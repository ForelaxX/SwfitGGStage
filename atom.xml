<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2017-07-18T01:30:41.000Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何检测摇一摇手势</title>
    <link href="https://swift.gg/2017/07/18/detect-shake-gestures-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/07/18/detect-shake-gestures-ios-tutorial-ios10/</id>
    <published>2017-07-17T16:00:00.000Z</published>
    <updated>2017-07-18T01:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/detect-shake-gestures-ios-tutorial-ios10" target="_blank" rel="external">原文链接</a>，原文日期：2017-04-18<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<p>iOS 设备可以检测摇一摇手势，在本节教程中，我们将学习如何检测摇一摇手势，检测到该手势后，更新 label 的文案。本节教程使用的是 Xcode 8.3 和 iOS 10.3。<br><a id="more"></a></p>
<h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，创建一个 Single View Application。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/single-view-xcode-templateformat=1500w1500341429.27" alt=""></p>
<p>Product Name 使用 <strong>IOS10ShakeGestureTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-projectformat=1500w1500341431.78" alt=""></p>
<p>打开 <strong>Storyboard</strong>，从 Object Library 中拖拽一个 Label 控件放到 View Controller 上，双击 Label 控件将文案修改为 <em>“Shake me”</em>。选中该 Label，点击 Auto Layout 的 Align 按钮。选中 “Horizontally in Container”，点击 “Add 1 Constraint”。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/auto-layout-horizontally-in-containerformat=750w1500341433.06" alt=""></p>
<p>选中 Label，点击 Auto Layout 的 Pin 按钮，选中上边距约束线，点击 “Add 1 Constraint”。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/auto-layout-pin-to-topformat=750w1500341433.89" alt=""></p>
<p>Storyboard 看起来应如下图所示。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-storyboardformat=1000w1500341434.83" alt=""></p>
<p>打开 Assistant Editor，确保 <strong>ViewController.swift</strong> 可见。按住 Control 键，将 Label 拖拽到 ViewController 类下，创建下图的 Outlet。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-label-outletformat=750w1500341435.62" alt=""></p>
<p>打开 ViewController.swift 文件，首先要让 View Controller 回应点击事件，可以通过 ViewController FirstResponder 实现，添加下列方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">becomeFirstResponder</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，要想检测摇一摇手势，添加 <strong>motionEnded(_:with:)</strong> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">motionEnded</span><span class="params">(<span class="number">_</span> motion: UIEventSubtype, with event: UIEvent?)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> motion == .motionShake &#123;</div><div class="line">        shakeLabel.text = <span class="string">"Shaken, not stirred"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果确实是一个 Shake Gesture（摇一摇），那么 Label 的文案就会更新。运行工程，摇一摇测试机。可以点击 iOS 模拟器菜单栏 Hardware 选项下的 Shake Gesture 来摇一摇。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-simulatorformat=750w1500341436.36" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>IOS10ShakeGestureTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      如何检测摇一摇手势
    
    </summary>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="IOSCREATOR" scheme="https://swift.gg/tags/IOSCREATOR/"/>
    
  </entry>
  
  <entry>
    <title>iOS 教程：属性字符串</title>
    <link href="https://swift.gg/2017/07/17/attributed-strings-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/07/17/attributed-strings-ios-tutorial-ios10/</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-07-18T01:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/attributed-strings-ios-tutorial-ios10" target="_blank" rel="external">原文链接</a>，原文日期：2017-04-04<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>译者注：本文是之前一篇文章的更新版本，<a href="https://www.ioscreator.com/tutorials/attributed-strings-tutorial-ios8-swift" target="_blank" rel="external">旧文链接</a>，旧文使用的 Swift 版本不是 3.0，本文更新了代码，升级到了 Swift 3.0。</p>
</blockquote>
<p>属性字符串（Attributed Strings）可以为文本赋予各种各样的属性，还能一次给（部分）文本赋值多个属性。在本节教程中，将学会给 label 文本里的每个单词各设置不一样的样式。本节教程使用的是 Xcode 8 和 iOS 10。<br><a id="more"></a></p>
<p>打开 Xcode，创建一个 Single View Application。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/single-view-xcode-templateformat=1500w1500254455.03" alt=""></p>
<p>Product Name 使用 <strong>IOS10AttributedStringsTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/attributed-strings-projectformat=1500w1500254455.98" alt=""></p>
<p>打开 <strong>Storyboard</strong>，从 Object-Library（控件库）中拖拽一个 Label 控件到主界面，点击 Storyboard 右下角 Auto Layout 的 Align 按钮，添加下图所示约束，点击 “Add 1 Constraint”。。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/auto-layout-horizontally-in-containerformat=750w1500254456.86" alt=""></p>
<p>点击 Auto Layout 的 Pin 按钮，添加如下图所示约束，点击 “Add 1 Constraint”。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/auto-layout-pin--to-topformat=750w1500254457.69" alt=""></p>
<p>点击 Assistant Editor，确保 <strong>ViewController.swift</strong> 文件可见。按住 Control 键，将 Label 控件拖拽到 ViewController 类下面，创建下列 Outlet 连接。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/attributes-label-outletformat=750w1500254459.19" alt=""></p>
<p>打开 <strong>ViewController.swift</strong> 文件，如下所示对 <strong>viewDidLoad</strong> 方法进行修改。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">    <span class="comment">// 1</span></div><div class="line">    <span class="keyword">let</span> string = <span class="string">"Testing Attributed Strings"</span></div><div class="line">    <span class="keyword">let</span> attributedString = <span class="type">NSMutableAttributedString</span>(string: string)</div><div class="line">        </div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">let</span> firstAttributes:[<span class="type">String</span>:<span class="type">Any</span>] = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.blue, <span class="type">NSBackgroundColorAttributeName</span>: <span class="type">UIColor</span>.yellow, <span class="type">NSUnderlineStyleAttributeName</span>: <span class="number">1</span>]</div><div class="line">    <span class="keyword">let</span> secondAttributes:[<span class="type">String</span>:<span class="type">Any</span>] = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.red, <span class="type">NSBackgroundColorAttributeName</span>: <span class="type">UIColor</span>.blue, <span class="type">NSStrikethroughStyleAttributeName</span>: <span class="number">1</span>]</div><div class="line">    <span class="keyword">let</span> thirdAttributes:[<span class="type">String</span>:<span class="type">Any</span>] = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.green, <span class="type">NSBackgroundColorAttributeName</span>: <span class="type">UIColor</span>.black, <span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">40</span>)]</div><div class="line">        </div><div class="line">    <span class="comment">// 3</span></div><div class="line">    attributedString.addAttributes(firstAttributes, range: <span class="type">NSRange</span>(location: <span class="number">0</span>, length: <span class="number">8</span>))</div><div class="line">    attributedString.addAttributes(secondAttributes, range: <span class="type">NSRange</span>(location: <span class="number">8</span>, length: <span class="number">11</span>))</div><div class="line">    attributedString.addAttributes(thirdAttributes, range: <span class="type">NSRange</span>(location: <span class="number">19</span>, length: <span class="number">7</span>))</div><div class="line">        </div><div class="line">    <span class="comment">// 4</span></div><div class="line">    attributedLabel.attributedText = attributedString</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建一个普通的字符串，将会转换成多种属性字符串。</li>
<li>创建见 3 个字典，存储属性的键和值。</li>
<li>将属性添加到 <code>attributedString</code> 对象中。</li>
<li>最后，将属性字符串赋值给 Label。</li>
</ol>
<p><strong>运行</strong>程序，属性字符串的实现效果如下。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/attributed-strings-simulatorformat=750w1500254459.94" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>IOS10AttributedStringsTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      iOS 教程：属性字符串
    
    </summary>
    
      <category term="iOS" scheme="https://swift.gg/categories/iOS/"/>
    
      <category term="Swift 入门" scheme="https://swift.gg/categories/iOS/Swift-%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="IOSCREATOR" scheme="https://swift.gg/tags/IOSCREATOR/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #74</title>
    <link href="https://swift.gg/2017/07/16/swift_weekly_issue_74/"/>
    <id>https://swift.gg/2017/07/16/swift_weekly_issue_74/</id>
    <published>2017-07-15T16:00:00.000Z</published>
    <updated>2017-07-18T01:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-74/" target="_blank" rel="external">原文链接</a>，原文日期：2017-06-15<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="external">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="external">Cwift</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<p>WWDC 已经过去一周了，你有大概了解你的代码要怎么迁移到 Swift 4 吗？我最先接触到的是一堆警告，提示有多余的协议遵守，查证得知<a href="https://bugs.swift.org/browse/SR-5153" target="_blank" rel="external">这是个 bug</a>。但说回来，比起去年我花了两个星期迁移到 Swift 3 来说，这次的升级已经好很多了。</p>
<p>而且，牢记 Swift 3.2 版本实际是在 Swift 3 兼容模式下运行 Swift 4 的编译器（<code>-swift-version 3</code>，通过这届 WWDC，我理解了很多东西）。当你在浏览  <a href="https://bugs.swift.org/" target="_blank" rel="external">bugs.swift.org</a>  时记住这一点也会很有帮助。<br><a id="more"></a></p>
<blockquote>
<p>想要赞助 Swift Weekly Brief 吗? <a href="https://swiftweekly.github.io/sponsorship/" target="_blank" rel="external">点击此处了解更多</a>  </p>
</blockquote>
<h2 id="社区任务"><a href="#社区任务" class="headerlink" title="社区任务"></a>社区任务</h2><ul>
<li>SR-4866：Stack overflow: 空括号表达式语法分析错误</li>
<li>SR-4830：编译器的 log 加上颜色区分</li>
</ul>
<p>可以通过 <a href="https://github.com/SwiftWeekly/swiftweekly.github.io/compare" target="_blank" rel="external">pull request</a> 或者 <a href="https://twitter.com/swiftlybrief" target="_blank" rel="external">tweet</a> 提交任务。</p>
<h2 id="Swift-扩展"><a href="#Swift-扩展" class="headerlink" title="Swift 扩展"></a>Swift 扩展</h2><p>第 15 集： <a href="https://spec.fm/podcasts/swift-unwrapped/70809" target="_blank" rel="external">Swift 更新内容， Part 2</a></p>
<p>JP Simard 和 Jesse Squires 继续讨论 Swift 的更新内容</p>
<h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>John Sundell 写了篇<a href="https://www.swiftbysundell.com/posts/exploring-the-new-string-api-in-swift-4" target="_blank" rel="external">关于 Swift 4 新的字符串 API 的文章</a>，这篇文章包括了很多实用的例子，展示了如何在 Swift 日常开发中使用新的字符串 API。</p>
<p>Slava Pestov 在 Twitter <a href="https://twitter.com/slava_pestov/status/873751462630760449" target="_blank" rel="external">提了一个谜题</a>：<code>print(type{ })</code>会输出什么？为什么？（<a href="https://twitter.com/nicklockwood/status/873796388768841728" target="_blank" rel="external">答案在这里</a>）</p>
<p>Slava 也<a href="https://twitter.com/slava_pestov/status/873744097353256961" target="_blank" rel="external">强调了</a> Swift 编译器团队，自从 2014 年的<a href="https://github.com/apple/swift/commit/d8ce0b80cbb7732cb32b245f9fadd47c11a4b163" target="_blank" rel="external">这一个 commit</a> 开始已经修复了<strong>超过 5500 个 bug 了</strong>。</p>
<h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Slava Pestove <a href="https://github.com/apple/swift/pull/10195" target="_blank" rel="external">修复了一个 Swift 3.1 和 Swift 4 的 bug</a>， 当一个类的父类初始化方法是一个 Objective-C 里定义的类工厂方法时，Swift 可能会报错提示 <code>self.init</code> 会让 self 逃逸，所以不能通过编译。</p>
<p>Devin Coughlin <a href="https://github.com/apple/swift/pull/10191" target="_blank" rel="external">加入了对于 inout 的静态分析</a>，加强 Swift 4 的内存安全特性。</p>
<p>Nate Cook 给新的 Swift 4 的 stdlib <a href="https://github.com/apple/swift/pull/10229" target="_blank" rel="external">补充和修改了一大堆文档内容</a>。</p>
<p>Dave Abrahams 开了一个新的 PR 以便<a href="https://github.com/apple/swift/pull/10223" target="_blank" rel="external">改进 String 的性能</a>。</p>
<p>Roman Levenstein 减少了标准库的代码体积，大概 5-6% 左右，然后从主分支 <a href="https://github.com/apple/swift/pull/10263" target="_blank" rel="external">cherry-pick 了一个 patch</a> 到 Swift 4 分支。</p>
<h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>这周没有提案的更新！具体的可以到<a href="[Swift Evolution]https://apple.github.io/swift-evolution/">这里</a>查看。</p>
<h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>本周的讨论围绕 Swift-Evolution 邮件列表应该扮演什么角色的话题展开，因为邮件列表的责任是展示一些有帮助的讨论内容以及提案的审核结果，鉴于邮件主题是由 Swift 发布周期/阶段引导的，什么时候才应该把一个想法带入严肃的讨论中（也许这个想法跟当前开发阶段的主题毫无联系）很值得讨论。</p>
<p>Ted Kremenek 这么<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170612/037339.html" target="_blank" rel="external">写到</a>：</p>
<blockquote>
<p>各位：这是一个很好的讨论，很感谢大家对于这件事情的思考。这其实是 Ben Cohen 和我私下聊完之后，我们打算带着核心团队一起讨论这件事。  </p>
<p>[…]  </p>
<p>根据 Xiaodi 的观察，evolution 的列表对于推进当前开发目标内的提案的作用是最大的。有很多不同的主题大家想讨论，而且很明显所有人都有点焦虑，想要都参与但人的精力是有限的，很难每一个主题都深入地参与进去。也许把这些移到一个讨论版（我们一直想做，但一直没有精力做的一个东西），提供一个非正式的讨论社区，就像 Xiaodi 提到的 Swift.org 论坛那样的东西，但要把开发目标内外主题明确分开，让大家可以去讨论他们感兴趣的主题。  </p>
<p>[…]  </p>
</blockquote>
<p>如果你对于 Swift Evolution 的发展感兴趣的话，那可以考虑深入阅读，看看这个过程是如何围绕着“开发目标内”呈现有建设性的讨论，以及该如何处理那些不在“当前开发目标内”的想法。</p>
<p>Chris Lattner 在回顾 <a href="https://lists.swift.org/pipermail/swift-evolution//Week-of-Mon-20170612/037514.html" target="_blank" rel="external">SE-0110</a> 的一个<a href="https://lists.swift.org/pipermail/swift-evolution//Week-of-Mon-20170612/037514.html" target="_blank" rel="external">长期讨论</a>里做了回应：</p>
<blockquote>
<p>核心团队今天讨论了这件事情，大家一致认为需要为了重新获得语法的便捷性而做出改变。 讨论之后大家更倾向于（至少）保留闭包里使用括号展开元组的形式，但这件事情还需要更多的讨论。  </p>
<p>说一个题外话，给元组里面的元素命名的形式以后某个时间点应该会被取消掉。不仔细看的话，你能分清下面声明了哪个变量吗？：  </p>
<p><code>let (a : Int, b : Float) = foo()</code>  </p>
<p>?  </p>
</blockquote>
<p>我们在这里回顾一下<a href="https://swiftweekly.github.io/issue-72/" target="_blank" rel="external">第 72 期的周报</a>。在 Swift 4 里，n 个元素的元组已经不会在闭包里拓展为 n 个参数了（元组展平行为）。这意味着闭包将会接收一个元组类型的参数，而你需要手动去把它们展开。这很明显就不符合直觉，开发体验也很差。很高兴看到核心团队重新考虑这个决定！谁说 Swift-Evolution 不好的？😉</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有关 Swift 2 的<a href="https://twitter.com/jckarter/status/874397984712163331" target="_blank" rel="external">一些感想</a>🍺。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      Swift 周报
    
    </summary>
    
      <category term="Swift 进阶" scheme="https://swift.gg/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Jesse Squires" scheme="https://swift.gg/tags/Jesse-Squires/"/>
    
  </entry>
  
  <entry>
    <title>Swift 3.0 下 Notifications 与 userInfo 的使用</title>
    <link href="https://swift.gg/2017/06/13/notifications-and-userinfo-with-swift-3-0/"/>
    <id>https://swift.gg/2017/06/13/notifications-and-userinfo-with-swift-3-0/</id>
    <published>2017-06-12T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Joe，<a href="http://dev.iachieved.it/iachievedit/notifications-and-userinfo-with-swift-3-0/" target="_blank" rel="external">原文链接</a>，原文日期：2016-09-17<br>译者：<a href="undefined">Tony Han</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 3.0 版本给 Swift 语言带来了相当多的改变，包括去掉 Foundation 框架中 NS 前缀的 <a href="https://developer.apple.com/videos/play/wwdc2016/403/" target="_blank" rel="external">Great Renaming</a>。<code>NSThread</code> 被简写作 <code>Thread</code>，<code>NSData</code> 被简写作 <code>Data</code>，就是这个意思。</p>
<a id="more"></a>
<p>这意味着，需要更新通过 <code>userInfo</code> 使用 <code>NSNotificationCenter</code>，哦不，<code>NotificationCenter</code> 的用法。这是 Swift 2 和 Swift 3 之间的巨大差别。</p>
<p>现在获取默认的 <code>NotificationCenter</code> 的方法已经变成 <code>let nc = NotificationCenter.default</code>。另外，当接收到通知时，使用选择器的模型已经改变为指定要执行的代码块或函数。</p>
<p>例如，在 Swift 2 中这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> nc = <span class="type">NSNotificationCenter</span>.defaultCenter()</div><div class="line">nc.addObserver(<span class="keyword">self</span>, </div><div class="line">               selector: #selector(<span class="type">ViewController</span>.catchNotification),</div><div class="line">               name: <span class="string">"MyNotification"</span>, </div><div class="line">               object: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>而 Swift 3 中要这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span> <span class="comment">// 注意：default 是属性，不是方法调用</span></div><div class="line">nc.addObserver(forName:<span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>),</div><div class="line">               object:<span class="literal">nil</span>, queue:<span class="literal">nil</span>,</div><div class="line">               using:catchNotification)</div></pre></td></tr></table></figure>
<p>上面的例子设置了通知中心将 <code>MyNotification</code> 通知传递给具有 <code>(Notification) -&gt; Void</code> 方法签名的 <code>catchNotification</code> 函数。或者也可以使用闭包调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span> <span class="comment">// 注意：default 是属性，不是方法调用</span></div><div class="line">nc.addObserver(forName:<span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>),</div><div class="line">               object:<span class="literal">nil</span>, queue:<span class="literal">nil</span>) &#123;</div><div class="line">  notification <span class="keyword">in</span></div><div class="line">  <span class="comment">// 处理通知</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h4><p>下面看看如何发送通知。Swift 2.0 中的 <code>postNotificationName</code> 方法在 Swift 3.0 中已经被替换为 <code>post</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span></div><div class="line">nc.post(name:<span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>),</div><div class="line">        object: <span class="literal">nil</span>,</div><div class="line">        userInfo: [<span class="string">"message"</span>:<span class="string">"Hello there!"</span>, <span class="string">"date"</span>:<span class="type">Date</span>()])</div></pre></td></tr></table></figure>
<p><code>userInfo</code> 使用 <code>[AnyHashable：Any]?</code> 作为参数，这在 Swift 中被称作字典字面量。注意，<code>userInfo</code> 的值不需要统一类型（即 <code>Any</code> 所占位置）；这里发送了一个 <code>String</code> 类型和一个 <code>Date</code> 类型。</p>
<h4 id="处理通知"><a href="#处理通知" class="headerlink" title="处理通知"></a>处理通知</h4><p><code>guard</code> 语法用来从 <code>userInfo</code> 中解包并验证期望数据，这是一个很不错的方式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">catchNotification</span><span class="params">(notification:Notification)</span></span> -&gt; <span class="type">Void</span> &#123;</div><div class="line">  <span class="built_in">print</span>(<span class="string">"Catch notification"</span>)</div><div class="line">  </div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> userInfo = notification.userInfo,</div><div class="line">        <span class="keyword">let</span> message  = userInfo[<span class="string">"message"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</div><div class="line">        <span class="keyword">let</span> date     = userInfo[<span class="string">"date"</span>]    <span class="keyword">as</span>? <span class="type">Date</span> <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"No userInfo found in notification"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"Notification!"</span>,</div><div class="line">                                message:<span class="string">"<span class="subst">\(message)</span> received at <span class="subst">\(date)</span>"</span>,</div><div class="line">                                preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</div><div class="line">  alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</div><div class="line">  <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要验证 <code>guard</code> 的作用，可以使用 <code>String</code> 类型或其他的对象类型代替 <code>Date()</code> 来调用 <code>post</code> 方法。可以在控制台的输出中看到 <code>No userInfo found in notification</code>。</p>
<h4 id="实例源码"><a href="#实例源码" class="headerlink" title="实例源码"></a>实例源码</h4><p>可以在一个简单的 iOS 项目中尝试使用上面的代码。创建 <strong>Single View Application</strong> 项目，并且使用以下内容替换 <code>ViewController.swift</code> 中的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">let</span> myNotification = <span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span></div><div class="line">    nc.addObserver(forName:myNotification, object:<span class="literal">nil</span>, queue:<span class="literal">nil</span>, using:catchNotification)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidAppear(animated)</div><div class="line">    <span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span></div><div class="line">    nc.post(name:myNotification,</div><div class="line">            object: <span class="literal">nil</span>,</div><div class="line">            userInfo:[<span class="string">"message"</span>:<span class="string">"Hello there!"</span>, <span class="string">"date"</span>:<span class="type">Date</span>()])</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">catchNotification</span><span class="params">(notification:Notification)</span></span> -&gt; <span class="type">Void</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Catch notification"</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> userInfo = notification.userInfo,</div><div class="line">          <span class="keyword">let</span> message  = userInfo[<span class="string">"message"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</div><div class="line">          <span class="keyword">let</span> date     = userInfo[<span class="string">"date"</span>]    <span class="keyword">as</span>? <span class="type">Date</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"No userInfo found in notification"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"Notification!"</span>,</div><div class="line">                                  message:<span class="string">"<span class="subst">\(message)</span> received at <span class="subst">\(date)</span>"</span>,</div><div class="line">                                  preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</div><div class="line">    alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</div><div class="line">    <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li><code>Notification</code> 的“名字”不再是字符串类型，而是 <code>Notification.Name</code> 类型，因此在声明通知的时候使用 <code>let myNotification = Notification.Name(rawValue:&quot;MyNotification&quot;)</code>。这样可以允许我们在任何需要使用 <code>Notification.Name</code> 的地方来使用 <code>myNotification</code>，比如，<code>NotificationCenter.addObserver</code> 和 <code>NotificationCenter.post</code> 方法。</li>
<li>推荐使用分开的 <code>catchNotification</code> 方法而不是纠缠在一起的代码块。</li>
</ul>
<p>就是这样，简洁而有效！</p>
<h4 id="评论内容"><a href="#评论内容" class="headerlink" title="评论内容"></a>评论内容</h4><p>声明并使用通知的改进：</p>
<p>1) 首先声明通知名称：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Notification</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">MyNotification</span> = <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">"Notification.MyApp.MyNotification"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2) 使用通知名称发送通知：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: <span class="type">Notification</span>.<span class="type">MyApp</span>.<span class="type">MyNotification</span>, object: <span class="keyword">self</span>)</div></pre></td></tr></table></figure>
<p>3) 监听通知：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">Notification</span>.<span class="type">MyApp</span>.<span class="type">MyNotification</span>, object: <span class="literal">nil</span>, queue: <span class="type">OperationQueue</span>.main) &#123;</div><div class="line">      pNotification <span class="keyword">in</span></div><div class="line"> </div><div class="line">  <span class="comment">// Your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Joe，&lt;a href=&quot;http://dev.iachieved.it/iachievedit/notifications-and-userinfo-with-swift-3-0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-09-17&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;Tony Han&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 3.0 版本给 Swift 语言带来了相当多的改变，包括去掉 Foundation 框架中 NS 前缀的 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2016/403/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Great Renaming&lt;/a&gt;。&lt;code&gt;NSThread&lt;/code&gt; 被简写作 &lt;code&gt;Thread&lt;/code&gt;，&lt;code&gt;NSData&lt;/code&gt; 被简写作 &lt;code&gt;Data&lt;/code&gt;，就是这个意思。&lt;/p&gt;
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #73</title>
    <link href="https://swift.gg/2017/06/10/issue-73/"/>
    <id>https://swift.gg/2017/06/10/issue-73/</id>
    <published>2017-06-09T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-73/" target="_blank" rel="external">原文链接</a>，原文日期：2017-06-09<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="external">四娘</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>这周的事情很多！今天是 <a href="https://developer.apple.com/videos/wwdc2017/" target="_blank" rel="external">WWDC 2017</a> 的最后一天，Swift 4 随着 <a href="https://developer.apple.com/xcode/" target="_blank" rel="external">Xcode 9</a>，一起放出了开发者公测版。Xcode 和 Swift 都有好几个重大的改进和新的功能 — 这个版本真的很棒。整个<a href="https://twitter.com/ericasadun/status/871819962888802304" target="_blank" rel="external">社区</a>的<a href="https://twitter.com/SmileyKeith/status/871852588844556288" target="_blank" rel="external">反响</a><a href="https://twitter.com/fpillet/status/871987276187828224" target="_blank" rel="external">都</a><a href="https://twitter.com/chriseidhof/status/873066951739703296" target="_blank" rel="external">很</a><a href="https://twitter.com/tonyarnold/status/873017116298846208" target="_blank" rel="external">正</a><a href="https://twitter.com/ayanonagon/status/871850052498489344" target="_blank" rel="external">面</a>。恭喜 Apple 的 Xcode, Swift 和开发工具组！</p>
<a id="more"></a>
<blockquote>
<p>想要赞助 Swift Weekly Brief 吗？<a href="https://swiftweekly.github.io/sponsorship/" target="_blank" rel="external">点击此处了解更多</a>  </p>
</blockquote>
<h2 id="Swift-解包"><a href="#Swift-解包" class="headerlink" title="Swift 解包"></a>Swift 解包</h2><p>第 14 集：<a href="https://spec.fm/podcasts/swift-unwrapped/70808" target="_blank" rel="external">Swift 更新内容，Part 1</a></p>
<p>我们讨论了 Swift 4 里的一些新功能和改进。</p>
<h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>Apple <a href="https://www.apple.com/newsroom/2017/06/swift-playgrounds-expands-coding-education-to-robots-drones-and-musical-instruments/" target="_blank" rel="external">宣布</a> Swift Playgrounds 已经支持对玩具机器人和无人机的编程了。他们正与多家公司合作，包括 Lego, Sphero 等一众公司。 这件事情很棒很好玩，你可以在这里查看<a href="https://www.youtube.com/watch?v=v7926MzvXOQ" target="_blank" rel="external">相关视频</a>。</p>
<p>Erica Sadun 的新书 <a href="http://ericasadun.com/2017/06/01/swift-style-wwdc-sale/" target="_blank" rel="external">Swift Style</a> 这周正式开始销售。</p>
<p>objc.io 已经放出了他们的新书，<a href="https://www.objc.io/blog/2017/06/02/optimizing-collections/" target="_blank" rel="external">Optimizing Collections</a>。作者 <a href="https://twitter.com/lorentey" target="_blank" rel="external">Károly Lőrentey</a> 在这本书里介绍了如何使用 Swift 编写高效的自定义集合类型。</p>
<p><a href="https://developer.apple.com/news/?id=06052017d" target="_blank" rel="external">Xcode 9 beta 以及新的 SDK</a> 全都放出来啦！</p>
<h2 id="WWDC-里关于-Swift-的视频"><a href="#WWDC-里关于-Swift-的视频" class="headerlink" title="WWDC 里关于 Swift 的视频"></a>WWDC 里关于 Swift 的视频</h2><ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/402/" target="_blank" rel="external">What’s new in Swift</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/408/" target="_blank" rel="external">What’s new in Swift Playgrounds</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/416/" target="_blank" rel="external">Teaching with Swift Playgrounds</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/212/" target="_blank" rel="external">What’s new in Foundation</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/407/" target="_blank" rel="external">Understanding undefined behavior</a></li>
</ul>
<h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Rober Widmann <a href="https://github.com/apple/swift/pull/10175" target="_blank" rel="external">合并了修改</a>，使用了 Xcode 新的未定义行为检测器，来修复了一些未定义的行为。</p>
<p>Roman Levenstein <a href="https://github.com/apple/swift/pull/10096" target="_blank" rel="external">做了一些小调整</a>，让标准库的代码体积减少了 1.5% ！！！</p>
<p>Swift 服务端 API 工作组发布了一个<a href="https://github.com/swift-server/http" target="_blank" rel="external">新的 repo</a>，主要是关于跨平台 HTTP API 的开发。</p>
<p>Ben Cohen 向 <code>swift-4.0 分支</code><a href="https://github.com/apple/swift/pull/10161" target="_blank" rel="external">发起了一个合并的请求</a>，用于提高 substring 比较的性能。Nate Cook <a href="https://github.com/apple/swift/pull/10156" target="_blank" rel="external">也发起了一个提高字典效率的合并请求</a>，现在已经有<a href="https://github.com/apple/swift/pulls?utf8=✓&amp;q=is%3Apr%20%5B4.0%5D%20in%3Atitle" target="_blank" rel="external">好几个 Swift 4 的合并请求</a> 了，希望那些已经请求完成的合并请求可以尽快通过。我们应该可以在接下来的 beta 版里看到这些改进。</p>
<p>Slava Pestov <a href="https://github.com/apple/swift/pull/10162" target="_blank" rel="external">修复</a>了几个 Bug。👏</p>
<h2 id="正在-review-的提案"><a href="#正在-review-的提案" class="headerlink" title="正在 review 的提案"></a>正在 review 的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="external">SE-0180</a>：字符串索引类型统一，Dave Abrahams，<a href="https://lists.swift.org/pipermail/swift-evolution-announce/2017-June/000384.html" target="_blank" rel="external">正在 review</a></p>
<blockquote>
<p>现在 <code>String</code> 跟它的 <code>CharacterView</code> 共用一个 <code>Index</code> 类型，但 <code>UTF8View</code>，  <code>UTF16View</code> 以及 <code>UnicodeScalarView</code> 就不是了。这个提案重新定义了这几个类型的 <code>Index</code> 类型，让它们跟 <code>String</code> 保持一致。并且暴露一个公开的 <code>encodedOffset</code> 属性和构造器，用于序列化和反序列化 <code>String</code> 和 <code>Substring</code> 的索引值。  </p>
<p>[…]</p>
<p>这样的结果就是很多 API 都无法从原本的设计中获益，通常来说，一个 view 的索引如果可以在另一个 view 有对应的索引值的话，这些索引值的转换都应该在内部完成，而不是像现在这样需要写很多不必要的代码。 </p>
<p>[…]  </p>
<p>所有 String 的 view 都会使用同一种 Index 类型 (<code>String.Index</code>)，这样索引值就可以在内部进行转换，而不用显式地去完成。  </p>
<p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="external">查看原文…</a>  </p>
</blockquote>
<h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>Ted Kremenek 发布了<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170605/004751.html" target="_blank" rel="external">一个公告</a>，关于即将开源的重构工具，以及其它在 WWDC 公布的事情：</p>
<blockquote>
<p>今天下午在 WWDC 上，我们发布了 Xcode 9 里新的重构功能(支持 Swift，C，Objective-C 和 C++)。我们同时宣布将会把这个引擎的核心代码开源出来，包括 Xcode 编译时才会索引的新功能。 </p>
<p>大概会在接下来的几个星期里, 我们将会分阶段把这些代码发布出来： </p>
<ul>
<li><p>关于 Swift 的重构功能，我们还需要做一些收尾工作，例如文档的编写，我们想在发布之前完成。 Argyrios Kyrtzidis 和他的团队负责处理这个计划。  </p>
</li>
<li><p>关于 C/C++/Objective-C 的重构功能，我们想和 LLVM 社区一起完成然后并入 LLVM。第一阶段应该会在 swift-clang 的 repo 里完成，但是他们想做的不只是这些。Duncan Exon Smith 和他的团队负责这个计划。  </p>
</li>
<li><p>我们也会开源编译器对于编译时索引的支持，包括了 Clang 和 Swift。Argyrios 和他的团队负责推进这件事。关于 Clang 的改变他们应该会在也会在 swift-clang 上完成，然后跟 LLVM 社区讨论如何将他们并入 Clang 里。  </p>
</li>
<li><p>最后，我们将会把 Swift 迁移工具剩余的部分开源出来。Argyrios 和他的团队负责推进这件事情，这些修改只会在 Swift 仓库里完成。  </p>
</li>
</ul>
<p>和之前一样，我们还需要完成 Swift 与 Apple 最新的 SDK 的桥接工作。希望可以在下周之前完成，之后我们就会暂时关闭仓库的 commit 权限。相关的细节之后会通过邮件公布。在此之前， Swift.org 的可下载的工具链都可以跟 Xcode 8.3.2 交互。在这之后, 我们可下载的工具链就主要会面向 Xcode 9 beta。这件事情很必要，因为之后最上层的 API 会依赖于最新的 SDK。  </p>
</blockquote>
<p>Rick Ballard 发了一个关于 Swift 4 包管理器的<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170605/037002.html" target="_blank" rel="external">公告</a>:</p>
<blockquote>
<p>Hello, Swift Pacakage Manager 的社区。  </p>
<p>我想要汇报一下 Swift 4 里 SwiftPM 的开发进度。我们已经在这个春季实现了一系列的 evolution 提案： </p>
<ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0152-package-manager-tools-version.md" target="_blank" rel="external">SE-0152</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0158-package-manager-manifest-api-redesign.md" target="_blank" rel="external">SE-0158</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0151-package-manager-swift-language-compatibility-version.md" target="_blank" rel="external">SE-0151</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0146-package-manager-product-definitions.md" target="_blank" rel="external">SE-0146</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0175-package-manager-revised-dependency-resolution.md" target="_blank" rel="external">SE-0175</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0150-package-manager-branch-support.md" target="_blank" rel="external">SE-0150</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0162-package-manager-custom-target-layouts.md" target="_blank" rel="external">SE-0162</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0149-package-manager-top-of-tree.md" target="_blank" rel="external">SE-0149</a> […]  </li>
</ul>
<p>除了这些提案，我们还实现了一些重大的改进： </p>
<ul>
<li><p>在 macOS 上，包的交互和包的编译现在都沙盒化了，能够减轻恶意软件带来的损耗。 </p>
</li>
<li><p>许多错误信息和诊断都加强了，包括依赖管理时出现的冲突。</p>
</li>
<li><p>Xcode 工程文件生成器也改进了，现在允许在重新生成工程文件时让 scheme 引用包里的 target。  </p>
</li>
<li><p>并且做了大量的小改进和 bug 修复。  </p>
</li>
</ul>
<p>Xcode 9 在新的编译系统里为 Swift 包管理提供了原生的支持。这个编译系统提供了灵活性和拓展性，让 Xcode 可以支持新的编译模型，例如 Swift 包管理。此外, SwiftPM 为 SwiftPM 的库做了大量的工作，让 Swift 包管理的工具可以轻松嵌入诸如 Xcode 的软件里。</p>
<p>那 SwiftPM 4 还有什么？首先，我们将会实现 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0179-swift-run-command.md" target="_blank" rel="external">SE-0179</a>，支持 <code>swift package run</code> 命令。另外，我们还希望开始放下现在的版本，然后开始计划后面，虽然我们还是在接收建议和 evolution 的提案   </p>
<p>[…]  </p>
<p>其它功能我们应该会考虑在下个版本进行支持，例如包资源(例如图片)，许可证和元数据支持，用于处理源代码控制分支的显式支持，以及一个泛用的机制去处理编译工具不支持包管理的情况。最后, 我们确实考虑了之后建立一个中心化的包索引机制，我们也许会在接下来一年为这件事情做一些基础工作。 </p>
<p><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170605/037002.html" target="_blank" rel="external">查看原文…</a>  </p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后 – <a href="https://twitter.com/NeoNacho/status/871143591258734594" target="_blank" rel="external">self storage</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Jesse Squires，&lt;a href=&quot;https://swiftweekly.github.io/issue-73/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-09&lt;br&gt;译者：&lt;a href=&quot;https://kemchenj.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;四娘&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这周的事情很多！今天是 &lt;a href=&quot;https://developer.apple.com/videos/wwdc2017/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WWDC 2017&lt;/a&gt; 的最后一天，Swift 4 随着 &lt;a href=&quot;https://developer.apple.com/xcode/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Xcode 9&lt;/a&gt;，一起放出了开发者公测版。Xcode 和 Swift 都有好几个重大的改进和新的功能 — 这个版本真的很棒。整个&lt;a href=&quot;https://twitter.com/ericasadun/status/871819962888802304&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;社区&lt;/a&gt;的&lt;a href=&quot;https://twitter.com/SmileyKeith/status/871852588844556288&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;反响&lt;/a&gt;&lt;a href=&quot;https://twitter.com/fpillet/status/871987276187828224&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;都&lt;/a&gt;&lt;a href=&quot;https://twitter.com/chriseidhof/status/873066951739703296&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;很&lt;/a&gt;&lt;a href=&quot;https://twitter.com/tonyarnold/status/873017116298846208&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;正&lt;/a&gt;&lt;a href=&quot;https://twitter.com/ayanonagon/status/871850052498489344&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;面&lt;/a&gt;。恭喜 Apple 的 Xcode, Swift 和开发工具组！&lt;/p&gt;
    
    </summary>
    
      <category term="Jesse Squires" scheme="https://swift.gg/categories/Jesse-Squires/"/>
    
    
      <category term="Swift 周报" scheme="https://swift.gg/tags/Swift-%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>把代码迁移到协调器上</title>
    <link href="https://swift.gg/2017/06/09/migrating-to-coordinators/"/>
    <id>https://swift.gg/2017/06/09/migrating-to-coordinators/</id>
    <published>2017-06-08T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/04/migrating-to-coordinators/" target="_blank" rel="external">原文链接</a>，原文日期：2017-4-25<br>译者：<a href="http://weibo.com/277195544" target="_blank" rel="external">Cwift</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>这篇文章是 <a href="http://khanlou.com/tag/advanced-coordinators/" target="_blank" rel="external">Coordinators（协调器）进阶教程系列</a>的第一篇。如果你没有阅读过<a href="http://khanlou.com/2015/01/the-coordinator/" target="_blank" rel="external">原始的帖子</a>及其<a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="external">后续</a>，请务必首先查阅这些文章。该系列将涵盖几项进阶的 Coordinator 使用技巧、疑点、常见问题以及其他细碎的内容。让我们开始吧。</p>
<a id="more"></a>
<p>常有人问我，如何把一个使用 Storyboard 构建或者是使用纯代码编写 ViewController 构建的应用重构成使用 Coordinators 的应用。只要方法正确，重构可以逐步完成。即使重构未完成，你的应用仍旧可以部署。</p>
<p>要实现这个目标，最好的做法是从根路径出发，在 Coordinators 中称之为 “AppCoordinator”。AppDelegate 持有该 AppCoordinator，AppCoordinator 调度 App 可以加载的所有 ViewController。</p>
<p>想要理解为什么从 App 的根路径开始，可以从反面来思考。如果从一些叶子流程开始（比如，一个 <code>CheckoutCoordinator</code>），那么需要保持对该 Coordinator 的强引用，以防它被释放。如果 Coordinator 被释放，它内部的代码就都不能执行了。所以，深入一个 App 中去，如果我们创建一个 Coordinator，必须让某个对象长久地持有它。</p>
<p>有两种方案可以防止对象被释放。第一种方案是使用静态引用。因为系统里可能只有一个 <code>CheckoutCoordinator</code>，所以很容易将其填充到一个全局变量中。虽然这种方案有效果，但是不是一个理想的选择，因为全局变量阻碍了可测试性和灵活性。第二种方案是让当前展示的 ViewController 持有 Coordinator。这将迫使当前的 ViewController 变得复杂一些，但是可以降低 Coordinator 所管理的所有 ViewController 的复杂性。然而，这种关系本质上是有缺陷的。ViewController 是 Coordinator 的“孩子”，编程时，孩子们不应该不知道他们的父母是谁。类似于一个 <code>UIView</code> 持有了一个 <code>UIViewController</code> 的引用：这种事是不该发生的。</p>
<p>如果你遇到了必须从子流程开始的情况，你可以使用上述两种方法之一。但是，如果可以选择，我的建议是从根路径开始。</p>
<p>从根路径开始的另一个好处是认证流程通常更靠近 App 的根路径。身份认证是一个很好的流程，可以抽象成单独的对象，很适合用来验证 App 中的 Coordinator。</p>
<p>将 App 的 RootViewController 交付给 <code>AppCoordinator</code> 之后，你可以对代码进行 Commit/Pull Request/Code Review。因为其他的 ViewController 仍在正常运转，所以 App 可以在这个未完工的状态下继续工作。基于这点，逐步改造，你可以将更多的 ViewController 交付给 Coordinator。将每个“流程”都交付给 Coordinator 之后，你可以提交代码或者创建一个 pr，不会影响 App 的正常工作。正如最佳重构一样，这些步骤只是移动代码，有时根据需要创建新的 Coordinator。</p>
<p>一旦所有的场景切换都转移到了 Coordinator 中，你就可以开始下一步的重构了，例如将 iPhone 和 iPad 的 Coordinator 封装到单独的对象（而不是一个切换状态的 Coordinator），让子流程可复用，更好地依赖注入，这些都可以应用到你的新架构中。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2017/04/migrating-to-coordinators/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-4-25&lt;br&gt;译者：&lt;a href=&quot;http://weibo.com/277195544&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cwift&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这篇文章是 &lt;a href=&quot;http://khanlou.com/tag/advanced-coordinators/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Coordinators（协调器）进阶教程系列&lt;/a&gt;的第一篇。如果你没有阅读过&lt;a href=&quot;http://khanlou.com/2015/01/the-coordinator/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始的帖子&lt;/a&gt;及其&lt;a href=&quot;http://khanlou.com/2015/10/coordinators-redux/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;后续&lt;/a&gt;，请务必首先查阅这些文章。该系列将涵盖几项进阶的 Coordinator 使用技巧、疑点、常见问题以及其他细碎的内容。让我们开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Table View 中开启文本菜单功能</title>
    <link href="https://swift.gg/2017/06/09/use-context-menu-with-table-view-tutorial-ios10/"/>
    <id>https://swift.gg/2017/06/09/use-context-menu-with-table-view-tutorial-ios10/</id>
    <published>2017-06-08T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/use-context-menu-with-table-view-tutorial-ios10" target="_blank" rel="external">原文链接</a>，原文日期：2017-01-09</p>
<h2 id="译者：Crystal-Sun；校对：walkingway；定稿：CMB"><a href="#译者：Crystal-Sun；校对：walkingway；定稿：CMB" class="headerlink" title="译者：Crystal Sun；校对：walkingway；定稿：CMB"></a>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></h2></blockquote>
<!--此处开始正文-->
<p>长按所选的对象后，弹出文本菜单（Context Menu），允许用户进行剪切、复制、粘贴操作。默认情况下，文本菜单功能在 Table View 中是关闭状态。在本节教程中，将学习如何在 Table View Cell 中开启文本菜单功能，将所选的文本复制到 Text Filed（文本输入框）中。本节教程使用的是 Xcode 8.1 和 iOS 10。</p>
<a id="more"></a>
<h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，创建一个 Single View Application。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58ff88928419c2b2a27d0754/1493141675229/single-view-xcode-template?format=1500w" alt=""></p>
<p>点击 Next。Product Name 使用 <strong>IOS10ContextMenuTableViewTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587284518419c2902d0b4038/1483899997903/?format=1500w" alt=""></p>
<p>打开 <strong>Main.storyboard</strong> 文件，从 Object Library 中拖拽一个 Table View 到主界面，然后选中 Table View，找到 Attribute Inspector，在 Table View 部分，将 Prototype Cells 的值改为1。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728478414fb539f1673cc0/1483900034219/?format=500w" alt=""></p>
<p>选中 Table View Cell，找到 Attribute Inspector ，在 Table View Cell 区域，将 Indentifier 的值设置为 “cell”。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728493bf629afa514967a5/1483900060894/?format=750w" alt=""></p>
<p>选中 Table View，点击右下角的 Pin 按钮，点击上方、左、右三条线，选择 Height，设置成固定高度。在 Update Frames 的下拉菜单中选择 Items of New Contraints，接下来点击 “Add 4 Constraints”。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587284b5725e2549f7b0a58c/1483900094417/?format=750w" alt=""></p>
<p>从 Object Library 中拖拽一个 Text Field 控件，放到 Table View 的下方。按住 Control 键，将其拖拽到 Table View 上，松开 Control 键，选择 “Vertical Spacing” 和 “Center Horizontally”。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587285ead1758edd735361d8/1483900403738/Autolayout-Pinleftandright.png?format=500w" alt=""></p>
<p>选中 Text Field，点击右下角的 Pin 按钮，选中左、右两条线。如下图添加约束。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587286031e5b6c9fdaadb7b3/1483900432899/?format=750w" alt=""></p>
<p>View Controller 需要成为 Table View 的代理（delegate）。选中 TableView，按住 Control 键，将其拖拽到 View Controller 顶部的黄色图标上，点击 dataSource，重复上述步骤，点击 delegate。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728664bebafb08e6a84d26/1483900526787/?format=300w" alt=""></p>
<p>对 Text Field 控件也重复上述步骤，使 View Controller 成为 Text Field 的代理（delegate）。然后打开 <strong>ViewController.swift</strong> 文件，将类的声明改成如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITextFieldDelegate</span> </span>&#123;</div></pre></td></tr></table></figure>
<p>接着添加下列属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pasteBoard = <span class="type">UIPasteboard</span>.generalPasteboard()</div><div class="line"><span class="keyword">var</span> tableData: [<span class="type">String</span>] = [<span class="string">"dog"</span>,<span class="string">"cat"</span>,<span class="string">"fish"</span>]</div></pre></td></tr></table></figure>
<p>pasteBoard 属性将用于复制粘贴操作，tableData 存储展示在 Table View Cell 上的数据。接下来，如下所示修改 Table View 的 delegate 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> tableData.<span class="built_in">count</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>, <span class="keyword">for</span>: indexPath)</div><div class="line">        </div><div class="line">    cell.textLabel?.text = tableData[indexPath.row]</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> cell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Table View 现在会展示 tableData 数组中的值，想要开启文本菜单功能，需要实现以下三个 delegate 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, shouldShowMenuForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">Bool</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, canPerformAction action: Selector, forRowAt indexPath: IndexPath, withSender sender: Any?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">if</span> (action == #selector(<span class="type">UIResponderStandardEditActions</span>.copy(<span class="number">_</span>:))) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, performAction action: Selector, forRowAt indexPath: IndexPath, withSender sender: Any?)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> cell = tableView.cellForRow(at: indexPath)</div><div class="line">    pasteBoard.string = cell!.textLabel?.text</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>tableView:shouldShowMenuForRowAt</strong> 方法必须返回 true，才能长按显示文本菜单。<strong>tableView:canPerformAction:forRowAt</strong> 方法，让文本菜单只显示 copy（复制）一个选项。<strong>tableView:performAction:forRowAt:withSender</strong> 方法将选中的文本复制到 pasteBoard 变量中。</p>
<p>最后，通过 <strong>textFieldShouldReturn</strong> 方法，在点击 Text Field 后让键盘消失。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">self</span>.view.endEditing(<span class="literal">true</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>运行</strong>工程，长按一行 Table View Cell，然后选择 copy（复制） 选项，粘贴到 Text Field（文本框）里。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728d2c1b631b6a2299ad67/1483902262012/?format=750w" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>IOS10ContextMenuTableViewTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/use-context-menu-with-table-view-tutorial-ios10&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-01-09&lt;/p&gt;
&lt;h2 id=&quot;译者：Crystal-Sun；校对：walkingway；定稿：CMB&quot;&gt;&lt;a href=&quot;#译者：Crystal-Sun；校对：walkingway；定稿：CMB&quot; class=&quot;headerlink&quot; title=&quot;译者：Crystal Sun；校对：walkingway；定稿：CMB&quot;&gt;&lt;/a&gt;译者：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/h2&gt;&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;长按所选的对象后，弹出文本菜单（Context Menu），允许用户进行剪切、复制、粘贴操作。默认情况下，文本菜单功能在 Table View 中是关闭状态。在本节教程中，将学习如何在 Table View Cell 中开启文本菜单功能，将所选的文本复制到 Text Filed（文本输入框）中。本节教程使用的是 Xcode 8.1 和 iOS 10。&lt;/p&gt;
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的安全性</title>
    <link href="https://swift.gg/2017/06/06/safety-in-swift/"/>
    <id>https://swift.gg/2017/06/06/safety-in-swift/</id>
    <published>2017-06-05T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/04/safety-in-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2017-04-05<br>译者：<a href="undefined">Doye</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 是一门注重安全性的语言，如<a href="https://Swift.org/" target="_blank" rel="external">Swift官网</a>的<a href="https://Swift.org/about/" target="_blank" rel="external">关于页面</a>中所言</p>
<blockquote>
<p>Swift 是一门通用编程语言，采用现代化的方法来保证安全性与性能，套用软件设计模式。</p>
</blockquote>
<a id="more"></a>
<p>还有它的说明</p>
<ul>
<li><p><strong>安全性</strong>：那些显而易见而又便捷的编程方法应该保证是安全的。未定义的行为会破坏软件的安全性。在软件发布之前就要把开发者的错误扼杀在萌芽之中。强调安全性有时会让你觉得 Swift 语法过于严苛，但是它带来的代码的明晰从长远来看还是利大于弊的。</p>
</li>
<li><p><strong>高性能</strong>: Swift旨在替代 C 系语言（C，C ++和Objective-C），因此 Swift 必须在绝大多数任务中与这些语言有着接近的性能指数，而且性能需要具有可预测性。而且这种指数需要是一种普遍的性能指数，而不是昙花一现的仅仅几种任务类型的高性能。具有各种特性的语言有很多，但仍保持着如此高性能却实属罕见。</p>
</li>
<li><p><strong>表现力</strong>:  Swift 受益于计算机科学的几十年发展，提供了开发人员期望的现代功能并具有有趣的语法。而且 Swift 并不止步于此，Swift 社群会关注编程语言的发展并取其精华，使得 Swift 一直保持进化，变得更好。</p>
</li>
</ul>
<p>举例来说，类似 <strong>Optional</strong> 这种类型就是 Swift 考虑安全性的一个体现，在其他的编程语言当中，你并不能知道哪个变量可以为空(null)哪个不能，而 <strong>Optional</strong> 携带着改变量可能为空的信息，这就强制开发者去考虑可能为空的情况。对于”可空”（nullable）的类型，如果你用强解包符号（<strong>!</strong>）来处理该类型，有些时候它会直接 crash。Swift 的安全性相当于一条安全带，你可以自行解开它，但是风险也要自己来承担。</p>
<p>然而在某些情况下，安全性看起来并不足够。比如举例来说，如果我们有一个字典，我们需要通过一些 key 来提取到返回值类型为 optional 的 value</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> person: [<span class="type">String</span>: <span class="type">String</span>] = <span class="comment">//...</span></div><div class="line">type(of: person[<span class="string">"name"</span>]) <span class="comment">// =&gt; Optional&lt;String&gt;</span></div></pre></td></tr></table></figure>
<p>但是如果我们对数组进行类似的操作，我们并不会得到一个 optional:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> users: [<span class="type">User</span>] = <span class="comment">//...</span></div><div class="line">type(of: users[<span class="number">0</span>]) <span class="comment">// =&gt; User</span></div></pre></td></tr></table></figure>
<p>原因是数组可能没有元素，如果 <strong>users</strong> 的数组为空的话，这段程序将会直接crash，从这方面来看，好像Swift并没有做到足够安全。</p>
<p>Swift仍然在开放的演进中，你可能就此问题提些建议到 <a href="http://khanlou.com/2017/04/safety-in-swift/" target="_blank" rel="external">Swift evolution邮件组</a><br>不，那也不会有什么改变，在 <strong>Swift evolution</strong> 的 github 库里 <a href="https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md" target="_blank" rel="external">”常见驳回”提议页</a> 当中描述了不会接受这项提议：</p>
<ul>
<li>Array&lt; T &gt; 的下标获取操作不返回一个 <strong>T</strong> 而是返回一个 <strong>T?</strong> 或者 <strong>T!</strong>，当前的数组的逻辑是<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002446.html" target="_blank" rel="external">故意为之</a>，它准确反映了访问越界的数组下标是一个逻辑错误。如果改变目前的逻辑会降低数组的读取到一个无法接受的程度，这项提议<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002425.html" target="_blank" rel="external">提出多次</a>并不会被社区采纳。</li>
</ul>
<p>这里指出的原因是在这种特殊情况下，性能至关重要。但是如果我们回过头来看上面引用的关于页当中的信息，”安全性”的地位应该是高于”速度”的，难道安全性不应该比速度更为重要么？</p>
<p>这里存在着一个根本的争议点，在于”安全性”一词的定义。对于”安全性”一个普遍的理解是不 crash，而 Swift 核心成员的定义是”永远不会在无意中访问错误的内存”。</p>
<p>从这点来看，Swift 的下标操作是”安全的”，它永远都不会去访问在数组自身分配之外的内存，当你想访问数组越界的内存时它会立即 crash，如 Optional 类型避免了当前存在的各种空指针引用的 bug 一样，数组这里的考虑避免了缓冲区溢出的 bug。</p>
<p>Chris Lattner（Swift 作者）在<a href="https://overcast.fm/+CdTE-_oY/24:37" target="_blank" rel="external">这段采访</a>的24.39处有段说明</p>
<blockquote>
<p>我们采用的安全性策略是在综合的一种妥协。我们想使Swift成为一门安全的编程语言，但这种安全并不是没有bug，而是我们保障内存安全的的基础上同时提供高性能而且采用一直前进的编程语言范式。</p>
</blockquote>
<p>或许，内存安全相对于安全是一个更好的名词，有些开发者可能更偏向于得到一个 optional 的返回值，而不是在数组越界访问的问题里纠结，每个人都同意直接让程序crash会好过让程序携带着非法的数据继续运行下去，而这种情况还可能会被栈溢出的攻击所利用。</p>
<p>第二种权衡（直接 crash 而不是允许越界访问）的决定看起来显而易见，但是有些语言不会做这种保证，在 C 中，访问越界的数组将会导致未知的行为（具体取决于使用的编译器对这种行为的实现），在 Swift 中开发者会快速的意识到自己犯了类似数组越界的错误，Swift团队觉得这是一个合适的 crash 时机，所以并不会返回一个 optional 甚至是返回一段未知的数据。</p>
<p>使用这里”安全”的定义也明确了”不安全”的 API 的定义，因为它们直接访问内存进行编程，程序员们自己必须十分小心保证自己不会访问到无效的内存，这点尤为困难，即使专家在这种情景也会犯错，如果对这个主题感兴趣去查阅 <a href="https://www.cocoawithlove.com/blog/2016/02/16/use_it_or_lose_it_why_safe_c_is_sometimes_unsafe_swift.html" target="_blank" rel="external">Matt Gallagher的博客</a>中以安全的方式桥接 C 到 Swift 的相关讨论。</p>
<p>Swift 的团队对于安全的定义可能与你预想的并不完全一致，但是它们的种种策略确实可以避免大多数的程序员去考虑各种常见的 bug，将“安全”的定义细化为“内存安全”可以让我更好的理解 Swift 团队对于安全的定义。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2017/04/safety-in-swift/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-04-05&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;Doye&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 是一门注重安全性的语言，如&lt;a href=&quot;https://Swift.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swift官网&lt;/a&gt;的&lt;a href=&quot;https://Swift.org/about/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于页面&lt;/a&gt;中所言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Swift 是一门通用编程语言，采用现代化的方法来保证安全性与性能，套用软件设计模式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="khanlou.com" scheme="https://swift.gg/categories/khanlou-com/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>[Jinkey 原创]震惊！iOS 系统居然自带悬浮窗口调试工具</title>
    <link href="https://swift.gg/2017/05/27/ui-debugging-information-overlay/"/>
    <id>https://swift.gg/2017/05/27/ui-debugging-information-overlay/</id>
    <published>2017-05-26T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>原文链接 : <a href="http://www.jianshu.com/p/736353b5cfaf?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends&amp;from=singlemessage&amp;isappinstalled=1" target="_blank" rel="external">震惊！iOS 系统居然自带悬浮窗口调试工具 —— Jinkey 原创</a></li>
<li>原文作者 : <a href="http://www.jianshu.com/u/8354f5625fe4" target="_blank" rel="external">Jinkey</a></li>
</ul>
</blockquote>
<!--此处开始正文-->
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><blockquote>
<p>英文原文：<br><a href="http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/" target="_blank" rel="external">http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/</a></p>
<p>我写得这个并不是翻译而是用自己的理解重新表述这个功能，和原文内容有出入，有能力的可以查看英文原文。</p>
</blockquote>
<p>我们经常使用各种调试工具，或者开源库来支持悬浮窗调试信息，但苹果的私有方法就提供了 <code>UIDebuggingInformationOverlay</code> 。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-2ef0080f4eea8935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<h2 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2 如何使用"></a>2 如何使用</h2><p>在 <code>AppDelegate</code> 的 <code>didFinishLaunchingWithOptions</code> 方法中加入两行代码即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> overlayClass = <span class="type">NSClassFromString</span>(<span class="string">"UIDebuggingInformationOverlay"</span>) <span class="keyword">as</span>? <span class="type">UIWindow</span>.<span class="type">Type</span></div><div class="line"><span class="number">_</span> = overlayClass?.perform(<span class="type">NSSelectorFromString</span>(<span class="string">"prepareDebuggingOverlay"</span>))</div></pre></td></tr></table></figure>
<p>运行程序后，两根手指点击状态栏即可调起这个调试的悬浮层。</p>
<h2 id="3-能做什么"><a href="#3-能做什么" class="headerlink" title="3 能做什么"></a>3 能做什么</h2><h3 id="3-1-查看整个-window-的-View-嵌套关系"><a href="#3-1-查看整个-window-的-View-嵌套关系" class="headerlink" title="3.1 查看整个 window 的 View 嵌套关系"></a>3.1 查看整个 <code>window</code> 的 <code>View</code> 嵌套关系</h3><blockquote>
<p>View Hierarchy</p>
</blockquote>
<p>这个功能可以查看页面层级的结构树，点击感叹号进入详情页（点 <code>cell</code>  是没反应的），会展示那个 <code>view</code> 的 <code>frame</code> 、 <code>bounds</code> 和其他一些实例变量。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-66b7d3e56dd27cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="3-2-查看当前-ViewController-的属性"><a href="#3-2-查看当前-ViewController-的属性" class="headerlink" title="3.2 查看当前 ViewController 的属性"></a>3.2 查看当前 <code>ViewController</code> 的属性</h3><blockquote>
<p>VC Hierarchy</p>
</blockquote>
<p>查看激活的 <code>ViewController</code> 的 <code>childrenViewCotroller</code> 的结构树和相关属性：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-bbae2392b4a80173.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="3-3-查看-UIApplication-的成员属性"><a href="#3-3-查看-UIApplication-的成员属性" class="headerlink" title="3.3 查看 UIApplication 的成员属性"></a>3.3 查看 <code>UIApplication</code> 的成员属性</h3><blockquote>
<p>Ivar Explorer</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-04044fb28c7d6910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="3-4-测量组件大小"><a href="#3-4-测量组件大小" class="headerlink" title="3.4 测量组件大小"></a>3.4 测量组件大小</h3><blockquote>
<p>Measure</p>
</blockquote>
<p>一开始还挺懵逼不知道要怎么用，后来发现手指是直接在悬浮窗的外部进行进行拖动就可以了，如果你的组件被悬浮窗挡住了好像就没办法了。<br><br>选择 Vertical ，手指在屏幕拖动即可显示某个组件的高度；<br><br>选择 Horizontal ，手指在屏幕拖动即可显示某个组件的 宽度；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-7f0f0d183cc50196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="3-5-效果对比"><a href="#3-5-效果对比" class="headerlink" title="3.5 效果对比"></a>3.5 效果对比</h3><blockquote>
<p>Spec Compare</p>
</blockquote>
<p>从相册读取一个图片（你必须在info.plist 先配置相册权限NSPhotoLibraryUsageDescription）和当前界面对比。</p>
<p>点击 Add -&gt; 从相册选择一个界面截图 -&gt; 点击刚添加的截图 -&gt; 手指在屏幕（悬浮窗外部）上下滑动 -&gt; 即可动态改变截图的透明度来对比截图和当前界面的差异 -&gt; 双击退出。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-d8eae18f88927c88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我的微信公众号 <code>jinkey-love</code> 欢迎交流</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 : &lt;a href=&quot;http://www.jianshu.com/p/736353b5cfaf?utm_campaign=hugo&amp;amp;utm_medium=reader_share&amp;amp;utm_content=note&amp;amp;utm_source=weixin-friends&amp;amp;from=singlemessage&amp;amp;isappinstalled=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;震惊！iOS 系统居然自带悬浮窗口调试工具 —— Jinkey 原创&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者 : &lt;a href=&quot;http://www.jianshu.com/u/8354f5625fe4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jinkey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1 背景&quot;&gt;&lt;/a&gt;1 背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;英文原文：&lt;br&gt;&lt;a href=&quot;http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我写得这个并不是翻译而是用自己的理解重新表述这个功能，和原文内容有出入，有能力的可以查看英文原文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们经常使用各种调试工具，或者开源库来支持悬浮窗调试信息，但苹果的私有方法就提供了 &lt;code&gt;UIDebuggingInformationOverlay&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/854231-2ef0080f4eea8935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="投稿" scheme="https://swift.gg/categories/%E6%8A%95%E7%A8%BF/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>给每一个 Swift 版本设定开发主题</title>
    <link href="https://swift.gg/2017/05/26/swift-themed-releases/"/>
    <id>https://swift.gg/2017/05/26/swift-themed-releases/</id>
    <published>2017-05-25T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/03/swift-themed-releases/" target="_blank" rel="external">原文链接</a>，原文日期：2017-03-20<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="external">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="external">Cwift</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>大概一个星期之前，<a href="https://swift.org/community/#core-team" target="_blank" rel="external">Swift 核心团队</a>成员 Ben Cohen 在 <a href="https://swift.org/community/#swift-evolution" target="_blank" rel="external">Swift-Evolution</a> 发了<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170306/033699.html" target="_blank" rel="external">一条的很值得思考的信息</a>，回答了一个<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170220/033092.html" target="_blank" rel="external">问题</a> — 再给 <a href="https://github.com/apple/swift/blob/master/CHANGELOG.md#swift-40" target="_blank" rel="external">Swift 4</a> 提一个新提案, 被通过的几率有多大。</p>
<p>Ben 阐述了核心团队决定提案是否要推迟的主要依据。主旨就是 Swift 每一个版本都应该专注于一小部分主题，符合主题的提案给予更高的优先级。</p>
<a id="more"></a>
<p>我认为 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170306/033699.html" target="_blank" rel="external">这篇文章</a> 并没有引起足够的重视，这也是为什么我把它完全引用过来的原因(链接和注解是我自己加的)：</p>
<blockquote>
<p><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html" target="_blank" rel="external">Swift 4 的主题</a>设定好之后，一些不符合主题的提案还是进入了我们的讨论，这显得一点意义也没有。例如一些关于 <a href="https://developer.apple.com/reference/swift/string" target="_blank" rel="external">String</a> ， <a href="https://developer.apple.com/reference/swift/dictionary" target="_blank" rel="external">Dictionary</a> 和 <a href="https://developer.apple.com/reference/swift/sequence" target="_blank" rel="external">Sequence</a> / <a href="https://developer.apple.com/reference/swift/collection" target="_blank" rel="external">Collection</a> 的提案被采纳。在 Swift 接下来的版本里，很可能这些与目标不符合的提案，例如 String 进一步的完善(原生的正则表达式)，move-only 类型，异步，反射，或者是泛型的加强，都会进入讨论。<strong>我们觉得专注于特定的主题对于一门语言的演变特别重要，这些散乱的，与当前开发主题无关的提案，应该要设置更高的采纳门槛。</strong></p>
<p>其中一个原因是核心团队和社区的精力有限。专注一部分目标进行讨论，可以让别的社区更容易参与到我们的讨论里(尽管<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170206/031657.html" target="_blank" rel="external">加入提案模板</a>也会有帮助)。而且如果保证每一个提案都能够为这个阶段的目标服务，我们就可以避免一些提案虽然被采纳，但从未有机会实现的情况出现。  </p>
<p>此外，专注于某个目标进行讨论时，针对这个目标，我们可以有完成度更高，更加具有一致性的功能设计。可以探讨如何在 Swift 4 里把<a href="https://github.com/apple/swift/blob/master/CHANGELOG.md#swift-40" target="_blank" rel="external">所有新的泛型功能</a>合理地组合到一起，构建一个完善，高度一致的体系，让我们更容易使用和理解。或者是新的字符串功能如何<a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md" target="_blank" rel="external">更加便捷地处理字符串</a>。<strong>一方面是向大家传递 Swift 4 想要完成的目标，一方面更利于我们去完成一个条理清晰，连贯的设计。</strong></p>
<p>一个条理清晰的设计不止对于版本的迭代很重要 — 因为这可以让开发者更容易学习使用新功能，<strong>而且对于语言的长期发展也是一样重要。</strong>没有明确目标的提案，会让我们非常难理解单个提案怎么融入到 Swift 整体的发展方向里。我们想要避免进行了一些局部的改进过后，后续再次触及相关的部分时，却发现当时的改进并不符合整体设计。同时还有一种情况是，我们考虑了太多分开看起来很合理的功能，但将它们拼凑到一起时却并不合适。  </p>
<p>例如，最近的一些提案围绕着<a href="https://github.com/DevAndArtist/swift-evolution/blob/refactor_existential_metatypes/proposals/0126-refactor-metatypes.md" target="_blank" rel="external">重构 meta types</a> ，但这必须在反射这个大框架下讨论才可以，所以我们应该等到这个主题被提上议程再去讨论。另外一个例子: 最近的提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0154-dictionary-key-and-value-collections.md" target="_blank" rel="external">SE-154</a> 提议可以自定义存储字典键值对的集合，这种做法并没有降低耦合度，它只是提供了一种略微笨重的方式去解决问题 — 给字典提供一个初始值，然后去更新这个值。但它需要作为<a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md" target="_blank" rel="external">ABI 稳定</a>的一部分去思考。这也是我们决定在 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170213/032116.html" target="_blank" rel="external">第二阶段</a> <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170213/032118.html" target="_blank" rel="external">展开关于字典的讨论</a>的原因。  </p>
<p>对于 <a href="https://github.com/apple/swift-evolution/blob/master/releases/swift-3_0.md" target="_blank" rel="external">Swift 3</a> 和 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html" target="_blank" rel="external">Swift 4</a> ，核心团队给每一个版本都设定了主题。<strong>核心团队想要在这个过程中，让社区更早加入到讨论中，帮助核心团队决定接下来的目标，但也会同时思考更好的方式。</strong></p>
</blockquote>
<p>Swift 4.0 的开发周期已经过半，但还不能太早决定接下来 Swift 5 的目标。 <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md" target="_blank" rel="external">ABI 稳定</a> 肯定优先，但除此之外呢？字符串再进一步的改进？异步？反射?</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/03/swift-themed-releases/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-03-20&lt;br&gt;译者：&lt;a href=&quot;https://kemchenj.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;四娘&lt;/a&gt;；校对：&lt;a href=&quot;http://weibo.com/277195544&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cwift&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;大概一个星期之前，&lt;a href=&quot;https://swift.org/community/#core-team&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swift 核心团队&lt;/a&gt;成员 Ben Cohen 在 &lt;a href=&quot;https://swift.org/community/#swift-evolution&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swift-Evolution&lt;/a&gt; 发了&lt;a href=&quot;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170306/033699.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一条的很值得思考的信息&lt;/a&gt;，回答了一个&lt;a href=&quot;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170220/033092.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;问题&lt;/a&gt; — 再给 &lt;a href=&quot;https://github.com/apple/swift/blob/master/CHANGELOG.md#swift-40&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swift 4&lt;/a&gt; 提一个新提案, 被通过的几率有多大。&lt;/p&gt;
&lt;p&gt;Ben 阐述了核心团队决定提案是否要推迟的主要依据。主旨就是 Swift 每一个版本都应该专注于一小部分主题，符合主题的提案给予更高的优先级。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>SpriteKit 技巧之添加背景图片</title>
    <link href="https://swift.gg/2017/05/19/display-background-with-spritekit-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/05/19/display-background-with-spritekit-ios-tutorial-ios10/</id>
    <published>2017-05-18T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/display-background-with-spritekit-ios-tutorial-ios10" target="_blank" rel="external">原文链接</a>，原文日期：2017/01/17<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>Sprite Kit 是硬件加速的动画系统，为创建 2D 游戏进行了专门的优化。在本节教程中，将使用 Game 模板来添加一张背景图片。本节教程使用的是 Xcode 8.2.1 和 iOS 10.2。</p>
<a id="more"></a>
<p>打开 Xcode，选择 iOS -&gt; Application -&gt; Game 模板。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587dfce23a04118eabdf7d95/1484651758293/?format=1500w" alt=""></p>
<p>Product Name 使用 <strong>SpriteKitBackgroundTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Game Technology 一栏选择 SpriteKit，Devices 一栏选择 iPhone。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58ff88c71b10e3c8c1dc6a0d/1493141718478/facebook-project?format=1500w" alt=""></p>
<p>本节教程需要一张图片作为背景图，从这里<a href="https://www.ioscreator.com/s/background.jpg" target="_blank" rel="external">下载</a>图片，添加到工程中，确保在添加时选择 “Copy items if needed” 选项。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587dff5d46c3c46130f0a478/1484652392518/?format=1500w" alt=""></p>
<p>在 Xcode 的 Game 模板中，已经做了很多初始化的工作。在 Sprite Kit 框架中，每个场景（scene）控制 App 的一屏（screen）。找到 <strong>GameViewController.swift</strong> 文件，在 GameViewController 类里，已经定义好了 <strong>viewDidLoad</strong> 方法，在这个方法里创建场景，呈现 GameScene 对象。将 viewDidLoad 方法代码更改成如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">    <span class="keyword">let</span> scene = <span class="type">GameScene</span>(size:<span class="type">CGSize</span>(width: <span class="number">1080</span>, height: <span class="number">1920</span>))</div><div class="line">        </div><div class="line">    <span class="keyword">let</span> skView = <span class="keyword">self</span>.view <span class="keyword">as</span>! <span class="type">SKView</span></div><div class="line">    scene.scaleMode = .aspectFill</div><div class="line">    skView.presentScene(scene)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>找到 <strong>GameScene.swift</strong> 方法，已经定义好了 GameScene 类，在 <strong>didMove</strong> 方法中，实现自定义的代码。删除 GameScene 类里面所有的代码，然后添加 didMove 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameScene</span>: <span class="title">SKScene</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didMove</span><span class="params">(to view: SKView)</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> background = <span class="type">SKSpriteNode</span>(imageNamed: <span class="string">"background.jpg"</span>)</div><div class="line">        background.position = <span class="type">CGPoint</span>(x: size.width/<span class="number">2</span>, y: size.height/<span class="number">2</span>)</div><div class="line">        addChild(background)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Sprite Kit 框架有个指定的类来创建控制 sprite（精灵）（译者注：sprite 是计算机图形学的专有名词，意为包含于场景中的二维图像或动画），就是 SKSpriteNode 类。在该节点（node）下，图片加载完成。接下来，将图片添加到场景中。最后，删除 GameScene.sks 和 Action.sks 文件，目前不需要这两个文件。</p>
<p><strong>运行</strong>工程。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587e00d546c3c46130f0ae45/1484652772003/?format=750w" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>SpriteKitBackgroundTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/display-background-with-spritekit-ios-tutorial-ios10&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017/01/17&lt;br&gt;译者：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Sprite Kit 是硬件加速的动画系统，为创建 2D 游戏进行了专门的优化。在本节教程中，将使用 Game 模板来添加一张背景图片。本节教程使用的是 Xcode 8.2.1 和 iOS 10.2。&lt;/p&gt;
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>改变状态栏的颜色</title>
    <link href="https://swift.gg/2017/05/18/change-color-status-bar-tutorial/"/>
    <id>https://swift.gg/2017/05/18/change-color-status-bar-tutorial/</id>
    <published>2017-05-17T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/change-color-status-bar-tutorial" target="_blank" rel="external">原文链接</a>，原文日期：2016/12/29<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>状态栏可以有两种外观：dark（黑色） 和 light（白色）。在本章教程中，将学习如何改变状态栏的外观。本节教程使用的是 Xcode 8.0 和 iOS 10。</p>
<a id="more"></a>
<p>打开 Xcode，创建一个 Single View Application。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58ff88928419c2b2a27d0754/1493141675229/single-view-xcode-template?format=1500w" alt=""></p>
<p>Product Name 使用 <strong>IOS10StatusBarColorTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57ea5a84e58c62718aa3048b/1474976400272/?format=1500w" alt=""></p>
<p>打开 Storyboard，选中 View，在 Attributes Inspetor 里将 Background Color 改成 Light Gray。运行工程，默认的状态栏颜色是黑色（dark）。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57ea5aa5e58c62718aa30530/1474976432868/?format=750w" alt=""></p>
<p>而我们想要实现的效果是白色的状态栏。打开 ViewController.swift 文件，添加下列代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="keyword">var</span> preferredStatusBarStyle: <span class="type">UIStatusBarStyle</span> &#123;</div><div class="line">    <span class="keyword">return</span> .lightContent</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码将 UIStatusBarStyle 枚举项设为 lightContent。运行工程，这时状态栏的颜色变成了白色（light）。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57ea5ad8e58c62718aa3063d/1474976482842/?format=750w" alt=""></p>
<p>接下来回到 Storyboard，选中 View Controller，在 Editor 菜单中选择 Embed in Navigation Controller。选中 Navigation Bar，在 Attribute Inspector 里将 Bar Tint color 设置为 red。storyboard 应该如下图所示。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57eaaf88893fc08c39f02235/1474998157337/?format=1500w" alt=""></p>
<p>运行工程，状态栏又变成了黑色，也就是默认状态。产生这个问题的原因是，iOS 请求的是 navigation controller 状态栏风格，不是 navigation controller 所包含的 controller 风格。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57eab046bebafbd7890070a9/1474998347300/?format=750w" alt=""></p>
<p>为了改变 Navigation controller 的风格（style），需要在 <strong>AppDelegate.swift</strong> 文件里如下修改代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="comment">// Override point for customization after application launch.</span></div><div class="line">        </div><div class="line">    <span class="type">UINavigationBar</span>.appearance().barStyle = .blackOpaque</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行工程，这时状态栏的颜色变成了白色。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57eab0ce37c581c584f0a3a9/1474998487766/?format=750w" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>IOS10StatusBarColorTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      iOS 开发中如何改变状态栏的颜色
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 入门" scheme="https://swift.gg/tags/iOS-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unowned 还是 Weak？生命周期和性能对比</title>
    <link href="https://swift.gg/2017/05/16/unowned-or-weak-lifetime-and-performance/"/>
    <id>https://swift.gg/2017/05/16/unowned-or-weak-lifetime-and-performance/</id>
    <published>2017-05-15T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Umberto Raimondi，<a href="https://www.uraimo.com/2016/10/27/unowned-or-weak-lifetime-and-performance/" target="_blank" rel="external">原文链接</a>，原文日期：2016-10-27<br>译者：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>每当处理循环引用（retain cycles）时，需要考量对象生命周期来选择<code>unowned</code>或者<code>weak</code>标识符，这已经成为了一个共识。但是有时仍然会心存疑问，在具体的使用中应该选择哪一个，或者退一步讲，保守的只使用 weak 是不是一个好的选择呢？</p>
<p>本文首先对循环引用的基础知识做一个简要介绍，然后会分析 Swift 源代码的一些片段，讲解 <code>unowned</code> 和 <code>weak</code>  在生命周期和性能上的差异点，希望看完本文以后，在的使用场景中，能使用正确的弱引用类型。</p>
<a id="more"></a>
<p><strong>目录:</strong></p>
<ul>
<li><a href="#the_basic">基础知识</a></li>
<li><a href="#the_question_unowned_or_weak">问题来了: unowened 还是 weak?</a></li>
<li><a href="#performance_a_look_under_the_hood">性能：深度探索</a></li>
<li><a href="#deconstructing_capture_lists_handling">捕获列表处理解析</a></li>
<li><a href="#conclusion">结论</a></li>
<li><a href="#footnotes">脚注</a></li>
</ul>
<blockquote>
<p>从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="external">GitHub</a> 或者 <a href="https://www.uraimo.com/archives/2016-10-27-UnownedWeakPlayground.playground.zip" target="_blank" rel="external">zipped</a> 获取本文相关的 Playground 代码。然后从<a href="https://www.uraimo.com/archives/closure.zip" target="_blank" rel="external">这里</a>获取闭包案例和 SIL，SILGen 以及 LLVM IR 的输出。</p>
</blockquote>
<p><a name="the_basic"></a></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>众所周知，<code>Swift</code> 利用古老并且有效的自动引用计数（ARC, Automatic Reference Counting）来管理内存，带来的后果和在 Objective-C 中使用的情况类似，需要手动使用弱引用来解决循环引用问题。</p>
<p>如果对 <code>ARC</code> 不了解，只需要知道的是，每一个<em>引用类型</em>实例都有一个引用计数与之关联，这个引用计数用来记录这个对象实例正在被变量或常量引用的总次数。当引用计数变为 <code>0</code> 时，实例将会被析构，实例占有的内存和资源都将变得重新可用。</p>
<p>当有两个实例通过某种形式互相引用时，就会形成循环引用（比如：两个类实例都有一个属性指向对方的类实例；双向链表中两个相邻的节点实例等…）, 由于两个实例的引用计数都一直大于 <code>0</code>， 循环引用将会阻止这些实例的析构。</p>
<p>为了解决这个问题，和其他一些有类似问题的语言一样， 在 <code>Swift</code> 中，<em>弱引用</em> 的概念被提了出来，弱引用不会被 <code>ARC</code> 计算，也就是说，当一个弱引用指向一个引用类型实例时，引用计数不会增加。</p>
<p>弱引用不会阻止实例的析构, 只需要记住的是，在任何情况下，弱引用都不会拥有它指向的对象。在正式的场景中不是什么大问题，但是在我们处理这类引用的时候，需要意识到这一点。</p>
<p>在 Swift 中有 2 种 <em>弱</em> 引用形式，<code>unowned</code> 和 <code>weak</code>。</p>
<p>虽然它们的作用类似，但与它们相关实例生命周期的假设会略有不同，并且具有不同的性能特征。</p>
<p>为了举例说明循环引用，这里不使用大家期望看到的类之间的循环引用，而使用闭包的上下文案例，这在 <code>Objective-C</code> 日常开发中处理循环引用时经常会遇到的情况。和类的循环引用类似，通过创建一个强引用指向外部实例，或捕获它，阻止它析构。</p>
<p>在 <code>Objective-C</code> ，按照标准的做法，定义一个弱引用指向闭包外部的实例，然后在闭包内部定义强引用指向这个实例，在闭包执行期间使用它。当然，有必要在使用前检查引用的有效性。</p>
<p>为了更方便的处理循环引用，<code>Swift</code> 引入了一个新的概念，用于简化和更加明显地表达在闭包内部外部变量的捕获：<em>捕获列表（capture list）</em>。使用捕获列表，可以在函数的头部定义和指定那些需要用在内部的外部变量，并且指定引用类型(译者注：这里是指 <code>unowned</code> 和 <code>weak</code>）。</p>
<p>接下来举一些例子，在各种情况下捕获变量的表现。</p>
<p>当不使用捕获列表时，闭包将会创建一个外部变量的强引用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 = <span class="number">1</span>, i2 = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> fStrong = &#123;</div><div class="line">    i1 += <span class="number">1</span></div><div class="line">    i2 += <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">fStrong()</div><div class="line"><span class="built_in">print</span>(i1,i2) <span class="comment">//Prints 2 and 3</span></div></pre></td></tr></table></figure>
<p>闭包内部对变量的修改将会改变外部原始变量的值，这与预期是一致的。</p>
<p>使用捕获列表，闭包内部会创建一个新的可用常量。如果没有指定常量修饰符，闭包将会简单地拷贝原始值到新的变量中，对于值类型和引用类型都是一样的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fCopy = &#123; [i1] <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(i1,i2)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fStrong()</div><div class="line"><span class="built_in">print</span>(i1,i2) <span class="comment">//打印结果是 2 和 3  </span></div><div class="line"></div><div class="line">fCopy()  <span class="comment">//打印结果是 1 和 3</span></div></pre></td></tr></table></figure>
<p>在上面的例子中，在调用 <code>fStrong</code> 之前定义函数 <code>fCopy</code> ,在该函数定义的时候，私有常量已经被创建了。正如你所看到的，当调用第二个函数时候，仍然打印 <code>i1</code> 的原始值。</p>
<p>对于外部引用类型的变量，在捕获列表中指定 <code>weak</code> 或 <code>unowned</code>，这个常量将会被初始化为一个弱引用，指向原始值，这种指定的捕获方式就是用来处理循环引用的方式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">aClass</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c1 = aClass()</div><div class="line"><span class="keyword">var</span> c2 = aClass()</div><div class="line"></div><div class="line"><span class="keyword">var</span> fSpec = &#123; [<span class="keyword">unowned</span> c1, <span class="keyword">weak</span> c2] <span class="keyword">in</span></div><div class="line">    c1.value += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> c2 = c2 &#123;</div><div class="line">        c2.value += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fSpec()</div><div class="line"><span class="built_in">print</span>(c1.value,c2.value) <span class="comment">//Prints 2 and 2</span></div></pre></td></tr></table></figure>
<p>两个 <code>aClass</code> 捕获实例的不同的定义方式，决定了它们在闭包中不同的使用方式。</p>
<p>unowned 引用使用的场景是，原始实例永远不会为 <em>nil</em>，闭包可以直接使用它，并且直接定义为显式解包可选值。当原始实例被析构后，在闭包中使用这个捕获值将导致崩溃。</p>
<p>如果捕获原始实例在使用过程中可能为 <em>nil</em> ，必须将引用声明为 <code>weak</code>， 并且在使用之前验证这个引用的有效性。</p>
<p><a name="the_question_unowned_or_weak"></a></p>
<h3 id="问题来了-unowened-还是-weak"><a href="#问题来了-unowened-还是-weak" class="headerlink" title="问题来了: unowened 还是 weak?"></a>问题来了: unowened 还是 weak?</h3><p>在实际使用中如何选择这两种弱引用类型呢？</p>
<p>这个问题的答案可以简单由原始对象和引用它的闭包的<strong>生命周期来解释</strong>。</p>
<p><img src="https://www.uraimo.com/imgs/unownedbig.png" alt=""></p>
<p>有两个可能出现的场景：</p>
<ul>
<li><p>闭包和捕获对象的生命周期相同，所以对象可以被访问，也就意味着闭包也可以被访问。外部对象和闭包有相同的生命周期(比如：对象和它的父对象的简单返回引用）。在这种情况下，你应该把引用定义为 <strong>unowned</strong>。</p>
<p>一个经典的案例是: <code>[unowned self]</code>, 主要用在闭包中，这种闭包主要在他们的父节点上下文中做一些事情，没有在其他地方被引用或传递，不能作用在父节点之外。</p>
</li>
</ul>
<ul>
<li><p>闭包的生命周期和捕获对象的生命周期相互独立，当对象不能再使用时，闭包依然能够被引用。这种情况下，你应该把引用定义为 <code>weak</code>，并且在使用它之前验证一下它是否为 <code>nil</code>（请不要对它进行强制解包).</p>
<p>一个经典的案例是: <code>[weak delegate = self.delegate!]</code>，可以在某些使用闭包的场景中看到，闭包使用的是完全无关（生命周期独立）的代理对象。</p>
</li>
</ul>
<p>当无法确认两个对象之间生命周期的关系时，是否不应该去冒险选择一个无效 <code>unowned</code> 引用？而是保守选择 <code>weak</code> 引用是一个更好的选择？</p>
<p>答案是否定的，不仅仅是因为对象生命周期了解是一件必要的事情，而且这两个修饰符在性能特性上也有很大的不同。</p>
<p>弱引用最常见的实现是，每次一个新的引用生成时，都会把每个弱引用和它指向的对象信息存储到一个附加表中。</p>
<p>当没有任何强引用指向一个对象时，<code>Swift</code> 运行时会启动析构过程，但是在这之前，运行时会把所有相关的弱引用置为 <em>nil</em> 。弱引用的这种实现方式我们称之为”零和弱引用”。</p>
<p>这种实现有实际的开销，考虑到需要额外实现的数据结构，需要确保在并发访问情况下，对这个全局引用结构所有操作的正确性。一旦析构过程开始了，在任何环境中，都不允许访问弱引用所指向的对象了。</p>
<p>弱引用（包括 <code>unowned</code> 和一些变体的 <code>weak</code>)在 Swift 使用了更简单和快速的实现机制。</p>
<p><code>Swift</code> 中的每个对象保持了两个引用计数器，一个是强引用计数器，用来决定 <code>ARC</code> 什么时候可以安全地析构这个对象，另外一个附加的弱引用计数器，用来计算创建了多少个指向这个对象的 <code>unowned</code> 或者 <code>weak</code> 引用，当这个计数器为零时，这个对象将被 <em>析构</em> 。</p>
<p>需要重点理解的是，只有等到所有 <code>unowned</code> 引用被释放后，这个对象才会被真正地析构，然后对象将会保持未解析可访问状态，当析构发生后，对象的内容才会被回收。</p>
<p>每当 <code>unowned</code> 引用被定义时，对应的 <code>unowned</code> 引用计数会进行原子级别地增加(使用<a href="http://llvm.org/docs/Atomics.html#libcalls-atomic" target="_blank" rel="external">原子gcc/llvm操作</a>，进行一系列快速且线程安全的基本操作，例如：增加，减少，比较，交换等)，以保证线程安全。在增加计数之前，会检查强引用计数以确保对象是有效的。</p>
<p>试图访问一个无效的对象，将会导致错误的断言，你的应用在运行时中会报错(这就是为什么这里的 <code>unownd</code> 实现方式叫做 <code>unowned(safe)</code> 实现)</p>
<p>为了更好的优化，应用编译时带有 <code>-OFast</code>，<code>unowned</code> 引用不会去验证引用对象的有效性，<code>unowned</code> 引用的行为就会像 <code>Objective-C</code> 中的 <code>__unsafe_unretained</code> 一样。如果引用对象无效，<code>unowned</code> 引用将会指向已经释放垃圾内存（这种实现称之 <code>unowned(unsafe)</code>）。</p>
<p>当一个 <code>unowned</code> 引用被释放后，如果这时没有其他强引用或 <code>unowned</code> 引用指向这个对象，那么最终这个对象将被析构。这就是为什么一个引用对象不能在强引用计数器等于零的情况下，被析构的原因，所有的引用计数器必须能够被访问用来验证 <code>unowned</code> 引用和强引用数量。</p>
<p>Swift 的 <code>weak</code> 引用添加了附加层，间接地把 <code>unowned</code> 引用包裹到了一个可选容器里面，在指向的对象析构之后变成空的情况下，这样处理会更加的清晰。但是需要付出的代价是，附加的机制需要正确地处理可选值。</p>
<p>考虑到以上因素，在对象关系生命周期允许的情况下，<strong>优先选择</strong>使用 <code>unowned</code> 引用。但是这不是此故事的结局，接下来比较一下两者性能<sup><a href="#1">1</a></sup>上的差别。</p>
<p><a name="performance_a_look_under_the_hood"></a></p>
<h3 id="性能：深度探索"><a href="#性能：深度探索" class="headerlink" title="性能：深度探索"></a>性能：深度探索</h3><p>在查看 <code>Swift</code> 项目源码验证之前，需要理解 <code>ARC</code> 如何管理这两种引用类型，并且还需要解释 <code>swiftc</code>，<code>LLVM</code> 和 <code>SIL</code> 的相关知识。</p>
<p>接下来试着简要介绍本文所需要的必备知识点，如果想了解更多，将在最后的脚注中找到一些有用的链接。</p>
<p>使用一个图来解释 <em>swiftc</em> 整个编译过程的包含的模块：</p>
<p><img src="https://www.uraimo.com/imgs/swiftc.png" alt=""></p>
<p><code>Swiftc</code> 和 <em>clang</em> 一样构建在 LLVM 上，遵循 <em>clang</em> 编译器相似的编译流程。</p>
<p>在编译过程的第一部分，使用一个特定语言前端进行管理，<code>swift</code> 源代码被解释生成一个抽象语法树(AST)表达<sup><a href="#2">2</a></sup>，然后抽象语法树的结果从语义角度进行分析，找出语义错误。</p>
<p>在这个点上，对于其他的基于 LLVM 的编译器来讲，在通过一个附加步骤对源代码进行静态分析后（必要时可以显示错误和警告），接着 <em>IRGen</em> 模块 会把 <code>AST</code> 的内容会转换成一个轻量的和底层的机器无关的表示，我们称之为 <a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="external">LLVM IR</a>(<code>LLVM</code> 中间表示)。</p>
<p>尽管两个模块都需要做一些相同检查，但是这两个模块是区分开的，在两个模块之间也存在许多重复的代码。</p>
<p><code>IR</code> 是一种<a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="external">静态单赋值形式</a>（<code>SSA-form</code>）一致语言，可以看做注入了 <code>LLVM</code> 的虚拟机下的 <code>RISC</code> 类型<a href="https://idea.popcount.org/2013-07-24-ir-is-better-than-assembly/" target="_blank" rel="external">汇编语言</a>。基于 <code>SSA</code> 将简化接下来的编译过程，从语言前端提供的中间表达会在 <code>IR</code> 进行多重优化。</p>
<p>需要重点注意的是，<code>IR</code> 其中一个特点是，它具有三种不同的形式：内存表达（内部使用），序列化位代码形式（你已经知道的<a href="https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html" target="_blank" rel="external">位代码形式</a>）和可读形式。</p>
<p>最后一种形式非常有用，用来验证 <code>IR</code> 代码的最终结构，这个结构将会传入到整个过程中的最后一步，将会从机器独立的 <code>IR</code> 代码转换成平台相关的表达(比如：x86，ARM 等等)。最后一步将被 <code>LLVM</code> 平台后端执行。</p>
<p>那么 <code>swiftc</code> 和其他基于 <code>LLVM</code> 的编译器有什么不同呢？</p>
<p><code>swiftc</code> 和其他编译器从结构形式上的差别主要体现在一个附加组件，这个附加组件是 <em>SILGen</em> ，在 <em>IRGen</em> 之前，执行代码的监测和优化，生成一个高级的中间表达，我们称之为 <em>SIL</em> （Swift Intermediate Language，Swift 中间语言），最后 SIL 将会转换成 LLVM IR。这一步加强了在单个软件模块上所有具体语言的检查，并且简化了 <em>IRGen</em>。</p>
<p>从 <code>AST</code> 到 <code>IR</code> 的转换分为两个步骤。<em>SILGen</em> 把 <code>AST</code> 源代码转换为原始 <code>SIL</code> ，然后编译器进行 <code>Swift</code> 语法检查（需要时打印错误或者警告信息），优化有效的原始 <code>SIL</code> ，通过一些步骤最后生成标准化 <code>SIL</code> 。如上面的示意图显示那样，标准化 <code>SIL</code> 的最后转化为 <code>LLVM IR</code>。</p>
<p>再次强调，<code>SIL</code> 是一个 <code>SSA</code> 类型语言，使用附加的结构扩展了 <code>Swift</code> 的语法。它依赖 <code>Swift</code> 的类型系统，并且能理解 <code>Swift</code> 的定义，但是需要重点记住的是，当编译一个手写的 <code>SIL</code> 源码（是的，可以手动写 <code>SIL</code> 然后编译它）时，高阶的 <code>Swift</code> 代码或者函数内容将被编译器忽略。</p>
<p>在接下来的章节，我们将分析一个标准化 <code>SIL</code> 的案例，来理解 <code>unowned</code> 和 <code>weak</code> 引用如何被编译器处理。一个包含捕获列表的基本闭包的例子，查看这个例子生成的 <code>SIL</code> 代码，可以看到被编译器添加的所有 <code>ARC</code> 相关的函数调用。</p>
<blockquote>
<p>从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="external">GitHub</a> 或者 <a href="https://www.uraimo.com/archives/2016-10-27-UnownedWeakPlayground.playground.zip" target="_blank" rel="external">zipped</a> 获取本文相关的 Playground 代码。然后从<a href="https://www.uraimo.com/archives/closure.zip" target="_blank" rel="external">这里</a>获取闭包案例和 <code>SIL</code> ，<code>SILGen</code> 以及 <code>LLVM IR</code> 的输出。</p>
</blockquote>
<p><a name="deconstructing_capture_lists_handling"></a></p>
<h4 id="捕获列表处理解析"><a href="#捕获列表处理解析" class="headerlink" title="捕获列表处理解析"></a>捕获列表处理解析</h4><p>接下来看看一个简单的 <code>Swift</code> 的例子，定义两个类变量，然后在一个闭包中对他们进行弱引用的捕获：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">aClass</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c1 = aClass()</div><div class="line"><span class="keyword">var</span> c2 = aClass()</div><div class="line"></div><div class="line"><span class="keyword">var</span> fSpec = &#123; </div><div class="line">    [<span class="keyword">unowned</span> c1, <span class="keyword">weak</span> c2] <span class="keyword">in</span></div><div class="line">    c1.value = <span class="number">42</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> c2o = c2 &#123;</div><div class="line">        c2o.value = <span class="number">42</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fSpec()</div></pre></td></tr></table></figure>
<p>通过 <code>xcrun swiftc -emit-sil sample.swift</code> 编译 swift 源代码，生成标准化 SIL 代码。原始SIL 可以使用 <code>-emit-silgen</code> 选项来生成。</p>
<p>运行以上命令以后，会发现 swiftc 产生了许多代码。通过查看 swiftc 输出代码的片段，学习一下基本的 SIL 指令，理解整个结构。</p>
<p>在下面代码中需要的地方添加了一些多行注释（编译器也生成了一些单行注释），希望这些注释已经足够说清楚发生了什么：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  此文件包含典型 SIL 代码</div><div class="line">*/</div><div class="line">sil_stage canonical             </div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">  只有在 SIL 内部使用的特殊的导入</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> Builtin                  </div><div class="line"><span class="keyword">import</span> Swift</div><div class="line"><span class="keyword">import</span> SwiftShims</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">	三个全局变量的定义，包括 c1，c2 和 闭包 fSpec。</div><div class="line">  	@_Tv4clos2c1CS_6aClass是变量的符号，$aClass 是它的类型（类型前缀为$)。</div><div class="line">  	变量名在这里看起来很乱，但是在后面的代码中将变得更加可读。</div><div class="line">*/</div><div class="line"><span class="comment">// c1</span></div><div class="line">sil_global hidden @_Tv4sample2c1CS_6aClass : $aClass</div><div class="line"></div><div class="line"><span class="comment">// c2</span></div><div class="line">sil_global hidden @_Tv4sample2c2CS_6aClass : $aClass</div><div class="line"></div><div class="line"><span class="comment">// fSpec</span></div><div class="line">sil_global hidden @_Tv4sample5fSpecFT_T_ : $@callee_owned () -&gt; ()</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  层次作用域定义表示原始代码的位置。</div><div class="line">  每个 SIL 指示将会指向它生成的 `sil_scope`。</div><div class="line">*/</div><div class="line">sil_scope <span class="number">1</span> &#123;  parent @main : $<span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Int32</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="type">Int32</span> &#125;</div><div class="line">sil_scope <span class="number">2</span> &#123; loc <span class="string">"sample.swift"</span>:<span class="number">14</span>:<span class="number">1</span> parent <span class="number">1</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">	自动生成的 @main 函数包含了我们原始全部作用域的代码。</div><div class="line"> 	这里沿用了熟悉的 c main() 函数结构，接收参数个数和参数数组两个输入，这个函数遵循 c 调用约定。</div><div class="line">  	这个函数包含了需要调用闭包的指令。</div><div class="line">*/</div><div class="line"><span class="comment">// main</span></div><div class="line">sil @main : $<span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Int32</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="type">Int32</span> &#123;</div><div class="line"><span class="comment">/*</span></div><div class="line">  入口定义头部为 % 符号，后面跟随一个数字 id。</div><div class="line">  每当一个新的入口定义时（或者函数开头定义函数参数），编译器在入口行尾根据它的值（叫做 users）添加一个注释。</div><div class="line">  对于其他指令，需要提供 id 号。</div><div class="line">  在这里，入口 0 将被用来计算入口 4 的内容，入口 1 将被用来创建入口 10 的值。</div><div class="line">*/</div><div class="line"><span class="comment">// %0                                             // user: %4</span></div><div class="line"><span class="comment">// %1                                             // user: %10</span></div><div class="line"><span class="comment">/*</span></div><div class="line">  每一个函数被分解成一系列的基本指令块，每一个指令块结束于一个终止指令（一个分支或者一个返回）。</div><div class="line">  这一系列的指令块表示函数所有可能的执行路径。</div><div class="line">*/</div><div class="line">bb0(%<span class="number">0</span> : $<span class="type">Int32</span>, %<span class="number">1</span> : $<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;):</div><div class="line">...</div><div class="line">  <span class="comment">/*</span></div><div class="line">    每一个 SIL 指令都包含一个引用，指向源代码的位置，包括指令具体从源代码中哪个地方来，属于哪一个作用域。</div><div class="line">    在后面分析具体的方法会看到这些内容。</div><div class="line">  */</div><div class="line">  unowned_retain %<span class="number">27</span> : $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %28</span></div><div class="line">  store %<span class="number">27</span> to %<span class="number">2</span> : $*@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %29</span></div><div class="line">  %<span class="number">30</span> = alloc_box $@sil_weak <span class="type">Optional</span>&lt;aClass&gt;, <span class="keyword">var</span>, name <span class="string">"c2"</span>, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %46, %44, %43, %31</span></div><div class="line">  %<span class="number">31</span> = project_box %<span class="number">30</span> : $@box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// user: %35</span></div><div class="line">  %<span class="number">32</span> = load %<span class="number">19</span> : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %34, %33</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">  下面是一系列自动生成的`aClass`的方法，包括： init/deinit, setter/getter 和其他一些工具方法。</div><div class="line">  每个方法前的注释是编译器添加的，用来说明代码的具体作用。</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  隐藏方法只在它们模块中可见。</div><div class="line">  @convention(方法名)是 Swift 中方法调用默认的约定，在尾部有一个附加的参数指向它自己。</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.__deallocating_deinit</span></div><div class="line">sil hidden @_TFC4clos6aClassD : $<span class="meta">@convention</span>(method) (@owned aClass) -&gt; () &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  @guaranteed 参数表示保证在整个周期内调用此方法都有效。</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.deinit</span></div><div class="line">sil hidden @_TFC4clos6aClassd : $<span class="meta">@convention</span>(method) (@guaranteed aClass) -&gt; @owned <span class="type">Builtin</span>.<span class="type">NativeObject</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  [transparent] 修饰的方法是内联的小方法</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.value.getter</span></div><div class="line">sil hidden [transparent] @_TFC4clos6aClassg5valueSi : $<span class="meta">@convention</span>(method) (@guaranteed aClass) -&gt; <span class="type">Int</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// aClass.value.setter</span></div><div class="line">sil hidden [transparent] @_TFC4clos6aClasss5valueSi : $<span class="meta">@convention</span>(method) (<span class="type">Int</span>, @guaranteed aClass) -&gt; () &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">// aClass.value.materializeForSet</span></div><div class="line">sil hidden [transparent] @_TFC4clos6aClassm5valueSi : $<span class="meta">@convention</span>(method) (<span class="type">Builtin</span>.<span class="type">RawPointer</span>, @<span class="keyword">inout</span> <span class="type">Builtin</span>.<span class="type">UnsafeValueBuffer</span>, @guaranteed aClass) -&gt; (<span class="type">Builtin</span>.<span class="type">RawPointer</span>, <span class="type">Optional</span>&lt;<span class="type">Builtin</span>.<span class="type">RawPointer</span>&gt;) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  @owned 修饰符表示这个对象将被调用者拥有。</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.init() -&gt; aClass</span></div><div class="line">sil hidden @_TFC4clos6aClasscfT_S0_ : $<span class="meta">@convention</span>(method) (@owned aClass) -&gt; @owned aClass &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// aClass.__allocating_init() -&gt; aClass</span></div><div class="line">sil hidden @_TFC4clos6aClassCfT_S0_ : $<span class="meta">@convention</span>(method) (@thick aClass.<span class="type">Type</span>) -&gt; @owned aClass &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">  接下面是闭包代码段</div><div class="line">*/</div><div class="line"><span class="comment">// (closure #1)</span></div><div class="line">sil shared @_TF4closU_FT_T_ : $<span class="meta">@convention</span>(thin) (@owned @sil_unowned aClass, @owned @box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;) -&gt; () &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">/* 关于闭包的 SIL 代码， 见下文 */</span></div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"><span class="comment">/* </span></div><div class="line">  sil_vtable 定义所有关于 aClass 类的虚函数表。</div><div class="line">  sil_vtable 包含了期望的所有自动生成的方法。</div><div class="line">*/</div><div class="line">sil_vtable aClass &#123;</div><div class="line">  #aClass.<span class="keyword">deinit</span>!deallocator: _TFC4clos6aClassD	<span class="comment">// aClass.__deallocating_deinit</span></div><div class="line">  #aClass.value!getter.<span class="number">1</span>: _TFC4clos6aClassg5valueSi	<span class="comment">// aClass.value.getter</span></div><div class="line">  #aClass.value!setter.<span class="number">1</span>: _TFC4clos6aClasss5valueSi	<span class="comment">// aClass.value.setter</span></div><div class="line">  #aClass.value!materializeForSet.<span class="number">1</span>: _TFC4clos6aClassm5valueSi	<span class="comment">// aClass.value.materializeForSet</span></div><div class="line">  #aClass.<span class="keyword">init</span>!initializer.<span class="number">1</span>: _TFC4clos6aClasscfT_S0_	<span class="comment">// aClass.init() -&gt; aClass</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在回到主函数，看看两个类实例如何被获取到，并如何传递给调用他们的闭包。</p>
<p>在这里，所有标识都被重新整理，使得代码片段更加可读。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="comment">// main</span></div><div class="line">sil @main : $<span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Int32</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="type">Int32</span> &#123;</div><div class="line"><span class="comment">// %0                                             // user: %4</span></div><div class="line"><span class="comment">// %1                                             // user: %10</span></div><div class="line">bb0(%<span class="number">0</span> : $<span class="type">Int32</span>, %<span class="number">1</span> : $<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;):</div><div class="line">  ...</div><div class="line">  <span class="comment">/*</span></div><div class="line">    全局变量的引用使用三个入口来放置。</div><div class="line">  */</div><div class="line">  %<span class="number">13</span> = global_addr @clos.c1 : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">5</span>:<span class="number">5</span>, scope <span class="number">1</span> <span class="comment">// users: %26, %17</span></div><div class="line">  ...</div><div class="line">  %<span class="number">19</span> = global_addr @clos.c2 : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">6</span>:<span class="number">5</span>, scope <span class="number">1</span> <span class="comment">// users: %32, %23</span></div><div class="line">  ...</div><div class="line">  %<span class="number">25</span> = global_addr @clos.fSpec : $*@callee_owned () -&gt; (), loc <span class="string">"sample.swift"</span>:<span class="number">8</span>:<span class="number">5</span>, scope <span class="number">1</span> <span class="comment">// users: %48, %45</span></div><div class="line">  <span class="comment">/*</span></div><div class="line">    c1 是 unowned_retained 的。</div><div class="line">    下面的指令增加变量的 unowned 引用计数。</div><div class="line">  */</div><div class="line">  %<span class="number">26</span> = load %<span class="number">13</span> : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// user: %27</span></div><div class="line">  %<span class="number">27</span> = ref_to_unowned %<span class="number">26</span> : $aClass to $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// users: %47, %38, %39, %29, %28</span></div><div class="line">  unowned_retain %<span class="number">27</span> : $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %28</span></div><div class="line">  store %<span class="number">27</span> to %<span class="number">2</span> : $*@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %29</span></div><div class="line">  <span class="comment">/*</span></div><div class="line">    对 c2 的处理会更加复杂一些。</div><div class="line">	alloc_box 创建了一个这个变量的引用数容器，变量将会存在这个容器的堆中。</div><div class="line">    容器创建以后，将会创建一个可选变量，指向 c2，并且可选变量会存储在容器里。容器会增加所包含值的技术，正如下面看到的一样，一旦容器被迁移，可选值就会被释放。</div><div class="line">    在这里，c2 的值将被存储在这个可选值中，对象将暂时strong_retained 然后释放。</div><div class="line">  */</div><div class="line">  %<span class="number">30</span> = alloc_box $@sil_weak <span class="type">Optional</span>&lt;aClass&gt;, <span class="keyword">var</span>, name <span class="string">"c2"</span>, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %46, %44, %43, %31</span></div><div class="line">  %<span class="number">31</span> = project_box %<span class="number">30</span> : $@box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// user: %35</span></div><div class="line">  %<span class="number">32</span> = load %<span class="number">19</span> : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %34, %33</span></div><div class="line">  strong_retain %<span class="number">32</span> : $aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// id: %33</span></div><div class="line">  %<span class="number">34</span> = <span class="class"><span class="keyword">enum</span> <span class="title">$Optional</span>&lt;<span class="title">aClass</span>&gt;, #<span class="title">Optional</span>.<span class="title">some</span>!<span class="title">enumelt</span>.1, %32 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:23, <span class="title">scope</span> 2 // <span class="title">users</span>: %36, %35</span></div><div class="line">  <span class="title">store_weak</span> %34 <span class="title">to</span> [<span class="title">initialization</span>] %31 : <span class="title">$</span>*@<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:23, <span class="title">scope</span> 2 // <span class="title">id</span>: %35</div><div class="line">  <span class="title">release_value</span> %34 : <span class="title">$Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:23, <span class="title">scope</span> 2 // <span class="title">id</span>: %36</div><div class="line">  /*</div><div class="line">    获取到闭包的引用。</div><div class="line">  */</div><div class="line">  // <span class="title">function_ref</span> (<span class="title">closure</span> #1)</div><div class="line">  %37 = <span class="title">function_ref</span> @<span class="title">sample</span>.(<span class="title">closure</span> #1) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">thin</span>) (@<span class="title">owned</span> @<span class="title">sil_unowned</span> <span class="title">aClass</span>, @<span class="title">owned</span> @<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">user</span>: %44</div><div class="line">  /*</div><div class="line">    <span class="title">c1</span> 将被标记为 <span class="title">tagged</span>，并且变量变为 <span class="title">unowned_retained</span>。</div><div class="line">  */</div><div class="line">  <span class="title">strong_retain_unowned</span> %27 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %38</div><div class="line">  %39 = <span class="title">unowned_to_ref</span> %27 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span> <span class="title">to</span> <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">users</span>: %42, %40</div><div class="line">  %40 = <span class="title">ref_to_unowned</span> %39 : <span class="title">$aClass</span> <span class="title">to</span> <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">users</span>: %44, %41</div><div class="line">  <span class="title">unowned_retain</span> %40 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %41</div><div class="line">  <span class="title">strong_release</span> %39 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %42</div><div class="line">  /*</div><div class="line">    包含 <span class="title">c2</span> 的可选值容器是 <span class="title">strong_retained</span> 的。</div><div class="line">  */</div><div class="line">  <span class="title">strong_retain</span> %30 : <span class="title">$</span>@<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %43</div><div class="line">  /*</div><div class="line">    创建一个闭包对象，绑定方法到参数中。</div><div class="line">  */</div><div class="line">  %44 = <span class="title">partial_apply</span> %37(%40, %30) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">thin</span>) (@<span class="title">owned</span> @<span class="title">sil_unowned</span> <span class="title">aClass</span>, @<span class="title">owned</span> @<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">user</span>: %45</div><div class="line">  <span class="title">store</span> %44 <span class="title">to</span> %25 : <span class="title">$</span>*@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %45</div><div class="line">  /*</div><div class="line">    </div><div class="line">    对 <span class="title">c1</span> 和 <span class="title">c2</span> 的容器变量进行释放（使用 对应匹配的 *<span class="title">_release</span> 方法）。</div><div class="line">  */</div><div class="line">  <span class="title">strong_release</span> %30 : <span class="title">$</span>@<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 2 // <span class="title">id</span>: %46</div><div class="line">  <span class="title">unowned_release</span> %27 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:14, <span class="title">scope</span> 2 // <span class="title">id</span>: %47</div><div class="line">  /*</div><div class="line">     加载原先存储的闭包对象，增加强引用然后调用它。</div><div class="line">  */</div><div class="line">   %48 = <span class="title">load</span> %25 : <span class="title">$</span>*@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":17:1, <span class="title">scope</span> 2 // <span class="title">users</span>: %50, %49</div><div class="line">  <span class="title">strong_retain</span> %48 : <span class="title">$</span>@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":17:1, <span class="title">scope</span> 2 // <span class="title">id</span>: %49</div><div class="line">  %50 = <span class="title">apply</span> %48() : <span class="title">$</span>@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":17:7, <span class="title">scope</span> 2</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>闭包有一个更加复杂的结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  闭包参数被标记为 @sil, 指定参数如何被计数，有一个 unowned 的 aClass 类变量 c2, 和另外一个包含 c2 的可选值容器。</div><div class="line">*/</div><div class="line"><span class="comment">// (closure #1)</span></div><div class="line">sil shared @clos.fSpec: $<span class="meta">@convention</span>(thin) (@owned @sil_unowned aClass, @owned @box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;) -&gt; () &#123;</div><div class="line"><span class="comment">// %0                                             // users: %24, %6, %5, %2</span></div><div class="line"><span class="comment">// %1                                             // users: %23, %3</span></div><div class="line"><span class="comment">/*</span></div><div class="line">  下面的函数包含三块，后面两块的执行依赖可选值 c2 具体的值。</div><div class="line">*/</div><div class="line">bb0(%<span class="number">0</span> : $@sil_unowned aClass, %<span class="number">1</span> : $@box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;):</div><div class="line">...</div><div class="line">  <span class="comment">/*</span></div><div class="line">    c1 被强计数。</div><div class="line">  */</div><div class="line">  strong_retain_unowned %<span class="number">0</span> : $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">10</span>:<span class="number">5</span>, scope <span class="number">17</span> <span class="comment">// id: %5</span></div><div class="line">  %<span class="number">6</span> = unowned_to_ref %<span class="number">0</span> : $@sil_unowned aClass to $aClass, loc <span class="string">"sample.swift"</span>:<span class="number">10</span>:<span class="number">5</span>, scope <span class="number">17</span> <span class="comment">// users: %11, %10, %9</span></div><div class="line">  <span class="comment">/*</span></div><div class="line">    使用内部自带包，传入一个整型字面量到整型结构中，初始化了一个值为 42 的整型值。</div><div class="line">    这个值将被设置为 c1 的新值，完成以后这个变量将会被释放。</div><div class="line">    在这里，我们第一次看到 class_method 指令，用于获取 vtable 中的函数引用。</div><div class="line">  */</div><div class="line">  %<span class="number">7</span> = integer_literal $<span class="type">Builtin</span>.<span class="type">Int64</span>, <span class="number">42</span>, loc <span class="string">"sample.swift"</span>:<span class="number">10</span>:<span class="number">16</span>, scope <span class="number">17</span> <span class="comment">// user: %8</span></div><div class="line">  %<span class="number">8</span> = <span class="class"><span class="keyword">struct</span> <span class="title">$Int</span> (%7 : <span class="title">$Builtin</span>.<span class="title">Int64</span>), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:16, <span class="title">scope</span> 17 // <span class="title">user</span>: %10</span></div><div class="line">  %9 = <span class="title">class_method</span> %6 : <span class="title">$aClass</span>, #<span class="title">aClass</span>.<span class="title">value</span>!<span class="title">setter</span>.1 : (<span class="title">aClass</span>) -&gt; (<span class="title">Int</span>) -&gt; () , <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:14, <span class="title">scope</span> 17 // <span class="title">user</span>: %10</div><div class="line">  %10 = <span class="title">apply</span> %9(%8, %6) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:14, <span class="title">scope</span> 17</div><div class="line">  <span class="title">strong_release</span> %6 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:16, <span class="title">scope</span> 17 // <span class="title">id</span>: %11</div><div class="line">  /*</div><div class="line">    接下来讨论 <span class="title">c2</span>。</div><div class="line">    获取可选值，然后根据它的内容执行接下来的分支语句。</div><div class="line"></div><div class="line">    <span class="title">If</span> <span class="title">the</span> <span class="title">optional</span> <span class="title">has</span> <span class="title">a</span> <span class="title">value</span> <span class="title">the</span> <span class="title">bb2</span> <span class="title">block</span> <span class="title">will</span> <span class="title">be</span> <span class="title">executed</span> <span class="title">before</span> <span class="title">jumping</span> </div><div class="line">    <span class="title">to</span> <span class="title">bb3</span>, <span class="title">if</span> <span class="title">it</span> <span class="title">doesn</span>'<span class="title">t</span> <span class="title">after</span> <span class="title">a</span> <span class="title">brief</span> <span class="title">jump</span> <span class="title">to</span> <span class="title">bb1</span>, <span class="title">the</span> <span class="title">function</span> <span class="title">will</span> <span class="title">proceed</span> <span class="title">to</span> <span class="title">bb3</span> <span class="title">releasing</span></div><div class="line">    <span class="title">the</span> <span class="title">retained</span> <span class="title">parameters</span>.</div><div class="line">    </div><div class="line">  */</div><div class="line">  %12 = <span class="title">load_weak</span> %3 : <span class="title">$</span>*@<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":11:18, <span class="title">scope</span> 18 // <span class="title">user</span>: %13</div><div class="line">  <span class="title">switch_enum</span> %12 : <span class="title">$Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">case</span> #<span class="title">Optional</span>.<span class="title">some</span>!<span class="title">enumelt</span>.1: <span class="title">bb2</span>, <span class="title">default</span> <span class="title">bb1</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":11:18, <span class="title">scope</span> 18 // <span class="title">id</span>: %13</div><div class="line">  <span class="title">bb1</span>:                                              // <span class="title">Preds</span>: <span class="title">bb0</span></div><div class="line">  /*</div><div class="line">    跳转到闭包的结尾。</div><div class="line">  */</div><div class="line">  <span class="title">br</span> <span class="title">bb3</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":11:18, <span class="title">scope</span> 16        // <span class="title">id</span>: %14</div><div class="line"></div><div class="line">// %15                                            // <span class="title">users</span>: %21, %20, %19, %16</div><div class="line"><span class="title">bb2</span>(%15 : <span class="title">$aClass</span>):                               // <span class="title">Preds</span>: <span class="title">bb0</span></div><div class="line">  /*</div><div class="line">    调用 <span class="title">aClass</span> 的 <span class="title">setter</span>，设置它的值为 42.</div><div class="line">  */</div><div class="line">  ...</div><div class="line">  %17 = <span class="title">integer_literal</span> <span class="title">$Builtin</span>.<span class="title">Int64</span>, 42, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:21, <span class="title">scope</span> 19 // <span class="title">user</span>: %18</div><div class="line">  %18 = <span class="title">struct</span> <span class="title">$Int</span> (%17 : <span class="title">$Builtin</span>.<span class="title">Int64</span>), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:21, <span class="title">scope</span> 19 // <span class="title">user</span>: %20</div><div class="line">  %19 = <span class="title">class_method</span> %15 : <span class="title">$aClass</span>, #<span class="title">aClass</span>.<span class="title">value</span>!<span class="title">setter</span>.1 : (<span class="title">aClass</span>) -&gt; (<span class="title">Int</span>) -&gt; () , <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:19, <span class="title">scope</span> 19 // <span class="title">user</span>: %20</div><div class="line">  %20 = <span class="title">apply</span> %19(%18, %15) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:19, <span class="title">scope</span> 19</div><div class="line">  <span class="title">strong_release</span> %15 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":13:5, <span class="title">scope</span> 18 // <span class="title">id</span>: %21</div><div class="line">  <span class="title">br</span> <span class="title">bb3</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":13:5, <span class="title">scope</span> 18         // <span class="title">id</span>: %22</div><div class="line"></div><div class="line"><span class="title">bb3</span>:                                              // <span class="title">Preds</span>: <span class="title">bb1</span> <span class="title">bb2</span></div><div class="line">  /*</div><div class="line">    释放所有获取的变量然后返回。</div><div class="line">  */</div><div class="line">  <span class="title">strong_release</span> %1 : <span class="title">$</span>@<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">id</span>: %23</div><div class="line">  <span class="title">unowned_release</span> %0 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">id</span>: %24</div><div class="line">  %25 = <span class="title">tuple</span> (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">user</span>: %26</div><div class="line">  <span class="title">return</span> %25 : <span class="title">$</span>(), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">id</span>: %26</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，忽略掉不同的 <code>ARC</code> 指令带来的性能的差异点，对不同阶段每种类型的捕获变量做一个快速的对比：</p>
<table>
<thead>
<tr>
<th>动作</th>
<th style="text-align:center">Unowned</th>
<th style="text-align:right">Weak</th>
</tr>
</thead>
<tbody>
<tr>
<td>预先调用 #1</td>
<td style="text-align:center">对象进行 unowned_retain 操作</td>
<td style="text-align:right">创建一个容器，并且对象进行 strong_retain 操作。创建一个可选值，存入到容器中，然后释放可选值</td>
</tr>
<tr>
<td>预先调用 #2</td>
<td style="text-align:center">strong_retain_unowned，unowned_retain 和 strong_release</td>
<td style="text-align:right">strong_retain</td>
</tr>
<tr>
<td>闭包执行</td>
<td style="text-align:center">strong_retain_unowned，unowned_release</td>
<td style="text-align:right">load_weak, 打开可选值, strong_release</td>
</tr>
<tr>
<td>调用之后</td>
<td style="text-align:center">unowned_release</td>
<td style="text-align:right">strong_release</td>
</tr>
</tbody>
</table>
<p>正如上面看到的 SIL 代码段那样，处理 weak 引用会涉及到更多的工作，因为需要处理引用需要的可选值。</p>
<p>参照<a href="https://github.com/apple/swift/blob/master/docs/SIL.rst%22" target="_blank" rel="external">官方文档</a>的描述，这里对涉及到的所有 ARC 指令做一个简要的解释：</p>
<ul>
<li><strong>unowned_retain</strong>：<em>增加堆对象中的 unowned 引用计数。</em></li>
<li><strong>strong_retain_unowned</strong> ：<em>断言对象的强引用计数大于 0，然后增加这个引用计数。</em></li>
<li><strong>strong_retain</strong>：<em>增加对象的强引用计数。</em></li>
<li><strong>load_weak</strong>：<em>不是真正的 ARC 调用，但是它将增加可选值指向对象的强引用计数。</em></li>
<li><strong>strong_release</strong>：<em>减少对象的强引用计数。如果释放操作把对象强引用计数变为0，对象将被销毁，然后弱引用将被清除。当整个强引用计数和 unowned 引用计数都为0时，对象的内存才会被释放。</em></li>
<li><strong>unowned_release</strong>：<em>减少对象的 unowned 引用计数。当整个强引用计数和 unowned 引用计数都为 0 时，对象的内存才会被释放。</em></li>
</ul>
<p>接下来深入到 <code>Swift</code> 运行时看看，这些指令都是如何被实现的，相关的代码文件有：<a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/HeapObject.cpp" target="_blank" rel="external">HeapObject.cpp</a>，<a href="https://github.com/apple/swift/blob/master/include/swift/Runtime/HeapObject.h" target="_blank" rel="external">HeapObject.h</a>，<a href="https://github.com/apple/swift/blob/master/stdlib/public/SwiftShims/RefCount.h" target="_blank" rel="external">RefCount.h</a> 和 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/Heap.cpp" target="_blank" rel="external">Heap.cpp</a>、 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/SwiftObject.mm" target="_blank" rel="external">SwiftObject.mm</a> 中的少量定义。容器实现可以在 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/MetadataImpl.h" target="_blank" rel="external">MetadataImpl.h</a> 找到，但是本文不展开讨论。</p>
<p>这些文件中定义大多数的 <code>ARC</code> 方法都有三种变体，一种是对 <code>Swift</code> 对象的基础实现，另外两种实现是针对非原生 Swift 对象的：桥接对象和未知对象。后面两种变体这里不予讨论。</p>
<p>第一个讨论指令集和 <code>unowned</code> 引用相关。</p>
<p>在 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/HeapObject.cpp" target="_blank" rel="external">HeapObject.cpp</a> 文件中间可以看到对 <code>unowned_retain</code> 和 <code>unowned_release</code> 的实现方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">SWIFT_RT_ENTRY_VISIBILITY</span></div><div class="line">void swift::swift_unownedRetain(<span class="type">HeapObject</span> *object)</div><div class="line">    <span class="type">SWIFT_CC</span>(<span class="type">RegisterPreservingCC_IMPL</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (!object)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  object-&gt;weakRefCount.increment();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">SWIFT_RT_ENTRY_VISIBILITY</span></div><div class="line">void swift::swift_unownedRelease(<span class="type">HeapObject</span> *object)</div><div class="line">    <span class="type">SWIFT_CC</span>(<span class="type">RegisterPreservingCC_IMPL</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (!object)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (object-&gt;weakRefCount.decrementShouldDeallocate()) &#123;</div><div class="line">    <span class="comment">// Only class objects can be weak-retained and weak-released.</span></div><div class="line">    auto metadata = object-&gt;metadata;</div><div class="line">    <span class="built_in">assert</span>(metadata-&gt;isClassObject());</div><div class="line">    auto classMetadata = static_cast&lt;const <span class="type">ClassMetadata</span>*&gt;(metadata);</div><div class="line">    <span class="built_in">assert</span>(classMetadata-&gt;isTypeMetadata());</div><div class="line">    <span class="type">SWIFT_RT_ENTRY_CALL</span>(swift_slowDealloc)</div><div class="line">        (object, classMetadata-&gt;getInstanceSize(),</div><div class="line">         classMetadata-&gt;getInstanceAlignMask());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>swift_unownedRetain</code> 是 <code>unowned_retain</code> 的具体实现，简单地进行 <code>unowned</code> 引用计数的原子增加操作（这里定义为<code>weakRefCount</code>），<code>swift_unownedRelease</code> 更加复杂，原因之前也描述过，当没有其他 unowned 引用存在时，它需要执行对象的析构操作。</p>
<p>但是整体来讲都不复杂，在<a href="https://github.com/apple/swift/blob/master/stdlib/public/SwiftShims/RefCount.h#L242" target="_blank" rel="external">这里</a>可以看到 <code>doDecrementShouldDeallocate</code> 方法，这个方法在上面代码中被一个命名类似的方法调用了。这个方法没有做太多，<code>swift_slowDealloc</code> 只是释放给定的指针。</p>
<p>到此已经有了一个对象的 unowned 引用，另外一个指令，<code>strong_retain_unowned</code> 用来创建一个强引用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">SWIFT_RT_ENTRY_VISIBILITY</span></div><div class="line">void swift::swift_unownedRetainStrong(<span class="type">HeapObject</span> *object)</div><div class="line">    <span class="type">SWIFT_CC</span>(<span class="type">RegisterPreservingCC_IMPL</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (!object)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  <span class="built_in">assert</span>(object-&gt;weakRefCount.getCount() &amp;&amp;</div><div class="line">         <span class="string">"object is not currently weakly retained"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (! object-&gt;refCount.tryIncrement())</div><div class="line">    _swift_abortRetainUnowned(object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为弱引用应该指向了这个对象，要使用断言来验证对象是否被弱引用，一旦断言通过，将尝试进行增加强引用计数的操作。一旦对象在进程中已经被释放，尝试将会失败。</p>
<p>所有类似于 <code>tryIncrement</code> 通过某种形式修改引用计数的方法都放到 <a href="https://github.com/apple/swift/blob/master/stdlib/public/SwiftShims/RefCount.h" target="_blank" rel="external">RefCount.h</a> 中，需要使用原子操作进行这些任务。</p>
<p>接下来讨论下 <code>weak</code> 引用的的实现，正如之前看到的那样，<code>swift_weakLoadStrong</code> 用来获取容器中可选值中强引用的对象。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">HeapObject</span> *swift::swift_weakLoadStrong(<span class="type">WeakReference</span> *ref) &#123;</div><div class="line">  <span class="keyword">if</span> (ref-&gt;<span class="type">Value</span> == (uintptr_t)nullptr) &#123;</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ref 可能被其他线程访问</span></div><div class="line">  auto ptr = __atomic_fetch_or(&amp;ref-&gt;<span class="type">Value</span>, <span class="type">WR_READING</span>, __ATOMIC_RELAXED);</div><div class="line">  <span class="keyword">while</span> (ptr &amp; <span class="type">WR_READING</span>) &#123;</div><div class="line">    short <span class="built_in">c</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (__atomic_load_n(&amp;ref-&gt;<span class="type">Value</span>, __ATOMIC_RELAXED) &amp; <span class="type">WR_READING</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (++<span class="built_in">c</span> == <span class="type">WR_SPINLIMIT</span>) &#123;</div><div class="line">        std::this_thread::yield();</div><div class="line">        <span class="built_in">c</span> -= <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    ptr = __atomic_fetch_or(&amp;ref-&gt;<span class="type">Value</span>, <span class="type">WR_READING</span>, __ATOMIC_RELAXED);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  auto object = (<span class="type">HeapObject</span>*)(ptr &amp; ~<span class="type">WR_NATIVE</span>);</div><div class="line">  <span class="keyword">if</span> (object == nullptr) &#123;</div><div class="line">    __atomic_store_n(&amp;ref-&gt;<span class="type">Value</span>, (uintptr_t)nullptr, __ATOMIC_RELAXED);</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (object-&gt;refCount.isDeallocating()) &#123;</div><div class="line">    __atomic_store_n(&amp;ref-&gt;<span class="type">Value</span>, (uintptr_t)nullptr, __ATOMIC_RELAXED);</div><div class="line">    <span class="type">SWIFT_RT_ENTRY_CALL</span>(swift_unownedRelease)(object);</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line">  &#125;</div><div class="line">  auto result = swift_tryRetain(object);</div><div class="line">  __atomic_store_n(&amp;ref-&gt;<span class="type">Value</span>, ptr, __ATOMIC_RELAXED);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个实现中，获取一个强引用需要<a href="https://github.com/apple/swift/pull/1454" target="_blank" rel="external">更多复杂同步操作</a>，在多线程竞争严重的情况下，会带来性能损耗。</p>
<p>在这里第一次出现的 <code>WeakReference</code> 对象，是一个简单的结构体，包含一个整型值字段指向目标对象，目标对象是使用 <code>HeapObject</code> 类来承载的每一个运行时的 Swift 对象。 </p>
<p>在 weak 引用询问当前线程设置的 <code>WR_READING</code> 标识之后，从  <code>WeakReference</code>  容器中获取 Swift 对象，如果对象不再有效，或者在等待获取资源时，它变成可以进行析构，当前的引用会被设置为 <em>null</em>。</p>
<p>如果对象依然有效，获取对象的尝试将会成功。</p>
<p>因此，从这个角度来讲，对 weak 引用的常规操作性能比 unowned 引用的更低（但是主要的问题还是在可选值操作上面）。</p>
<p><a name="conclusion"></a></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>保守的使用 weak 引用是否明智呢？答案是否定的，无论是从性能的角度还是代码清晰的角度而言。</p>
<p>使用正确的捕获修饰符类型，明确的表明代码中的生命周期特性，当其他人或者你自己在读你的代码时不容易误解。</p>
<p><a name="footnotes"></a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p><a name="1"></a><br>1、<em>苹果第一次讨论 weak/unowned 争议可以查看<a href="https://devforums.apple.com/message/987086#987086" target="_blank" rel="external">这里</a>，之后在 twitter 上 Joe Groff 对此也进行了讨论，并且被 Michael Tsai <a href="http://mjtsai.com/blog/2015/11/24/how-swift-implements-unowned-and-weak-references/" target="_blank" rel="external">总结成文</a>。<br>这篇文章从意图角度出发，提供了完整并且可操作的解释。</em></p>
<p><a name="2"></a><br>2、<em>从<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">维基百科</a>中可以找到关于 AST 的解释，还可以从 Slava Pestov 的<a href="https://medium.com/@slavapestov/the-secret-life-of-types-in-swift-ff83c3c000a5#.jyxx86n2x" target="_blank" rel="external">这篇文章</a>中看到关于 Swift 编译器中如何实现 AST 的一些细节。</em></p>
<p><a name="3"></a><br>3、<em>关于 SIL 的更多信息，请查看详尽的<a href="https://github.com/apple/swift/blob/master/docs/SIL.rst" target="_blank" rel="external">官方 SIL 指南</a>，还有 2015 LLVM 开发者会议的<a href="https://www.youtube.com/watch?v=Ntj8ab-5cvE" target="_blank" rel="external">视频</a>。Lex Chou 写的 SIL 快速指南可以点击这里<a href="https://github.com/lexchou/swallow/tree/master/docs/en/sil-3-instruction-references" target="_blank" rel="external">查看</a>。 </em></p>
<p><a name="4"></a><br>4、<em>查看在 Swift 中如何进行名称粉碎（name mangling）的细节，请查看 Lex Chou 的<a href="https://github.com/lexchou/swallow/tree/master/docs/en/sil-1-mangling" target="_blank" rel="external">这篇文章</a>。</em></p>
<p><a name="5"></a><br>5、<em>Mike Ash 在他的 Friday Q&amp;A 中的<a href="https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html" target="_blank" rel="external">一篇文章</a>中讨论了如何实现 weak 引用的一种实践方法，这种方法与目前 Swift 的方法对比起来有一些过时，但是其中的解释依然值得参考。</em></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Umberto Raimondi，&lt;a href=&quot;https://www.uraimo.com/2016/10/27/unowned-or-weak-lifetime-and-performance/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-10-27&lt;br&gt;译者：&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;shanks&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;每当处理循环引用（retain cycles）时，需要考量对象生命周期来选择&lt;code&gt;unowned&lt;/code&gt;或者&lt;code&gt;weak&lt;/code&gt;标识符，这已经成为了一个共识。但是有时仍然会心存疑问，在具体的使用中应该选择哪一个，或者退一步讲，保守的只使用 weak 是不是一个好的选择呢？&lt;/p&gt;
&lt;p&gt;本文首先对循环引用的基础知识做一个简要介绍，然后会分析 Swift 源代码的一些片段，讲解 &lt;code&gt;unowned&lt;/code&gt; 和 &lt;code&gt;weak&lt;/code&gt;  在生命周期和性能上的差异点，希望看完本文以后，在的使用场景中，能使用正确的弱引用类型。&lt;/p&gt;
    
    </summary>
    
      <category term="uraimo" scheme="https://swift.gg/categories/uraimo/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>在 iOS 上用 Core Image 实现人脸检测</title>
    <link href="https://swift.gg/2017/05/11/face-detection-core-image/"/>
    <id>https://swift.gg/2017/05/11/face-detection-core-image/</id>
    <published>2017-05-10T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Gregg Mojica，<a href="http://www.appcoda.com/face-detection-core-image/" target="_blank" rel="external">原文链接</a>，原文日期：2016-09-06<br>译者：<a href="http://hulizhen.me" target="_blank" rel="external">智多芯</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>Core Image 是 Cocoa Touch 框架提供的功能强大的 API，是 iOS SDK 中常常被忽视的关键部件。本教程将尝试探索 Core Image 提供的人脸识别功能，并将其应用到 iOS App 中。</p>
<blockquote>
<p>注：这是中高级 iOS 教程，本教程假设你已经使用过类似 UIImagePicker，Core Image 等技术。如果你对这些还不熟悉，先看看<a href="http://www.appcoda.com/ios-programming-course" target="_blank" rel="external">我们的 iOS 教程系列</a>，等你准备好了再看这篇文章。</p>
</blockquote>
<a id="more"></a>
<h2 id="接下来要做的事"><a href="#接下来要做的事" class="headerlink" title="接下来要做的事"></a>接下来要做的事</h2><p>自从 iOS 5（大概在2011年左右）之后，iOS 开始支持人脸识别，只是用的人不多。人脸识别 API 让开发者不仅可以进行人脸检测，还能识别微笑、眨眼等表情。</p>
<p>首先创建一个简单的应用，探索一下 Core Image 提供的人脸识别技术，该应用可以识别出照片中的人脸并用方框将人脸框起来。在第二个例子中，用户可以拍照并检测照片上是否有人脸出现，如果有则提取人脸坐标。通过这两个例子，你将学会 iOS 上所有关于人脸识别的技术，并充分利用它强大却经常被忽视的功能。</p>
<p>下面开始吧！</p>
<h2 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h2><p><a href="https://github.com/appcoda/FaceDetector/raw/master/FaceDetectorStarter.zip" target="_blank" rel="external">下载</a>并在 Xcode 中打开起始工程。该工程中的 Storyboard 仅包含一个已连接到代码的 IBOutlet 和 imageView。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/09/face-detection-storyboard.jpg" alt=""></p>
<blockquote>
<p><strong>注</strong>：项目中的图片由 <a href="http://unsplash.com/" target="_blank" rel="external">unsplash.com</a> 提供。</p>
</blockquote>
<p>在开始使用 Core Image 进行人脸识别之前，需要将 Core Image 库导入项目中。打开 ViewController.swift 文件，在文件最上方插入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> CoreImage</div></pre></td></tr></table></figure>
<h2 id="用-Core-Image-实现人脸检测"><a href="#用-Core-Image-实现人脸检测" class="headerlink" title="用 Core Image 实现人脸检测"></a>用 Core Image 实现人脸检测</h2><p>在起始工程的 storyboard 里包含一个通过 IBOutlet 连接到代码中的 imageView。下一步将实现人脸检测的代码。先把以下代码加入 swift 文件中，后面再解释：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">detect</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> personciImage = <span class="type">CIImage</span>(image: personPic.image!) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> accuracy = [<span class="type">CIDetectorAccuracy</span>: <span class="type">CIDetectorAccuracyHigh</span>]</div><div class="line">    <span class="keyword">let</span> faceDetector = <span class="type">CIDetector</span>(ofType: <span class="type">CIDetectorTypeFace</span>, context: <span class="literal">nil</span>, options: accuracy)</div><div class="line">    <span class="keyword">let</span> faces = faceDetector?.features(<span class="keyword">in</span>: personciImage)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> face <span class="keyword">in</span> faces <span class="keyword">as</span>! [<span class="type">CIFaceFeature</span>] &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Found bounds are <span class="subst">\(face.bounds)</span>"</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> faceBox = <span class="type">UIView</span>(frame: face.bounds)</div><div class="line">        faceBox.layer.borderWidth = <span class="number">3</span></div><div class="line">        faceBox.layer.borderColor = <span class="type">UIColor</span>.red.cgColor</div><div class="line">        faceBox.backgroundColor = <span class="type">UIColor</span>.clear</div><div class="line">        personPic.addSubview(faceBox)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasLeftEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Left eye bounds are <span class="subst">\(face.leftEyePosition)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasRightEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Right eye bounds are <span class="subst">\(face.rightEyePosition)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里解释一下上面的代码：</p>
<ul>
<li>第 3 行：从 storyboard 中的 UIImageView 提取出 UIImage 并转换成 CIImage，将其保存在新创建的 <code>personciImage</code> 变量中。Core Image 需要用到 CIImage。</li>
<li>第 7 行：创建一个 <code>accuracy</code> 变量并设置为 <code>CIDetectorAccuracyHigh</code>。你可以选择 <code>CIDetectorAccuracyHigh</code> 或 <code>CIDetectorAccuracyLow</code>。本文希望得到高精度的结果，因此选择了 <code>CIDetectorAccuracyHigh</code>。</li>
<li>第 8 行：创建一个 <code>faceDetector</code> 变量并设置为  <code>CIDetector</code>  的实例。实例化 <code>CIDetector</code> 时将前文创建的 <code>accuracy</code> 作为参数传入。</li>
<li>第 9 行：通过调用 <code>faceDetector</code> 的 <code>features(in:)</code> 方法可检测出给定图像的所有人脸，最终以数组的形式返回所有人脸。</li>
<li>第 11 行：遍历数组中所有的人脸，并将其转换为 <code>CIFaceFeature</code> 类型。</li>
<li>第 15 行：创建一个 UIView 实例并命名为 <code>faceBox</code>，然后根据 <code>faces.first</code> 设置其大小。这将画一个方框用于高亮检测到的人脸。</li>
<li>第 17 行：将 <code>faceBox</code> 的边框宽度设为 3。</li>
<li>第 18 行：将边框颜色设置为红色。</li>
<li>第 19 行：将背景色设为透明，表示该视图没有可见的背景。</li>
<li>第 20 行：最后，将该视图添加到 <code>personPic</code> 视图中。</li>
<li>第 22-28 行：这些 API 不仅可以检测出人脸，还能检测出人脸的左右眼，但本文就不在图像中高亮人眼了。本文只想展示一些 <code>CIFaceFeature</code> 的相关属性。</li>
</ul>
<p>接着调用在 <code>viewDidLoad</code>中调用  <code>detect</code> 方法，在方法中增加下列一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">detect()</div></pre></td></tr></table></figure>
<p>编译并运行程序，可以看到如下效果：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/09/face-detection-2.png" alt=""></p>
<p>根据控制台的输出结果，似乎可以检测出人脸：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">Found</span> bounds are (<span class="number">177.0</span>, <span class="number">415.0</span>, <span class="number">380.0</span>, <span class="number">380.0</span>)</div></pre></td></tr></table></figure>
<p>还有几个问题没有处理：</p>
<ul>
<li>人脸识别程序应用于原始图像上，而原始图像有着比 imageView 更高的分辨率。另外，工程中 imageView 的 content mode 被设置为 aspect fit。为了正确地画出检测框，还需要计算出 imageView 中识别到的人脸的实际位置和尺寸。</li>
<li>再者，Core Image 和 UIView（或者UIKit）使用了不同的坐标系（如下图所示），因此还需要实现 Core Image 坐标到 UIView 坐标的转换。</li>
</ul>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/09/core-image-coordinate-1240x835.jpg" alt=""></p>
<p>现在使用下面的代码替换 <code>detect()</code> 方法中的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">detect</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> personciImage = <span class="type">CIImage</span>(image: personPic.image!) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> accuracy = [<span class="type">CIDetectorAccuracy</span>: <span class="type">CIDetectorAccuracyHigh</span>]</div><div class="line">    <span class="keyword">let</span> faceDetector = <span class="type">CIDetector</span>(ofType: <span class="type">CIDetectorTypeFace</span>, context: <span class="literal">nil</span>, options: accuracy)</div><div class="line">    <span class="keyword">let</span> faces = faceDetector?.features(<span class="keyword">in</span>: personciImage)</div><div class="line">    </div><div class="line">    <span class="comment">// 将 Core Image 坐标转换成 UIView 坐标</span></div><div class="line">    <span class="keyword">let</span> ciImageSize = personciImage.extent.size</div><div class="line">    <span class="keyword">var</span> transform = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1</span>, y: -<span class="number">1</span>)</div><div class="line">    transform = transform.translatedBy(x: <span class="number">0</span>, y: -ciImageSize.height)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> face <span class="keyword">in</span> faces <span class="keyword">as</span>! [<span class="type">CIFaceFeature</span>] &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Found bounds are <span class="subst">\(face.bounds)</span>"</span>)</div><div class="line">        </div><div class="line">        <span class="comment">// 实现坐标转换</span></div><div class="line">        <span class="keyword">var</span> faceViewBounds = face.bounds.applying(transform)</div><div class="line">        </div><div class="line">        <span class="comment">// 计算实际的位置和大小</span></div><div class="line">        <span class="keyword">let</span> viewSize = personPic.bounds.size</div><div class="line">        <span class="keyword">let</span> scale = <span class="built_in">min</span>(viewSize.width / ciImageSize.width,</div><div class="line">                        viewSize.height / ciImageSize.height)</div><div class="line">        <span class="keyword">let</span> offsetX = (viewSize.width - ciImageSize.width * scale) / <span class="number">2</span></div><div class="line">        <span class="keyword">let</span> offsetY = (viewSize.height - ciImageSize.height * scale) / <span class="number">2</span></div><div class="line">        </div><div class="line">        faceViewBounds = faceViewBounds.applying(<span class="type">CGAffineTransform</span>(scaleX: scale, y: scale))</div><div class="line">        faceViewBounds.origin.x += offsetX</div><div class="line">        faceViewBounds.origin.y += offsetY</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> faceBox = <span class="type">UIView</span>(frame: faceViewBounds)</div><div class="line">        </div><div class="line">        faceBox.layer.borderWidth = <span class="number">3</span></div><div class="line">        faceBox.layer.borderColor = <span class="type">UIColor</span>.red.cgColor</div><div class="line">        faceBox.backgroundColor = <span class="type">UIColor</span>.clear</div><div class="line">        personPic.addSubview(faceBox)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasLeftEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Left eye bounds are <span class="subst">\(face.leftEyePosition)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasRightEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Right eye bounds are <span class="subst">\(face.rightEyePosition)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，上面的代码使用放射变换将 Core Image 坐标转换成了 UIKit 坐标。然后，添加了一些额外的代码用于计算框视图的实际位置和尺寸。</p>
<p>现在再一次运行程序，应该可以看到检测框将识别出的人脸框起来了，这样就成功地用 Core Image 检测到人脸了。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/09/face-detection-result-1240x809.jpg" alt=""></p>
<h2 id="开发一个支持人脸识别的摄像应用"><a href="#开发一个支持人脸识别的摄像应用" class="headerlink" title="开发一个支持人脸识别的摄像应用"></a>开发一个支持人脸识别的摄像应用</h2><p>假设有一个用于摄像或拍照的应用程序，我们希望在拍照后检测是否有人脸出现。如果出现了人脸，可能想将这张照片打上一些标签并对其分类。下面结合 <code>UIImagePicker</code> 类，拍照完成时立刻运行上面的人脸检测代码。</p>
<p>上面的起始工程中已经创建了一个 <code>CameraViewController</code> 类，将其代码更新成下面这样，用以实现摄像功能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraViewController</span>: <span class="title">UIViewController</span>, <span class="title">UIImagePickerControllerDelegate</span>, <span class="title">UINavigationControllerDelegate</span> </span>&#123;</div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span>!</div><div class="line">    <span class="keyword">let</span> imagePicker = <span class="type">UIImagePickerController</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        imagePicker.delegate = <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">takePhoto</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> !<span class="type">UIImagePickerController</span>.isSourceTypeAvailable(.camera) &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        imagePicker.allowsEditing = <span class="literal">false</span></div><div class="line">        imagePicker.sourceType = .camera</div><div class="line">        </div><div class="line">        present(imagePicker, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any])</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> pickedImage = info[<span class="type">UIImagePickerControllerOriginalImage</span>] <span class="keyword">as</span>? <span class="type">UIImage</span> &#123;</div><div class="line">            imageView.contentMode = .scaleAspectFit</div><div class="line">            imageView.image = pickedImage</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">self</span>.detect()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</div><div class="line">        dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开始的几行代码设置了 <code>UIImagePicker</code> 代理。在 <code>didFinishPickingMediaWithInfo</code> 方法（这是一个 <code>UIImagePicker</code> 代理方法）中，将传入的图像设置到 imageView 上，最后关闭拾取器并调用 <code>detect</code> 函数。</p>
<p>上面的代码还未实现 <code>detect</code> 函数，将下面的代码加上：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">detect</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> imageOptions = <span class="type">NSDictionary</span>(object: <span class="type">NSNumber</span>(value: <span class="number">5</span>) <span class="keyword">as</span> <span class="type">NSNumber</span>, forKey: <span class="type">CIDetectorImageOrientation</span> <span class="keyword">as</span> <span class="type">NSString</span>)</div><div class="line">    <span class="keyword">let</span> personciImage = <span class="type">CIImage</span>(cgImage: imageView.image!.cgImage!)</div><div class="line">    <span class="keyword">let</span> accuracy = [<span class="type">CIDetectorAccuracy</span>: <span class="type">CIDetectorAccuracyHigh</span>]</div><div class="line">    <span class="keyword">let</span> faceDetector = <span class="type">CIDetector</span>(ofType: <span class="type">CIDetectorTypeFace</span>, context: <span class="literal">nil</span>, options: accuracy)</div><div class="line">    <span class="keyword">let</span> faces = faceDetector?.features(<span class="keyword">in</span>: personciImage, options: imageOptions <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">AnyObject</span>])</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> face = faces?.first <span class="keyword">as</span>? <span class="type">CIFaceFeature</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"found bounds are <span class="subst">\(face.bounds)</span>"</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"Say Cheese!"</span>, message: <span class="string">"We detected a face!"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</div><div class="line">        alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</div><div class="line">        <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasSmile &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"face is smiling"</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasLeftEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Left eye bounds are <span class="subst">\(face.leftEyePosition)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasRightEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Right eye bounds are <span class="subst">\(face.rightEyePosition)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"No Face!"</span>, message: <span class="string">"No face was detected"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</div><div class="line">        alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</div><div class="line">        <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 detect() 函数和之前的实现非常相似，不过这一次我们使用的是临时拍到的图像。根据检测结果会显示一个提示框，提示是否检测到人脸。运行程序来快速测试一下。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/08/faces.png" alt=""></p>
<p>CIFaceFeature 中的一些属性和方法前面已经尝试过了。例如，若要判断照片中的人是否正在微笑，可以通过 <code>hasSmile</code> 属性判断。还可以通过 <code>hasLeftEyePosition</code>  （或<code>hasRightEyePosition</code>）属性检查是否有左眼（或右眼）出现（希望有）。</p>
<p>还可以通过 <code>hasMouthPosition</code> 来判断是否出现了嘴巴。如果出现了，可以通过 <code>mouthPosition</code> 属性得到其坐标，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (face.hasMouthPosition) &#123;</div><div class="line">     <span class="built_in">print</span>(<span class="string">"mouth detected"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，通过 Core Image 进行人脸识别极其简单。除了检测嘴、微笑、眼睛位置等，还可以通过 <code>leftEyeClosed</code> （或<code>rightEyeClosed</code>）判断左眼（或右眼）是否睁开。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本教程探索了 Core Image 提供的人脸识别 API，并展示了如何在摄像机应用中使用该功能。本文通过 UIImagePicker 拍摄图像，并检测该图像中是否有人的出现。</p>
<p>如你所见，Core Image 的人脸识别 API 有着非常多的用处！希望你能觉得本教程有所帮助，让你了解到了这一鲜为人知的 iOS API！</p>
<blockquote>
<p> 注：欢迎继续关注让人脸识别更加强大的<a href="https://www.appcoda.com/tag/neural-net/" target="_blank" rel="external">神经网络系列教程</a>。</p>
</blockquote>
<p>你可以从<a href="https://github.com/appcoda/FaceDetector" target="_blank" rel="external">这里</a>下载到最终的工程代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Gregg Mojica，&lt;a href=&quot;http://www.appcoda.com/face-detection-core-image/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-09-06&lt;br&gt;译者：&lt;a href=&quot;http://hulizhen.me&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;智多芯&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Core Image 是 Cocoa Touch 框架提供的功能强大的 API，是 iOS SDK 中常常被忽视的关键部件。本教程将尝试探索 Core Image 提供的人脸识别功能，并将其应用到 iOS App 中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：这是中高级 iOS 教程，本教程假设你已经使用过类似 UIImagePicker，Core Image 等技术。如果你对这些还不熟悉，先看看&lt;a href=&quot;http://www.appcoda.com/ios-programming-course&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我们的 iOS 教程系列&lt;/a&gt;，等你准备好了再看这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>创建多个 Outlet 教程</title>
    <link href="https://swift.gg/2017/05/10/multiple-outlets-tutorial/"/>
    <id>https://swift.gg/2017/05/10/multiple-outlets-tutorial/</id>
    <published>2017-05-09T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：IOSCREATER，<a href="https://www.ioscreator.com/tutorials/multiple-outlets-tutorial" target="_blank" rel="external">原文链接</a>，原文日期：2016/02/08<br>译者：<a href="undefined">EyreFree</a>；校对：<a href="undefined">DianQK</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>为多个对象创建多个 Outlet 是比较费时费力的一件事情。而且多个对象也可能共享同一个的 Outlet。在本教程中，我们将会根据按钮的 tag 值来创建多个 Outlet。本教程使用 Xcode 7.2 作为开发工具，使用 Swift 2.1 和 iOS 9 进行构建。</p>
<a id="more"></a>
<p>打开 Xcode 并新建一个 Single View Application。Product Name 项填写 <strong>IOS9MultipleOutletsTutorial</strong>，然后填写你的 Organization Name 和 Organization Identifier。Language 项选择 Swift，并且确保 Devices 项只选择了 iPhone。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56962b56a12f44ae28276e6e/1452682071748/?format=750w" alt=""></p>
<p>打开 <strong>StoryBoard</strong> 并从 Object Library 拖一个按钮到主视图的左上方。打开 Attribute Inspector（属性检查器）并将 View 的 Tag 设为 10。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56967c4fb204d5edf92596e3/1452702801210/?format=300w" alt=""></p>
<p>复制此按钮，并将该按钮放置于和第一个按钮相同一行的主视图右上角位置，该按钮和第一个按钮具有相同的 Tag。<br>接下来，从 Object Library 中拖出另一个按钮到主视图中，将该按钮放在左上角按钮的下面。选中这个按钮并且打开 Attribute Inspector，将 View 中的 Tag 设为 20。然后再次复制刚添加的这个按钮并将复制的按钮放在刚添加的按钮的右方。到这里 Storyboard 应该是如下图所示的样子：</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56b3af28746fb99c72839226/1454616374964/?format=750w" alt=""></p>
<p>选中主视图然后点击 Interface Builder 右下角的 Resolve Auto Layout Issues 按钮。选择 All Views 中的 Reset to Suggested Constraint 这一选项。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56b50962746fb9a53ff4610c/1454705005083/?format=500w" alt=""></p>
<p>打开文件 <strong>ViewController.swift</strong> 并将方法 <strong>viewDidLoad</strong> 改为如下代码块所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> subview <span class="keyword">in</span> view.subviews <span class="keyword">where</span> subview.tag == <span class="number">10</span> &#123;</div><div class="line">        <span class="keyword">let</span> button = subview <span class="keyword">as</span>! <span class="type">UIButton</span></div><div class="line">        button.addTarget(<span class="keyword">self</span>, action: <span class="string">"changeColorRed:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span> subview <span class="keyword">in</span> view.subviews <span class="keyword">where</span> subview.tag == <span class="number">20</span> &#123;</div><div class="line">        <span class="keyword">let</span> button = subview <span class="keyword">as</span>! <span class="type">UIButton</span></div><div class="line">        button.addTarget(<span class="keyword">self</span>, action: <span class="string">"changeColorGreen:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 subview 属性可以用于遍历主视图的子视图。每个按钮都根据 tag 值的不同添加了一个相应的 target。接下来，我们需要实现 target 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeColorRed</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> button: <span class="type">UIButton</span> = sender <span class="keyword">as</span>! <span class="type">UIButton</span></div><div class="line">    button.tintColor = <span class="type">UIColor</span>.redColor()</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeColorGreen</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> button: <span class="type">UIButton</span> = sender <span class="keyword">as</span>! <span class="type">UIButton</span></div><div class="line">    button.tintColor = <span class="type">UIColor</span>.greenColor()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当选中按钮时，按钮的颜色会随之改变。<strong>构建并运行</strong>项目，接下来我们就点击按钮来更改这些按钮的颜色了。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56b3afc662cd945febf7cbf7/1454616530586/?format=750w" alt=""></p>
<p>你可以从 ioscreator 的 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">GitHub</a> 下载 <strong>IOS9MultipleOutletsTutorial</strong> 的源码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：IOSCREATER，&lt;a href=&quot;https://www.ioscreator.com/tutorials/multiple-outlets-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016/02/08&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;EyreFree&lt;/a&gt;；校对：&lt;a href=&quot;undefined&quot;&gt;DianQK&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;为多个对象创建多个 Outlet 是比较费时费力的一件事情。而且多个对象也可能共享同一个的 Outlet。在本教程中，我们将会根据按钮的 tag 值来创建多个 Outlet。本教程使用 Xcode 7.2 作为开发工具，使用 Swift 2.1 和 iOS 9 进行构建。&lt;/p&gt;
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 简洁之道(下)</title>
    <link href="https://swift.gg/2017/05/09/self-explained-swift-2/"/>
    <id>https://swift.gg/2017/05/09/self-explained-swift-2/</id>
    <published>2017-05-08T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Weston Hanners，<a href="https://www.alloc-init.com/blog/2017.01.19" target="_blank" rel="external">原文链接</a>，原文日期：2017-01-19<br>译者：<a href="http://coderafi.github.io/" target="_blank" rel="external">CoderAFI</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>工具让代码容易管理和阅读</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import UIKit</div><div class="line">import PlaygroundSupport</div><div class="line"></div><div class="line">// 欢迎阅读 Swift 简洁之道的第二篇文章. 这次的 playground 将会在上次的代码基础上做些修改并删除掉一些无用的注释.</div><div class="line">// 如果你感觉很难理解,可以先去阅读[Swift 简洁之道(上)](http://swift.gg/2017/04/24/self-explained-swift/)</div><div class="line"></div><div class="line">// 这篇文章我要传达的思想是 &quot;工具封装&quot;. 你可以创建很多可以在多个 app 中复用的工具来帮你节省时间,比方说 view 的创建和界面布局都可以抽象成辅助工具.</div><div class="line"></div><div class="line">// 这里所谓的 &quot;工具&quot; 就是一些 Swift extensions. 其实 extensions 能够在 Swift 已有的类型上添加新的函数.</div><div class="line">// 下面的代码中的函数就可以帮助我们初始化一些公共UI控件并且能够生成一些共用的界面布局.</div><div class="line"></div><div class="line">extension UIView &#123; // 布局扩展</div><div class="line"></div><div class="line">		// 这个函数能够缩短自动布局的代码行数，让代码更简洁</div><div class="line">    func constrainTo(view: UIView) &#123;</div><div class="line"></div><div class="line">				// 打开 autolayout 配置</div><div class="line">        view.translatesAutoresizingMaskIntoConstraints = false</div><div class="line"></div><div class="line">				// 根据函数名称, 我们可以判断参数 view 是当前 view 的父视图</div><div class="line">				// 在这里可能看起来有点奇怪, 但是当你看到如何使用时就会豁然开朗了</div><div class="line">        view.addSubview(self)</div><div class="line"></div><div class="line">				// 上篇文章之后，我发现了 NSLayoutAnchor 布局系统，它让自动布局的约束构建更加简洁明了，所以我们这里使用它</div><div class="line">        view.topAnchor.constraint(equalTo: self.topAnchor).isActive = true</div><div class="line">        view.bottomAnchor.constraint(equalTo: self.bottomAnchor).isActive = true</div><div class="line">        view.leftAnchor.constraint(equalTo: self.leftAnchor).isActive = true</div><div class="line">        view.rightAnchor.constraint(equalTo: self.rightAnchor).isActive = true</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">extension UIStackView &#123;</div><div class="line"></div><div class="line">		// UIStackView 控件有很多经常修改的配置属性. 下面的便利构造函数，可以做到只用一行代码来完成这些事</div><div class="line">    convenience init(arrangedSubviews: [UIView],</div><div class="line">                     axis: UILayoutConstraintAxis,</div><div class="line">                     distribution: UIStackViewDistribution,</div><div class="line">                     alignment: UIStackViewAlignment) &#123;</div><div class="line"></div><div class="line">				// 调用原来的构造器</div><div class="line">        self.init(arrangedSubviews: arrangedSubviews)</div><div class="line"></div><div class="line">				// 给配置属性赋值</div><div class="line">        self.axis = axis</div><div class="line">        self.distribution = distribution</div><div class="line">        self.alignment = alignment</div><div class="line"></div><div class="line">				// 由于该属性经常设置，所以在这我们直接给隐蔽的封装进去</div><div class="line">        self.translatesAutoresizingMaskIntoConstraints = false</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 下面我们来创建一些类函数来帮助创建 app 的 &quot;主题&quot;</div><div class="line"></div><div class="line">// 大部分情况下，这里都是把我上篇文章的代码重构到类函数里. 同时,提供不同的参数来保证每个实例的多态性</div><div class="line"></div><div class="line">// 同样的 translatesAutoresizingMaskIntoConstraints 属性也要设置来保障 view controller 中的代码简洁</div><div class="line"></div><div class="line">extension UIButton &#123;</div><div class="line"></div><div class="line">    class func standardAwesomeButton(title: String) -&gt; UIButton &#123;</div><div class="line"></div><div class="line">        let button = UIButton()</div><div class="line"></div><div class="line">        button.setTitle(title, for: .normal)</div><div class="line">        button.translatesAutoresizingMaskIntoConstraints = false</div><div class="line"></div><div class="line">        return button</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">extension UILabel &#123;</div><div class="line"></div><div class="line">    class func standardAwesomeLabel(title: String) -&gt; UILabel &#123;</div><div class="line"></div><div class="line">        let label = UILabel()</div><div class="line"></div><div class="line">        label.font = UIFont(name: &quot;Menlo&quot;, size: 14)</div><div class="line">        label.textColor = .white</div><div class="line">        label.text = title</div><div class="line">        label.textAlignment = .center</div><div class="line">        label.translatesAutoresizingMaskIntoConstraints = false</div><div class="line"></div><div class="line">        return label</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class OurAwesomeViewController: UIViewController &#123;</div><div class="line"></div><div class="line">    lazy var titleLabel: UILabel = &#123;</div><div class="line">        return UILabel.standardAwesomeLabel(title: &quot;Awesome&quot;)</div><div class="line">    &#125;()</div><div class="line"></div><div class="line">    lazy var button: UIButton = &#123;</div><div class="line"></div><div class="line">        let button = UIButton.standardAwesomeButton(title: &quot;Press Me&quot;)</div><div class="line">        button.addTarget(self,</div><div class="line">                         action: #selector(OurAwesomeViewController.buttonTest),</div><div class="line">                         for: .touchUpInside)</div><div class="line"></div><div class="line">        return button</div><div class="line">    &#125;()</div><div class="line"></div><div class="line">    override func loadView() &#123;</div><div class="line"></div><div class="line">        super.loadView()</div><div class="line"></div><div class="line">        view.backgroundColor = .blue</div><div class="line"></div><div class="line">				// 这里用到了我们自定义的 UIStackView 的初始化函数, 这样不仅减少了重复的代码量而且让代码更易读.</div><div class="line">        let verticalLayout = UIStackView(arrangedSubviews: [titleLabel, button],</div><div class="line">                                         axis: .vertical,</div><div class="line">                                         distribution: .fill,</div><div class="line">                                         alignment: .fill)</div><div class="line"></div><div class="line">        verticalLayout.isLayoutMarginsRelativeArrangement = true</div><div class="line">        verticalLayout.layoutMargins = UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)</div><div class="line"></div><div class="line">				// 调用我们新的布局函数，这让添加界面和设置界面约束更加容易、简洁</div><div class="line">        verticalLayout.constrainTo(view: view)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func buttonTest(sender: UIButton) &#123;</div><div class="line">        view.backgroundColor = .red</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 将上面的 view controller 绑定到 playground 上.</div><div class="line">PlaygroundPage.current.liveView = OurAwesomeViewController()</div><div class="line">PlaygroundPage.current.needsIndefiniteExecution = true</div><div class="line"></div><div class="line">// 正如你所见, 布局代码清晰而且易管理. 整个 View Controller 只有 43 行左右的代码量.</div><div class="line">// 以往，很多时候由于忘记设置属性或者调用函数而导致界面不显示，有了上面这些封装工具之后，代码不仅可以共享而且很多奇怪的问题也可以做到迅速定位.</div><div class="line"></div><div class="line">// 采用这些技巧，使得 view controllers 更加简单和主题化. 如果你愿意，当然可以为 button，label 或者其他 UI 控件创建很多不同的样式扩展.</div><div class="line">// 一次创建,一处更改,整个 app 都会生效 !!!</div><div class="line"></div><div class="line">// 这就是我们第二篇文章的全部内容，下篇文章，我将会介绍如何将业务逻辑从 ViewControllers 中剥离出来, 以保障架构的稳定性.</div></pre></td></tr></table></figure>
<p><a href="https://www.alloc-init.com/content/downloads/2-LayoutImproved.zip" target="_blank" rel="external">下载示例代码</a></p>
<blockquote>
<p>译者注：上面的这些翻译，个人认为只是作者为了阐述清楚代码的原理(也就是说为什么这样做能使代码简洁)，而并非是每行代码都要加注释.</p>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Weston Hanners，&lt;a href=&quot;https://www.alloc-init.com/blog/2017.01.19&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-01-19&lt;br&gt;译者：&lt;a href=&quot;http://coderafi.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CoderAFI&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;工具让代码容易管理和阅读&lt;/p&gt;
    
    </summary>
    
      <category term="alloc-init" scheme="https://swift.gg/categories/alloc-init/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>你需要的大概不是 enumerated</title>
    <link href="https://swift.gg/2017/05/05/you-probably-don&#39;t-want-enumerated/"/>
    <id>https://swift.gg/2017/05/05/you-probably-don&#39;t-want-enumerated/</id>
    <published>2017-05-04T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：KHANLOU，<a href="http://khanlou.com/2017/03/you-probably-don&#39;t-want-enumerated/" target="_blank" rel="external">原文链接</a>，原文日期：2017-03-28<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="external">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="external">Cwift</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 标准库里最容易被滥用的就是 Sequence 的 <code>enumerated()</code> 函数。这个函数会返回一个新的序列，包含了初始序列里的所有元素，以及与元素相对应的编号。</p>
<p><code>enumerated()</code> 很容易被误解。因为它给每一个元素都提供了一个编号，对于很多问题来说这是一个很简便的方案。然而，这些问题大多数都可以被另一种方式更好的解决，让我们来看一下其中的一些例子吧，要注意理解它们有什么问题，然后如何使用更好的抽象去解决它们。</p>
<a id="more"></a>
<p>使用 <code>enumerated()</code> 最关键的问题在于大家都认为它返回的是每一个元素和元素的索引值，但实际上并不是这样的。因为它可以适用于所有序列，而序列是不能保证有索引的，由此可知它返回的并不是索引值。下面的代码里，这个变量的名字是 <code>offset</code>，而不是 <code>index</code>，这是接下来文章里会默认使用的命名方式。offset 总是一个整型，从 0 开始，间隔为 1，跟每一个元素逐一对应。对于 <code>Array</code>，这刚好跟它的索引值完全一致，但除此之外的其他所有类型，都不会有这种巧合发生。让我们来看一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> array = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>]</div><div class="line"><span class="keyword">let</span> arraySlice = array[<span class="number">2</span>..&lt;<span class="number">5</span>]</div><div class="line">arraySlice[<span class="number">2</span>] <span class="comment">// =&gt; "c"</span></div><div class="line">arraySlice.enumerated().first <span class="comment">// =&gt; (0, "c")</span></div><div class="line">arraySlice[<span class="number">0</span>] <span class="comment">// fatalError</span></div></pre></td></tr></table></figure>
<p>我们的变量 <code>arraySlice</code>，毫无疑问是 <code>ArraySlice</code> 类型。然而，它的<code>startIndex</code> 很明显是 2，而不是 0，但当我们调用 <code>enumerated()</code> 和 <code>first</code> 的时候, 它会返回一个元组，包含了一个offset，值为 0，以及它的第一个元素 “c”。</p>
<p>你以为，你会获得与下面等价的代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="built_in">zip</span>(array.<span class="built_in">indices</span>, array)</div></pre></td></tr></table></figure>
<p>但实际上你获取到的是这个</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="built_in">zip</span>((<span class="number">0</span>..&lt;array.<span class="built_in">count</span>), array)</div></pre></td></tr></table></figure>
<p>如果你不是在使用 <code>Array</code> 的话，随时可能会产生错误的行为。</p>
<p>而且实际上你获取到的是一个 offset，而不是 index，使用 <code>enumerated()</code> 也会有别的问题。很多时候你也许想用 <code>enumerated()</code>， 但有别的更好的抽象可以使用。让我们来看一些例子。</p>
<p>我见到  <code>enumerated()</code> 最常用的方式是对一个数组执行 enumerated，使用返回的 offset 来获取另一个数组对应的元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (offset, model) <span class="keyword">in</span> models.enumerated() &#123;</div><div class="line">	<span class="keyword">let</span> viewController = viewControllers[offset]</div><div class="line">	viewController.model = model</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这段代码可以正常运作，但前提是 <code>models</code> 和 <code>viewControllers</code> 都是 Array 类型，使用整型来作为索引值类型，从 0 开始。另一个前提是这两个数组拥有相同的长度。如果<code>models</code> 的数组长度比 <code>viewControllers</code> 短的话，就会崩溃。我们还多了一个没有实际意义的多余的变量 <code>offset</code>。一个简洁的 Swift 实现方式应该是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (model, viewController) <span class="keyword">in</span> <span class="built_in">zip</span>(models, viewControllers) &#123;</div><div class="line">	viewController.model = model</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码更加简洁，而且适用于所有 <code>Sequence</code> 类型，而且可以安全地处理不等长的数组。</p>
<p>让我们看看另一个例子，这段代码给第一个 <code>imageView</code> 和它的容器以及每个 <code>imageView</code> 之间添加了一段 autolayout 的约束</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (offset, imageView) <span class="keyword">in</span> imageViews.enumerated() &#123;</div><div class="line">	<span class="keyword">if</span> offset == <span class="number">0</span> &#123;</div><div class="line">		imageView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor).isActive = <span class="literal">true</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">let</span> imageToAnchor = imageView[offset - <span class="number">1</span>]</div><div class="line">		imageView.leadingAnchor.constraint(equalTo: imageToAnchor.trailingAnchor).isActive = <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段示例代码也有同样的问题，我们想要成对的元素，但使用 <code>enumerated()</code> 去获取索引以便后续操作的时候，我们就需要手动去处理索引，这并没有必要。<code>zip</code> 在这种情况下也适用。</p>
<p>首先，处理容器和第一个元素的约束：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">imageViews.first?.leadingAnchor.constraint(equalTo: containerView.leadingAnchor).isActive = <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>接着，我们来把元素拼成一对：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">left</span>, <span class="keyword">right</span>) <span class="keyword">in</span> <span class="built_in">zip</span>(imageViews, imageViews.<span class="built_in">dropFirst</span>()) &#123;</div><div class="line">	<span class="keyword">left</span>.trailingAnchor.constraint(equalTo: <span class="keyword">right</span>.leadingAnchor).isActive = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>搞定，没有索引值，任何 Sequence 类型都适用，而且更加简洁。</p>
<p>（你也可以把这个拼对的操作封装进 <a href="https://gist.github.com/khanlou/f27b34f28b21b4834a758913e06a5f3b" target="_blank" rel="external">extension</a> 里，我会考虑命名为 <code>.eachPair()</code> ）</p>
<p>这里介绍一下 <code>enumerated()</code> 的使用姿势。因为你获取到的并非是索引值，而是一个整型，所以当你需要一个数字去对应到每一个元素的时候，就很适合使用 <code>enumerated()</code>。例如，你需要在垂直方向等距摆放多个 view，每一个 view 都需要一个 y，等于某个高度乘以 offset，<code>enumerated()</code> 就很适合。下面是一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (offset, view) <span class="keyword">in</span> views.enumerated() &#123;</div><div class="line">	view.frame.origin.y = offset * view.frame.height</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为这里的 offset 是作为一个数字去使用，<code>enumerated()</code>就可以正常运作。</p>
<p>使用的规则很简单：如果你是想用 <code>enumerated()</code> 去获取索引，那也许会有更好的方式去解决你的问题，如果你是想把它作为一个数字去使用，那就很适合👍。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：KHANLOU，&lt;a href=&quot;http://khanlou.com/2017/03/you-probably-don&amp;#39;t-want-enumerated/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-03-28&lt;br&gt;译者：&lt;a href=&quot;https://kemchenj.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;四娘&lt;/a&gt;；校对：&lt;a href=&quot;http://weibo.com/277195544&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cwift&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 标准库里最容易被滥用的就是 Sequence 的 &lt;code&gt;enumerated()&lt;/code&gt; 函数。这个函数会返回一个新的序列，包含了初始序列里的所有元素，以及与元素相对应的编号。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;enumerated()&lt;/code&gt; 很容易被误解。因为它给每一个元素都提供了一个编号，对于很多问题来说这是一个很简便的方案。然而，这些问题大多数都可以被另一种方式更好的解决，让我们来看一下其中的一些例子吧，要注意理解它们有什么问题，然后如何使用更好的抽象去解决它们。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Promise 的几种通用模式</title>
    <link href="https://swift.gg/2017/05/04/common-patterns-with-promises/"/>
    <id>https://swift.gg/2017/05/04/common-patterns-with-promises/</id>
    <published>2017-05-03T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Soroush Khanlou，<a href="http://khanlou.com/2016/08/common-patterns-with-promises/" target="_blank" rel="external">原文链接</a>，原文日期：2016/8/8<br>译者：<a href="http://weibo.com/277195544" target="_blank" rel="external">Cwift</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>译者注：英文原文发布时间较早，故原文代码中的 Swift 版本较旧，但是作者已将 GitHub 上的 <a href="https://github.com/khanlou/Promise" target="_blank" rel="external">Promise 示例代码</a>更新到了最新 Swift 版本，所以译者在翻译本文时，将文章里的代码按照 GitHub 上的示例代码进行了替换，更新成了最新版本的 Swift 代码。</p>
</blockquote>
<p>上周，我写了一篇<a href="http://swift.gg/2017/03/27/promises-in-swift/">介绍 Promise 的文章</a>，Promise 是处理异步操作的高阶模块。只需要使用 <code>fulfill()</code>、<code>reject()</code> 和 <code>then()</code> 等函数，就可以简单自由地构建大量的功能。本文会展示我在 Promise 方面的一些探索。</p>
<a id="more"></a>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p><code>Promise.all</code> 是其中的典型，它保存所有异步回调的值。这个静态函数的作用是等待所有的 Promise 执行 fulfill（履行） ，一旦全部执行完毕，<code>Promise.all</code> 会使用所有履行后的值组成的数组对自己执行 fulfill。例如，你可能想在代码中对数组中的每个元素打点以捕获某个 API 的完成状态。使用 <code>map</code> 和 <code>Promise.all</code> 很容易实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> userPromises = users.<span class="built_in">map</span>(&#123; user <span class="keyword">in</span></div><div class="line">	<span class="type">APIClient</span>.followUser(user)</div><div class="line">&#125;)</div><div class="line"><span class="type">Promise</span>.all(userPromises).then(&#123;</div><div class="line">	<span class="comment">//所有的用户都已经执行了 follow！</span></div><div class="line">&#125;).<span class="keyword">catch</span>(&#123; error <span class="keyword">in</span></div><div class="line">	<span class="comment">//其中一个 API 失败了。</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>要使用 <code>Promise.all</code>，需要首先创建一个新的 Promise，它代表所有 Promise 的组合状态，如果参数中的数组为空，可以立即执行 fulfill。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">all</span>&lt;T&gt;<span class="params">(<span class="number">_</span> promises: [Promise&lt;T&gt;])</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">T</span>]&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Promise</span>&lt;[<span class="type">T</span>]&gt;(work: &#123; fulfill, reject <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> !promises.isEmpty <span class="keyword">else</span> &#123; fulfill([]); <span class="keyword">return</span> &#125;</div><div class="line">			</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个 Promise 内部，遍历每个子 Promise，并分别为它们添加成功和失败的处理流程。一旦有子 Promise 执行失败了，就可以拒绝高阶的 Promise。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> promise <span class="keyword">in</span> promises &#123;</div><div class="line">    promise.then(&#123; value <span class="keyword">in</span></div><div class="line"></div><div class="line">    &#125;).<span class="keyword">catch</span>(&#123; error <span class="keyword">in</span></div><div class="line">        reject(error)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有当所有的 Promise 都执行成功，才可以 <code>fulfill</code> 高阶的 Promise。检查一下以确保没有一个 Promise 被拒绝或者挂起，使用一点点 <code>flatMap</code> 的魔法，就可以对 Promise 的组合执行 fulfill 操作了。完整的方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">all</span>&lt;T&gt;<span class="params">(<span class="number">_</span> promises: [Promise&lt;T&gt;])</span></span> -&gt; <span class="type">Promise</span>&lt;[<span class="type">T</span>]&gt; &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Promise</span>&lt;[<span class="type">T</span>]&gt;(work: &#123; fulfill, reject <span class="keyword">in</span></div><div class="line">            <span class="keyword">guard</span> !promises.isEmpty <span class="keyword">else</span> &#123; fulfill([]); <span class="keyword">return</span> &#125;</div><div class="line">            <span class="keyword">for</span> promise <span class="keyword">in</span> promises &#123;</div><div class="line">                promise.then(&#123; value <span class="keyword">in</span></div><div class="line">                    <span class="keyword">if</span> !promises.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.isRejected || $<span class="number">0</span>.isPending &#125;) &#123;</div><div class="line">                        fulfill(promises.flatMap(&#123; $<span class="number">0</span>.value &#125;))</div><div class="line">                    &#125;</div><div class="line">                &#125;).<span class="keyword">catch</span>(&#123; error <span class="keyword">in</span></div><div class="line">                    reject(error)</div><div class="line">                &#125;)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>请注意，Promise 只能履行或者拒绝一次。如果第二次调用 <code>fulfill</code> 或者 <code>reject</code>，不会对 Promise 的状态造成任何影响。</p>
<p>因为 Promise 是状态机，它保存了与完成度有关的重要状态。它是一种不同于 <code>NSOperation</code> 的方法。虽然 <code>NSOperation</code> 拥有一个完成回调以及操作的状态，但它不能保存得到的值，你需要自己去管理。</p>
<p><code>NSOperation</code> 还持有线程模型以及优先级顺序相关的数据，而 Promise 对代码 <em>如何</em> 完成不做任何保证，只设置 <em>完成后</em>  需要执行的代码。Promise 类的定义足以证明。它唯一的实例变量是 <code>state</code>，状态包括挂起、履行或者拒绝（以及对应的数据），此外还有一个回调数组。（它还包含了一个隔离队列，但那不是真正的状态。）</p>
<h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p>有一种很有用的 Promise 可以延迟执行自己的操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">delay</span><span class="params">(<span class="number">_</span> delay: TimeInterval)</span></span> -&gt; <span class="type">Promise</span>&lt;()&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Promise</span>&lt;()&gt;(work: &#123; fulfill, reject <span class="keyword">in</span></div><div class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay, execute: &#123;</div><div class="line">            fulfill(())</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在方法内部，可以使用 <code>usleep</code> 或者其他方法来实现延迟，不过 <code>asyncAfter</code> 方法足够简单。当构建其他有趣的 Promise 时，这个延迟 Promise 会很有用。</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>接下来，使用 <code>delay</code> 来构建 <code>timeout</code>。该 Promise 如果超过一定时间就会被拒绝。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">timeout</span>&lt;T&gt;<span class="params">(<span class="number">_</span> timeout: TimeInterval)</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;(work: &#123; fulfill, reject <span class="keyword">in</span></div><div class="line">        delay(timeout).then(&#123; <span class="number">_</span> <span class="keyword">in</span></div><div class="line">            reject(<span class="type">NSError</span>(domain: <span class="string">"com.khanlou.Promise"</span>, code: -<span class="number">1111</span>, userInfo: [ <span class="type">NSLocalizedDescriptionKey</span>: <span class="string">"Timed out"</span> ]))</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 Promise 自身没有太多用处，但它可以帮助我们构建一些其他功能的 Promise。</p>
<h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><p><code>Promise.race</code> 是 <code>Promise.all</code> 的小伙伴，它不需要等待所有的子 Promise 完成，它只履行或者拒绝第一个完成的 Promise。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">race</span>&lt;T&gt;<span class="params">(<span class="number">_</span> promises: [Promise&lt;T&gt;])</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;(work: &#123; fulfill, reject <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> !promises.isEmpty <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>() &#125;</div><div class="line">        <span class="keyword">for</span> promise <span class="keyword">in</span> promises &#123;</div><div class="line">            promise.then(fulfill, reject)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 Promise 只能被执行或拒绝一次，所以当移除了 <code>.pending</code> 的状态后，在外部对 Promise 调用 <code>fulfill</code> 或者 <code>reject</code> 不会产生任何影响。</p>
<p>有了这个函数，使用 <code>timeout</code> 和 <code>Promise.race</code> 可以创建一个新的 Promise，针对成功、失败或者超过了规定时间三种情况。把它定义在 <code>Promise</code> 的扩展中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">addTimeout</span><span class="params">(<span class="number">_</span> timeout: TimeInterval)</span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Value</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Promise</span>.race(<span class="type">Array</span>([<span class="keyword">self</span>, <span class="type">Promise</span>&lt;<span class="type">Value</span>&gt;.timeout(timeout)]))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以在正常的 Promise 链中使用它，像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">APIClient</span></div><div class="line">    .getUsers()</div><div class="line">    .addTimeout(<span class="number">0.5</span>)</div><div class="line">    .then(&#123;</div><div class="line">    	<span class="comment">//在 0.5 秒内获取了用户数据</span></div><div class="line">    &#125;)</div><div class="line">    .<span class="keyword">catch</span>(&#123; error <span class="keyword">in</span></div><div class="line">    	<span class="comment">//也许是超时引发的错误，也许是网络错误</span></div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>这是我喜欢 Promise 的原因之一，它们的可组合性使得我们可以轻松地创建各种行为。通常需要保证 Promise 在 <em>某个时刻</em> 被履行或者拒绝，但是 timeout 函数允许我们用常规的方式来修正这种行为。</p>
<h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p><code>recover</code> 是另一个有用的函数。它可以捕获一个错误，然后轻松地恢复状态，同时不会弄乱其余的 Promise 链。<br>我们很清楚这个函数的形式：它应该接受一个函数，该函数中接受错误并返回新的 Promise。recover 方法也应该返回一个 Promise 以便继续链接 Promise 链。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Promise</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">(<span class="number">_</span> recovery: @escaping <span class="params">(Error)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="type">Promise</span>&lt;<span class="type">Value</span>&gt; &#123;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在方法体中，需要返回一个新的 Promise，如果当前的 Promise（<code>self</code>）执行成功，需要把成功状态转移给新的 Promise。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">(<span class="number">_</span> recovery: @escaping <span class="params">(Error)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="type">Promise</span>&lt;<span class="type">Value</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Promise</span>(work: &#123; fulfill, reject <span class="keyword">in</span></div><div class="line">        <span class="keyword">self</span>.then(fulfill).<span class="keyword">catch</span>(&#123; error <span class="keyword">in</span></div><div class="line">        </div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，<code>catch</code> 是另一回事了。如果 Promise 执行失败，应该调用提供的 <code>recovery</code> 函数。该函数会返回一个新的 Promise。无论 recovery 中的 Promise 执行成功与否，都要把结果返回给新的 Promise。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="comment">//...</span></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">try</span> recovery(error).then(fulfill, reject)</div><div class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">let</span> error) &#123;</div><div class="line">    reject(error)</div><div class="line">&#125;</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure>
<p>完整的方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">(<span class="number">_</span> recovery: @escaping <span class="params">(Error)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="type">Promise</span>&lt;<span class="type">Value</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Promise</span>(work: &#123; fulfill, reject <span class="keyword">in</span></div><div class="line">        <span class="keyword">self</span>.then(fulfill).<span class="keyword">catch</span>(&#123; error <span class="keyword">in</span></div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">try</span> recovery(error).then(fulfill, reject)</div><div class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">let</span> error) &#123;</div><div class="line">                reject(error)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了这个新的函数就可以从错误中恢复。例如，如果网络没有加载我们期望的数据，可以从缓存中加载数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">APIClient</span>.getUsers()</div><div class="line">    .recover(&#123; error <span class="keyword">in</span> </div><div class="line">        <span class="keyword">return</span> cache.getUsers()</div><div class="line">    &#125;).then(&#123; user <span class="keyword">in</span></div><div class="line">    	<span class="comment">//更新 UI</span></div><div class="line">    &#125;).<span class="keyword">catch</span>(&#123; error <span class="keyword">in</span></div><div class="line">    	<span class="comment">//错误处理</span></div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h3 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h3><p>重试是我们可以添加的另一个功能。若要重试，需要指定重试的次数以及一个能够创建 Promise 的函数，该 Promise 包含了重试要执行的操作（所以这个 Promise 会被重复创建很多次）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">retry</span>&lt;T&gt;<span class="params">(<span class="built_in">count</span>: Int, delay: TimeInterval, generate: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt; &#123;</div><div class="line">    <span class="keyword">if</span> <span class="built_in">count</span> &lt;= <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> generate()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;(work: &#123; fulfill, reject <span class="keyword">in</span></div><div class="line">        generate().recover(&#123; error <span class="keyword">in</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.delay(delay).then(&#123;</div><div class="line">                <span class="keyword">return</span> retry(<span class="built_in">count</span>: <span class="built_in">count</span>-<span class="number">1</span>, delay: delay, generate: generate)</div><div class="line">            &#125;)</div><div class="line">        &#125;).then(fulfill).<span class="keyword">catch</span>(reject)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果数量不足 1，直接生成 Promise 并返回。</li>
<li>否则，创建一个包含了需要重试的 Promise 的新的 Promise，如果失败了，在 <code>delay</code> 时间之后恢复到之前的状态并重试，不过此时的重试次数减为 <code>count - 1</code>。</li>
</ul>
<p>基于之前编写的 <code>delay</code> 和 <code>recover</code> 函数构建了重试的函数。</p>
<p>在上面的这些例子中，轻量且可组合的部分组合在一起，就得到了简单优雅的解决方案。所有的这些行为都是建立在 Promise 核心代码所提供的简单的 <code>.then</code> 和 <code>catch</code> 函数上的。通过格式化完成闭包的样式，可以解决诸如超时、恢复、重试以及其他可以通过简单可重用的方式解决的问题。这些例子仍然需要一些测试和验证，我会在未来一段时间内慢慢地添加到 <a href="https://github.com/khanlou/Promise" target="_blank" rel="external">GitHub 仓库</a> 中。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2016/08/common-patterns-with-promises/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016/8/8&lt;br&gt;译者：&lt;a href=&quot;http://weibo.com/277195544&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cwift&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：英文原文发布时间较早，故原文代码中的 Swift 版本较旧，但是作者已将 GitHub 上的 &lt;a href=&quot;https://github.com/khanlou/Promise&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Promise 示例代码&lt;/a&gt;更新到了最新 Swift 版本，所以译者在翻译本文时，将文章里的代码按照 GitHub 上的示例代码进行了替换，更新成了最新版本的 Swift 代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上周，我写了一篇&lt;a href=&quot;http://swift.gg/2017/03/27/promises-in-swift/&quot;&gt;介绍 Promise 的文章&lt;/a&gt;，Promise 是处理异步操作的高阶模块。只需要使用 &lt;code&gt;fulfill()&lt;/code&gt;、&lt;code&gt;reject()&lt;/code&gt; 和 &lt;code&gt;then()&lt;/code&gt; 等函数，就可以简单自由地构建大量的功能。本文会展示我在 Promise 方面的一些探索。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Feature 框架设计</title>
    <link href="https://swift.gg/2017/05/03/architecting-for-features/"/>
    <id>https://swift.gg/2017/05/03/architecting-for-features/</id>
    <published>2017-05-02T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="https://www.natashatherobot.com/architecting-for-features/" target="_blank" rel="external">原文链接</a>，原文日期：2017-03-12<br>译者：<a href="http://www.saitjr.com" target="_blank" rel="external">saitjr</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>几个月前，我在 <a href="http://iosconf.sg/" target="_blank" rel="external">iOS Conf SG</a> 上做了名为 <strong>创建 Feature，而不是 App</strong> 的分享（你可以在<a href="https://www.youtube.com/watch?v=lJlyR8chDwo" target="_blank" rel="external">这里</a>查看完整分享）。在 WWDC 2016 之后，我清晰地认识到今后的发展不是一个大一统的 App，而应该拥有各种小功能的 Feature。想想 Apple Watch，Widget，可交互的 Notifications，App Search，iMessage 贴纸，地图这些数不胜数的应用。</p>
<a id="more"></a>
<p><img src="https://www.natashatherobot.com/wp-content/uploads/Screen-Shot-2017-03-12-at-5.15.38-PM-1024x721.png" alt=""></p>
<p>如果处理得当，这里的每个 extension 都会成为你应用中的 feature。比如，Widget 中并不需要包含你应用的全部功能，仅提供最实用的那部分，能让用户快速查看即可（就像「天气」应用一样）。</p>
<p>继续深入，我们会发现，如果 extension 的种类足够多，那用户就可以从 app 中解脱了。他们完全可以在不打开 app 的情况下，直接查看相关信息（比如之前提到的「天气」）。虽然还是在使用你的服务，但不再是传统的「点击打开 app」了。</p>
<p>这完全重新定义了 app 的含义。所以，现在 app 不再是真正意义上的应用了，它变成了在合适时间，给用户提供相关信息的东西。这种认知转变，成功规避掉了那些需要依赖于「打开」的 app（比如，内置广告），而且还提供了许多全新的交互方式，树立更为强大的品牌意识。现在，app 能真的被称为「无处不在」了！不再是那个角落中期待被点击的图标了。</p>
<p>这也是为什么在 <a href="https://www.tryswift.co/tokyo/en" target="_blank" rel="external">try! Swift Tokyo</a> 大会上，我专注于为 <a href="https://github.com/tryswift/trySwiftAppFinal" target="_blank" rel="external">try! Swift app</a> 添加 feature 而不是开发新功能点的原因。</p>
<p>其中的关键是将数据层与 iOS app 分离，包括 Realm。Watch app，Apple TV app（说不定之后会开发），iOS app，iOS extension（如 Widget 和可交互的 Notification） 均会共用数据层。</p>
<p>不过，分离要比想象中复杂。我推荐先从 Basem Emra 的「<a href="http://basememara.com/creating-cross-platform-swift-frameworks-ios-watchos-tvos-via-carthage-cocoapods/" target="_blank" rel="external">用 Carthage 与 CocoaPods 打造跨 iOS，watchOS，tvOS 平台的 Swift 框架</a>」入门。</p>
<p>我自己还没独立做过 CocoaPods，更别说还是要依赖 Realm 的，所以我花了很多时间收集梳理。感谢带我入门的 <a href="https://twitter.com/aaalveee" target="_blank" rel="external">@aaalveee</a>，让 pod 能在 extension 之间工作的 <a href="https://twitter.com/k_katsumi" target="_blank" rel="external">@k_katsumi</a>，帮我集成 <a href="https://realm.io/products/realm-mobile-platform/" target="_blank" rel="external">Realm Mobile Platform</a> 的 <a href="https://twitter.com/TimOliverAU" target="_blank" rel="external">@TimOliverAU</a>（当然，还有些后续处理）。</p>
<p>虽然过程很困难（到现在都还有些工作没做），但是能有这样的结果我已经非常开心了。你可以在 <a href="https://github.com/tryswift/trySwiftData" target="_blank" rel="external">GitHub</a> 上看到 <strong>trySwiftData</strong> 这个框架。框架中最让我满意的地方，是格式化数据的这部分代码，比如，每个话题的标题为演讲者 + 描述，以前处理这个的代码就重复散落在 iOS 和 watchOS 上。我们甚至可以使用同一个 pod 添加有时间限制的 Widget。</p>
<p>期待下一次 try! Swift in NYC 能支持更多的 feature，包括可交互的 Notifications 和 App Search 🚀。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Natasha The Robot，&lt;a href=&quot;https://www.natashatherobot.com/architecting-for-features/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-03-12&lt;br&gt;译者：&lt;a href=&quot;http://www.saitjr.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;saitjr&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;几个月前，我在 &lt;a href=&quot;http://iosconf.sg/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS Conf SG&lt;/a&gt; 上做了名为 &lt;strong&gt;创建 Feature，而不是 App&lt;/strong&gt; 的分享（你可以在&lt;a href=&quot;https://www.youtube.com/watch?v=lJlyR8chDwo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;查看完整分享）。在 WWDC 2016 之后，我清晰地认识到今后的发展不是一个大一统的 App，而应该拥有各种小功能的 Feature。想想 Apple Watch，Widget，可交互的 Notifications，App Search，iMessage 贴纸，地图这些数不胜数的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="Natasha The Robot" scheme="https://swift.gg/categories/Natasha-The-Robot/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用 MapKit 绘制路线</title>
    <link href="https://swift.gg/2017/05/02/draw-route-mapkit-tutorial/"/>
    <id>https://swift.gg/2017/05/02/draw-route-mapkit-tutorial/</id>
    <published>2017-05-01T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/draw-route-mapkit-tutorial" target="_blank" rel="external">原文链接</a>，原文日期：2016-02-29<br>译者：<a href="undefined">TonyHan</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>在本节教程中，将学习如何在纽约市的两个地标之间绘制一条线路。这条线路绘制在 Map 图层的上面，使用折线绘制。本教程使用 Xcode 7.2 和 iOS 9.2。</p>
<a id="more"></a>
<blockquote>
<p>译者注：由于目前主流版本为 Xcode 8（iOS 10），因此图示可能会有所不同，不过不影响对于文章的理解。基于此版本的项目可以在<a href="https://github.com/lettleprince/IOS9DrawRouteMapKitTutorial" target="_blank" rel="external">这里</a>下载到。</p>
</blockquote>
<p>打开 Xcode 创建 Single View Application。使用 <strong>IOS9DrawRouteMapKitTutorial</strong> 作为项目名，然后根据实际情况填写 Organization Name 和 Organization Identifier。选择 Swift 作为编程语言，Devices 选择只适配 iPhone。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56cc46ad4d088ea899578483/1456228023320/?format=1500w" alt="image1"></p>
<p>在项目导航栏中，选择 Prokect Settings 图标。点击 Capabilities 栏并启用 Map framework。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56cc4fc61bbee05e52d974ec/1456230356683/?format=2500w" alt="image2"></p>
<p>打开 <strong>Storyboard</strong>，选择  View Controller，打开 Editor 菜单并选择 Embed in -&gt; Navigation Controller。双击 View Controller 的 Navigation Bar 并输入 “Route Tutorial”。接下来，从视图对象库中拖拽 Map Kit View 到主视图中。重新设置尺寸，让其填充整个屏幕。现在 Storyboard 如下图所示：</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56cc4be70442621c56ee71f0/1456229367115/?format=2500w" alt="image3"></p>
<p>打开 Assistant Editor，确保 <strong>ViewController.swift</strong> 文件可见。按住 control 键将 Map Kit View 拖动到 ViewController 类中，创建如下图所示的 Outlet：</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56d3303d7da24f7ba20e325d/1456681028709/?format=750w" alt="image4"></p>
<p>选择 Map Kit View，并点击在 Interface Builder 右下角的 Pin 图标（左边起第三个）。四边都设置约束，并反选 “Constrain to margins”。点击 “Add 4 Constraints” 按钮，于是 Map Kit View 在各方向上边缘都与主视图对齐。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56cc4adb59827e2cba96ca38/1456229089944/?format=750w" alt="image5"></p>
<p>打开 Assistant Editor，确保 ViewController.swift 文件可见。选择 Map Kit View。按住 control 键将 Map Kit View 拖动到 ViewController 类中，创建的 Outlet。</p>
<blockquote>
<p>译者注：这一段内容与上面的创建 Outlet 内容有重复，上面那一段及后面的图片应该在此处。因原文如此，故在此未改。</p>
</blockquote>
<p>打开 <strong>ViewController.swift</strong>，添加 MapKit framework。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> MapKit</div></pre></td></tr></table></figure>
<p>View Controller 需要遵循 MKMapViewDelegate 协议，才能实现路线的绘制。将类声明的代码修改为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">MKMapViewDelegate</span> </span>&#123;</div></pre></td></tr></table></figure>
<p>然后，将 <strong>viewDidLoad</strong> 方法修改为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    </div><div class="line">    <span class="comment">// 1.</span></div><div class="line">    mapView.delegate = <span class="keyword">self</span></div><div class="line">    </div><div class="line">    <span class="comment">// 2.</span></div><div class="line">    <span class="keyword">let</span> sourceLocation = <span class="type">CLLocationCoordinate2D</span>(latitude: <span class="number">40.759011</span>, longitude: -<span class="number">73.984472</span>)</div><div class="line">    <span class="keyword">let</span> destinationLocation = <span class="type">CLLocationCoordinate2D</span>(latitude: <span class="number">40.748441</span>, longitude: -<span class="number">73.985564</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 3.</span></div><div class="line">    <span class="keyword">let</span> sourcePlacemark = <span class="type">MKPlacemark</span>(coordinate: sourceLocation, addressDictionary: <span class="literal">nil</span>)</div><div class="line">    <span class="keyword">let</span> destinationPlacemark = <span class="type">MKPlacemark</span>(coordinate: destinationLocation, addressDictionary: <span class="literal">nil</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// 4.</span></div><div class="line">    <span class="keyword">let</span> sourceMapItem = <span class="type">MKMapItem</span>(placemark: sourcePlacemark)</div><div class="line">    <span class="keyword">let</span> destinationMapItem = <span class="type">MKMapItem</span>(placemark: destinationPlacemark)</div><div class="line">    </div><div class="line">    <span class="comment">// 5.</span></div><div class="line">    <span class="keyword">let</span> sourceAnnotation = <span class="type">MKPointAnnotation</span>()</div><div class="line">    sourceAnnotation.title = <span class="string">"Times Square"</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> location = sourcePlacemark.location &#123;</div><div class="line">        sourceAnnotation.coordinate = location.coordinate</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">let</span> destinationAnnotation = <span class="type">MKPointAnnotation</span>()</div><div class="line">    destinationAnnotation.title = <span class="string">"Empire State Building"</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> location = destinationPlacemark.location &#123;</div><div class="line">        destinationAnnotation.coordinate = location.coordinate</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 6.</span></div><div class="line">    <span class="keyword">self</span>.mapView.showAnnotations([sourceAnnotation,destinationAnnotation], animated: <span class="literal">true</span> )</div><div class="line">    </div><div class="line">    <span class="comment">// 7.</span></div><div class="line">    <span class="keyword">let</span> directionRequest = <span class="type">MKDirectionsRequest</span>()</div><div class="line">    directionRequest.source = sourceMapItem</div><div class="line">    directionRequest.destination = destinationMapItem</div><div class="line">    directionRequest.transportType = .<span class="type">Automobile</span></div><div class="line">    </div><div class="line">    <span class="comment">// 计算方向</span></div><div class="line">    <span class="keyword">let</span> directions = <span class="type">MKDirections</span>(request: directionRequest)</div><div class="line">    </div><div class="line">    <span class="comment">// 8.</span></div><div class="line">    directions.calculateDirectionsWithCompletionHandler &#123;</div><div class="line">        (response, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">        </div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(error)</span>"</span>)</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> route = response.routes[<span class="number">0</span>]</div><div class="line">        <span class="keyword">self</span>.mapView.addOverlay((route.polyline), level: <span class="type">MKOverlayLevel</span>.<span class="type">AboveRoads</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> rect = route.polyline.boundingMapRect</div><div class="line">        <span class="keyword">self</span>.mapView.setRegion(<span class="type">MKCoordinateRegionForMapRect</span>(rect), animated: <span class="literal">true</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>ViewController 作为 MKMapViewDelegate 协议的代理</li>
<li>设置地点的经纬度</li>
<li>创建包含地点坐标的地标对象</li>
<li>使用 MKMapitems 标记路径。该类封装了有关地图上特定点的信息</li>
<li>添加显示地标名字的大头针</li>
<li>在地图上显示大头针</li>
<li>使用 MKDirectionsRequest 类计算路径</li>
<li>使用折线在地图图层上面绘制出路径。该区域设置为两个位置都可见</li>
</ol>
<p>接下来，实现代理方法 <code>mapView(rendererForrOverlay:)</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapView</span><span class="params">(mapView: MKMapView, rendererForOverlay overlay: MKOverlay)</span></span> -&gt; <span class="type">MKOverlayRenderer</span> &#123;</div><div class="line">    <span class="keyword">let</span> renderer = <span class="type">MKPolylineRenderer</span>(overlay: overlay)</div><div class="line">    renderer.strokeColor = <span class="type">UIColor</span>.redColor()</div><div class="line">    renderer.lineWidth = <span class="number">4.0</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> renderer</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法返回用于返回绘制在地图上的渲染对象。使用宽度为 4 的红色线条。</p>
<p><strong>运行</strong> 项目，展示出两个地点及其之间的路线。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/56d3300c59827e6585c69352/1456680990852/?format=1500w" alt="image6"></p>
<p>可以从 <a href="">Github</a> 上 ioscreator 的仓库中下载 <strong>IOS9DrawRouteMapKitTutorial</strong> 项目的源代码作为参考。</p>
<blockquote>
<p>译者注：由于目前主流版本为 Xcode 8（iOS 10），因此图示可能会有所不同，不过不影响对于文章的理解。基于此版本的项目可以在<a href="https://github.com/lettleprince/IOS9DrawRouteMapKitTutorial" target="_blank" rel="external">这里</a>下载到。</p>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/draw-route-mapkit-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-02-29&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;TonyHan&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在本节教程中，将学习如何在纽约市的两个地标之间绘制一条线路。这条线路绘制在 Map 图层的上面，使用折线绘制。本教程使用 Xcode 7.2 和 iOS 9.2。&lt;/p&gt;
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>

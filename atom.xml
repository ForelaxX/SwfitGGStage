<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2017-09-05T02:02:46.000Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 中的并发编程(第一部分：现状）</title>
    <link href="https://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/"/>
    <id>https://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/</id>
    <published>2017-09-03T16:00:00.000Z</published>
    <updated>2017-09-05T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Umberto Raimondi，<a href="https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/" target="_blank" rel="external">原文链接</a>，原文日期：2017-05-07<br>译者：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>当前最新版本的 Swift 语言（译者注：当前最新稳定版本为 3.1.1）还没有包含任何原生并发特性，但是在其他现代编程语言中是带有这个特性的，比如 Go 和 Rust。<br>如果你想并发地执行任务，这时就需要处理与结果相关的竞态条件，目前唯一的选择就是使用第三方库，比如 libDispatch，或者 Foundation 和其他 OS 中提供的同步原语。<br>在这一系列文章的第一部分，看看 Swift 3 给出的处理方案，覆盖以下一些内容：Foundation 中的锁，线程和计时器提供语言层面的保证，最近不断增强的 GCD(Grand Central Dispatch) 和操作队列（Operation Queues）。</p>
<p>同时也会讨论到基础的并发原理和一些通用的并发模式。</p>
<a id="more"></a>
<p>原文链接：<a href="https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/" target="_blank" rel="external">All about Concurrency in Swift - Part 1: The Present</a></p>
<p><img src="/img/articles/all-about-concurrency-in-swift-1-the-present/concurr.png1504576909.77" alt=""></p>
<p>虽然在那些可以运行 Swift 的平台上，都可以使用 pthread 库来处理并发（译者注：pthread 库是跨平台的），但是在这里，不会讨论 pthread 库相关的函数和原语，对于这些底层一些库函数来说，有更高阶的替代者。NSTimer 类也不会在这里讨论，请查阅<a href="https://www.uraimo.com/swiftbites/nstimer-in-swift-3/" target="_blank" rel="external">这篇文章</a>，告诉你如何在 Swift 3中使用它。</p>
<p>正如已经被多次提到的一样，在 Swift 4.0 发布后的某个版本（应该不需要等到 Swift 5），Swift 语言将会定义一个牛逼的内存模型，包含支持原生并发特性，用于处理并发，和并行一样，不需要引入外部库，使用 Swift 的方式来处理并发。</p>
<p>在下一篇系列文章中，将会讨论其他语言中使用的一些替代方式和范式实现并发，并且探讨如何在 Swift 中实现它们，然后分析一些已经存在的开源实现，<br>并且使用了当前发布版本的 Swift  编写 Actors 模式，CSP 通道（Go 语言），STM（Software Transactional Memory）等并发实现。<br>在当前的 Swift 正式版本中允许使用行动者范式，Go 语言的 CSP 频道，软件事务内存。</p>
<p>在第二篇文章中，将会彻底预测下，主要预测方式，是把这些涉及的对象的情况做个介绍，这样可以让你可以身临其境，明白将会在未来的 Swift 版本如何定义处理并发。</p>
<blockquote>
<p>此文章和本博客相关文章代码可以从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="external">GitHub</a>和 <a href="https://www.uraimo.com/archives/2017-05-07-ConcurrencyInSwift.playground.zip" target="_blank" rel="external">Zipped</a>上下载。</p>
</blockquote>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#multithreading_and_concurrency_primer">多线程和并发启蒙</a></li>
<li><a href="#language_guarantees">语言支持</a></li>
<li><a href="#threads">线程类</a></li>
<li><p><a href="#synchronization_primitives">同步原语</a></p>
<ul>
<li><a href="#nslock">NSLock</a></li>
<li><a href="#nsrecursivelock">NSRecursiveLock</a></li>
<li><a href="#nsconditionlock">NSConditionLock</a></li>
<li><a href="#nscondition">NSCondition</a></li>
<li><a href="#nsdistributedlock">NSDistributedLock</a></li>
<li><a href="#osatomic_where_art_thou">OSAtomic 还能用吗？</a></li>
<li><a href="#on_synchronized_blocks">同步代码块</a></li>
</ul>
</li>
<li><p><a href="#grand_central_dispatch">GCD：Grand Central Dispatch</a></p>
<ul>
<li><a href="#dispatch_queues">调度队列</a></li>
<li><a href="#using_quenes">使用队列</a></li>
<li><a href="#barriers">屏障</a></li>
<li><a href="#singletons_and_dispatch_once">单例和 Dispatch_once</a></li>
<li><a href="#dispatch_groups">调度组</a></li>
<li><a href="#dispatch_work_items">调度工作项</a></li>
<li><a href="#dispatch_semaphores">调度信号量</a></li>
<li><a href="#dispatch_assertions">调度断言</a></li>
<li><a href="#dispatch_sources">调度资源</a></li>
</ul>
</li>
<li><p><a href="#operations_and_operationqueues">操作和操作队列</a></p>
</li>
<li><a href="#closing_thoughts">后记</a></li>
</ul>
<p><a name="multithreading_and_concurrency_primer"></a></p>
<h2 id="多线程和并发启蒙"><a href="#多线程和并发启蒙" class="headerlink" title="多线程和并发启蒙"></a>多线程和并发启蒙</h2><p>现如今，无论大家编写何种类型的应用，迟早大家会发现一个事实，应用都会运行在一个多线程的执行环境下面。</p>
<p>使用多处理器或者拥有多个硬件执行核心处理器的计算平台已经出现了几个时代了，并且像 <em>线程</em> 和 <em>进程</em> 等概念出现的甚至更早。</p>
<p>操作系统通过使用各种程序来利用硬件的能力，而应用或每一个现代的框架都在实现一些大家熟知的设计模式，用到了多线程来增强自身的灵活性和性能。</p>
<p>在我们开始深入讨论如何使用 Swift 处理多线程之前，先来解释一些需要了解的基本概念，这样才能考虑应该使用调度队列（<code>Dispatch Queues</code>）或者操作队列（<code>Operation Queues</code>）。<br>首先，你可能会问，苹果平台和框架已经使用了线程，为啥还需要在应用中单独介绍它们呢？<br>有少量通用的场景下，让使用多线程变得容易理解：</p>
<p><strong>任务组隔离</strong>：线程可以从执行流程角度模块化应用，不同线程用可预测的方式执行同类的一组任务，隔离应用中其他执行流程，这样对应用当前的状态更加可控。</p>
<p><strong>数据独立并行计算</strong>：多个软件线程，无论是基于硬件线程还是不基于软件线程(见下一个要点)，都通过并行处理同一个任务的多个拷贝，这个任务作用于原始输入数据结构的其中某个子集。</p>
<p><strong>更加清晰的方式等待竞争或I/O</strong>：使用阻塞 I/O 或执行某种类型的阻塞操作时，后台线程会等待这些操作的完成。使用线程，可以增强应用的设计，并且让处理阻塞的调用更加常见。</p>
<p>但是在执行多线程代码时，从一个线程的角度去看代码会不再有效，需要做一些有意义的假设。</p>
<p>理想情况下，每一个执行线程都相互独立，没有共享数据，这样并发编程没想象中复杂，编写的代码将会在一个独立的线程中执行。但在大多数情况下，会使用多个线程操作相同的数据，需要找到一种管控访问这些数据的方式，保证每一个对数据的操作都符合预期，不被其他线程操作造成不可预期行为。</p>
<p>并发编程需要编程语言和操作系统额外的保证，当多线程尝试同时改变变量（更多时候被称作”资源”）的值时候，需要一个显式状态信息来提供作用。</p>
<p>编程语言需要定义一个<em>内存模型</em>，在多线程存在的情况下，定义显式状态一些规则，指定这些基础状态在并发线程中如何运作，定义内存如何进行共享，以及指定那种方式的内存访问是有效的。</p>
<p>正因为如此，开发者对于每种语言中线程行为都有一个基本认知，只需要了解每种语言的编译器是如何在这个线程内存模型下去优化性能。</p>
<p>定义一个内存模型也是语言演化中一个重要的步骤，一个严格的模型将会限制编译器的演化。以前在内存模型的设计有可能会让新的优化搁浅。</p>
<p>定义内存模型的一些考虑点：</p>
<ul>
<li><p>语言表达式是否为<em>原子性</em>，在没有其他线程可以看到的情况下，操作将被整体执行。更有意义的场景是，一个变量是否被原子化操作。</p>
</li>
<li><p>多线程如何处理共享变量，变量被缓存是否是默认的，还有就是这个缓存行为是否受到特定的语言标识符所影响。</p>
</li>
<li><p>并发操作符通常被用作标记和管控共享资源的<em>临界区</em>和区域中的代码，允许有且只有一个线程同时执行指定的代码。</p>
</li>
</ul>
<p>接下来言归正传讨论如何在程序中使用并发。</p>
<p>正确处理并发的方式是，识别程序中的<em>临界区</em>，使用并发原语或者并发相关数据结构，来管控不同线程中的共享数据。</p>
<p>临界区中代码和数据结果的强制访问规则会带来一系列的其它问题，这些问题来源于一个事实，每一个将要执行的线程都期望得到自己想要的结果，都有机会修改共享数据，在某些情况下，这些线程中的一些线程永远不会执行，数据的修改也可能不按预期进行。</p>
<p>并发编程将面临一些额外的挑战，不得不去处理一些共同的问题：</p>
<ul>
<li><p><strong>竞争条件</strong>：当多线程操作同样的数据时，读和写数据同时进行，这一系列执行操作结果在不同的线程操作顺序下，变得不可预测。</p>
</li>
<li><p><strong>资源冲突</strong>：多线程会执行多个任务，需要安全的访问相同的资源时，将会增加额外的时间，这些延迟获取资源的时间，可能会导致不可预期的行为或者使得应用程序处理这些资源的数据结构变得复杂。</p>
</li>
<li><p><strong>死锁</strong>：多线程互相等待需要资源或锁的释放，然后永远阻塞这些线程的执行。</p>
</li>
<li><p><strong>饥饿</strong>：一个线程无法获取资源或者一个特定排序的资源，需要各种条件获取资源或者尝试获取资源永远失败。</p>
</li>
<li><p><strong>优先级反转</strong>：低优先级线程可能不断持有资源，需要这个资源的高优先级线程可能被其他不需要此资源的低优先级线程反转。</p>
</li>
<li><p>不可预期和公平：不能假设在什么时候或者什么顺序下，一个线程能获取到线程资源，延迟时间<a href="https://en.wikipedia.org/wiki/Unbounded_nondeterminism" target="_blank" rel="external">不会被优先级所决定</a>，但是会被冲突的数量所影响。一个线程不可能独立获得资源。但是并发原语用来保证临界区是<em>公平的</em>，或者说，为了<em>公平</em>，所有线程等待访问临界区的顺序都是依据等待顺序而来。</p>
</li>
</ul>
<p><a name="language_guarantees"></a></p>
<h2 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h2><p>虽然当前 Swift 还没有提供原生的并发编程特性，但它仍然提供了属性访问的多线程保证。</p>
<p>举个例子，全局变量就是被原子性的初始化的，不需要担心多线程情况下对同一变量的初始化操作，也不需要担心会看到一个初始化还在进行当中的部分初始化变量。</p>
<p>以上行为在下面实现单例模式的时候会看到。</p>
<p>但是需要重点注意的是，延迟属性初始化没有保证原子性，目前 Swift 语言没有提供注释或者修饰符来修改这种行为。</p>
<p>访问类变量同样没有保证原子性，如果想保证原子性，那么就需要提供额外的锁或者类似的机制来保证。</p>
<p><a name="threads"></a></p>
<h2 id="线程类"><a href="#线程类" class="headerlink" title="线程类"></a>线程类</h2><p><code>Foudation</code> 库提供了一个 <code>Thread</code> 类，内部继承自 <code>pthread</code>，可以用来创建线程和执行闭包。</p>
<p>使用 <code>Thread</code> 类的 <code>detachNewThreadSelector:toTarget:withObject:</code> 方法创建线程，或者自定义一个线程类，重写其中的 <code>main()</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> : <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Thread started, sleep for 2 seconds..."</span>)</div><div class="line">        sleep(<span class="number">2</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Done sleeping, exiting thread"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 iOS 10 和 macOS Sierra 开始，所有平台都可以使用构造器来创建一个新的线程，运行编写的闭包来指定线程执行。这篇文章所有例子仍然使用扩展基本 Thread 类，所以不需要担心是否是正确的操作系统来运行这些代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> t = <span class="type">Thread</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Started!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">t.stackSize = <span class="number">1024</span> * <span class="number">16</span></div><div class="line">t.start()               <span class="comment">//需要 100us 来生成一个线程</span></div></pre></td></tr></table></figure>
<p>一旦线程实例建立，需要手动的启动它。一个可选的步骤是，可以自定义新线程的栈空间大小。</p>
<p>可以调用<code>exit()</code>来终止线程，但这不推荐使用，因为这样不能保证当前任务能清理完成，大多数情况下，需要自己编写停止逻辑，或者使用<code>cancel()</code>方法，在主闭包中使用<code>isCancelled</code>属性来判断线程是否需要在自然结束之前终止当前任务。</p>
<p><a name="synchronization_primitives"></a></p>
<h2 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h2><p>当有不同的线程同时想修改共享数据时，有必要使用某种方式来处理线程之间的同步问题，阻止数据混乱和不可预期的行为。<br>线程间同步基础的处理手段包括锁，信号量和监视器。<br>Foundation 库提供以上几种方式。</p>
<p>你会马上看到，在 Swift 3 中，这些类（是的，它们都是引用类型）并没有<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0086-drop-foundation-ns.md#proposed-solution" target="_blank" rel="external">马上去掉 NS 前缀</a>，但是在未来的 Swift 版本中会去掉。</p>
<p><a name="nslock"></a></p>
<h3 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h3><p><code>NSLock</code> 是 <code>Foundation</code> 提供的最基本的锁类型。</p>
<p>当一个线程尝试对一个对象进行加锁时，可能会发生两件事情，线程会在这个锁没有被其他线程持有时，获得这个锁，或者线程将阻塞，等到锁的拥有者释放锁。从另外个角度讲，锁只能同时被一个线程所持有，这种机制非常适合作用于临界区的监控访问。</p>
<p><code>NSLock</code> 和其它的 <code>Foundation</code> 中锁是不公平的，意味着当一些线程想获取锁时，不会按照它们访问锁的顺序来获取锁。</p>
<p>不能假设一个执行顺序，在一个高度线程冲突的环境中，当有许多线程尝试获取资源是，一些线程有可能会被置为饥饿，永远不能获取它们等待的锁（或者不能及时地获取资源）。</p>
<p>没有竞争的情况下，获取一个锁需要的时间是 100 纳秒，但是当超过一个线程尝试获取锁资源时，耗费的时间将迅速增长。所以从性能的角度来说，锁不是解决资源分配最好的方式。</p>
<p>来看看两个线程的例子，记住获取锁的顺序不是注定的，甚至有可能 t1 连续获得两次锁（但是这种情况比较少见）.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> lock = <span class="type">NSLock</span>()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LThread</span> : <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> id:<span class="type">Int</span> = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(id:<span class="type">Int</span>)&#123;</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</div><div class="line">        <span class="keyword">self</span>.id = id</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        lock.lock()</div><div class="line">        <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" acquired lock."</span>)</div><div class="line">        lock.unlock()</div><div class="line">        <span class="keyword">if</span> lock.<span class="keyword">try</span>() &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" acquired lock again."</span>)</div><div class="line">            lock.unlock()</div><div class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">// If already locked move along.</span></div><div class="line">            <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" couldn't acquire lock."</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" exiting."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> t1 = <span class="type">LThread</span>(id:<span class="number">1</span>)</div><div class="line"><span class="keyword">var</span> t2 = <span class="type">LThread</span>(id:<span class="number">2</span>)</div><div class="line">t1.start()</div><div class="line">t2.start()</div></pre></td></tr></table></figure>
<p>当决定使用锁机制时，需要附加一些警告。迟早会对并发程序进行调试，这种情况下，记得限制对一些需要排序数据结构去使用锁，在代码中尽量不在多个地方直接引用一个锁。</p>
<p>当调试一个并发问题时，检查有少量入口的同步数据结构的状态，要比随时关注锁在代码中的具体位置，并且需要记住在不同函数中锁状态来讲，要愉快的多。需要额外的工作，使得并发代码的结构更加合理。</p>
<p><a name="nsrecursivelock"></a></p>
<h3 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a><code>NSRecursiveLock</code></h3><p>递归锁可以在一个线程已经持有这个锁的情况下，在后面的代码中获取多次，在递归函数和调用多个需要顺序检查同一个锁的函数时，需要用到这种锁。递归锁和基本锁<strong>不能共用</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> rlock = <span class="type">NSRecursiveLock</span>()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RThread</span> : <span class="title">Thread</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        rlock.lock()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Thread acquired lock"</span>)</div><div class="line">        callMe()</div><div class="line">        rlock.unlock()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Exiting main"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">callMe</span><span class="params">()</span></span>&#123;</div><div class="line">        rlock.lock()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Thread acquired lock"</span>)</div><div class="line">        rlock.unlock()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Exiting callMe"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> tr = <span class="type">RThread</span>()</div><div class="line">tr.start()</div></pre></td></tr></table></figure>
<p><a name="nsconditionlock"></a></p>
<h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><p>条件锁提供了附加的子锁，子锁可以独立地被加锁和被解锁，用来支持复杂的加锁步骤（比如：消费者-提供者场景）。</p>
<p>同时可以用一个全局锁（不管什么具体的场景都可以加锁），这种锁的行为和经典的 NSLock 一样。</p>
<p>下面的例子使用一个条件锁来保护共享整型，提供者每次更新整型，消费者都会在终端打印整型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="type">NO_DATA</span> = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> <span class="type">GOT_DATA</span> = <span class="number">2</span></div><div class="line"><span class="keyword">let</span> clock = <span class="type">NSConditionLock</span>(condition: <span class="type">NO_DATA</span>)</div><div class="line"><span class="keyword">var</span> <span class="type">SharedInt</span> = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span> : <span class="title">Thread</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</div><div class="line">            clock.lock(whenCondition: <span class="type">NO_DATA</span>) <span class="comment">//当条件为 NO_DATA 获取该锁</span></div><div class="line">			  <span class="comment">// 如果不想等待消费者，直接调用 clock.lock() 即可</span></div><div class="line">            <span class="type">SharedInt</span> = i</div><div class="line">            clock.unlock(withCondition: <span class="type">GOT_DATA</span>) <span class="comment">//解锁并设置条件为 GOT_DATA</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> : <span class="title">Thread</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</div><div class="line">            clock.lock(whenCondition: <span class="type">GOT_DATA</span>) <span class="comment">// 当条件为 GOT_DATA 获取该锁</span></div><div class="line">            <span class="built_in">print</span>(i)</div><div class="line">            clock.unlock(withCondition: <span class="type">NO_DATA</span>) <span class="comment">//解锁并设置条件为 NO_DATA</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> pt = <span class="type">ProducerThread</span>()</div><div class="line"><span class="keyword">let</span> ct = <span class="type">ConsumerThread</span>()</div><div class="line">ct.start()</div><div class="line">pt.start()</div></pre></td></tr></table></figure>
<p>当创建一个条件锁时，需要使用一个整型指定开始条件。</p>
<p><code>lock(whenCondition:)</code>方法在条件成立的情况下获得一个锁，或者等待另外一个线程使用<code>unlock(withCondition:)</code>释放锁并且设置这个值。</p>
<p>条件锁对于基本锁的一些小的改进允许我们建模更加复杂的场景。</p>
<p><a name="nscondition"></a></p>
<h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a><code>NSCondition</code></h3><p>不要混淆了 NSCondition 和条件锁，一个条件提供了更加清晰的等待<em>条件</em>产生的方式。</p>
<p>当一个已经获得锁的线程需要验证额外的条件（一些需要的资源，一个处于特殊状态的对象等），满足条件才能继续运行的时候，需要一种方式挂起然后在条件成立的时候继续工作。</p>
<p>在没有 NSCondition 的时候，这种情况通常会被实现为连续地或者周期性地检查条件（繁忙的等待），但是这样的话，线程获取的锁将会怎样？当条件成立希望再次获取他们之前，是应该等待还是释放它们呢？</p>
<p>NSCondition 提供了一个此问题清晰的解决方案，拥有此锁的线程会将此条件加入了<em>等待</em>列表，当条件成立时，通过另外一个线程的信号唤醒此线程。</p>
<p>下面是一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> cond = <span class="type">NSCondition</span>()</div><div class="line"><span class="keyword">var</span> available = <span class="literal">false</span></div><div class="line"><span class="keyword">var</span> <span class="type">SharedString</span> = <span class="string">""</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriterThread</span> : <span class="title">Thread</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</div><div class="line">            cond.lock()</div><div class="line">            <span class="type">SharedString</span> = <span class="string">"😅"</span></div><div class="line">            available = <span class="literal">true</span></div><div class="line">            cond.signal() <span class="comment">// 通知并且唤醒等待的线程</span></div><div class="line">            cond.unlock()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrinterThread</span> : <span class="title">Thread</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123; <span class="comment">// 循环 5 次</span></div><div class="line">            cond.lock()</div><div class="line">            <span class="keyword">while</span>(!available)&#123;   <span class="comment">// 通过伪信号进行保护</span></div><div class="line">                cond.wait()</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">print</span>(<span class="type">SharedString</span>)</div><div class="line">            <span class="type">SharedString</span> = <span class="string">""</span></div><div class="line">            available = <span class="literal">false</span></div><div class="line">            cond.unlock()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> writet = <span class="type">WriterThread</span>()</div><div class="line"><span class="keyword">let</span> printt = <span class="type">PrinterThread</span>()</div><div class="line">printt.start()</div><div class="line">writet.start()</div></pre></td></tr></table></figure>
<p><a name="nsdistributedlock"></a></p>
<h3 id="NSDistributedLock"><a href="#NSDistributedLock" class="headerlink" title="NSDistributedLock"></a><code>NSDistributedLock</code></h3><p>分布式锁和之前看到的锁机制完全不同，我不希望大家会频繁的使用它。</p>
<p>此锁的目标是在多个应用中共享数据，背后是是用一个文件系统的入口（比如一个简单的文件）。这意味着所有需要用到的应用都应该可以访问这个文件系统。<br>使用<code>try()</code>方法来获取锁，这是一个非阻塞的方法，立即会返回一个布尔值来表明是否获取到了锁。获取锁的尝试通常是多次，通常在尝试成功之前都会加上一个合理的延迟。<br>使用<code>unlock()</code>方法来释放一个分布式锁。<br>接下来是一个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> dlock = <span class="type">NSDistributedLock</span>(path: <span class="string">"/tmp/MYAPP.lock"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> dlock = dlock &#123;</div><div class="line">    <span class="keyword">var</span> acquired = <span class="literal">false</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span>(!acquired)&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Trying to acquire the lock..."</span>)</div><div class="line">        usleep(<span class="number">1000</span>)</div><div class="line">        acquired = dlock.<span class="keyword">try</span>()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Do something...</span></div><div class="line"></div><div class="line">    dlock.unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="osatomic_where_art_thou"></a></p>
<h3 id="OSAtomic-还能用吗？"><a href="#OSAtomic-还能用吗？" class="headerlink" title="OSAtomic 还能用吗？"></a><code>OSAtomic</code> 还能用吗？</h3><p><a href="[mikeash.com: Friday Q&amp;A 2011-03-04: A Tour of OSAtomic](https://www.mikeash.com/pyblog/friday-qa-2011-03-04-a-tour-of-osatomic.html">OSAtomic</a>) 提供的原子操作，都是一些简单的操作，没有使用经典锁逻辑，允许 set，get 或者 比较后 set 变量的操作，因为 OSAtomic 考虑到了具体的 CPU 功能（一些原生原子操作），比上面的锁机制提供更好的性能。</p>
<p>因为它处理并发的方式比较原始，所以不能说它们在构建并发数据结构时候非常有用。</p>
<p>从 macOS 10.12 开始，OSAtomic 被淘汰，并且它从来不能在 Linux 下使用，但是一些开源库，比如<a href="[GitHub - glessard/swift-atomics: Atomic operations bridged from Clang to Swift](https://github.com/glessard/swift-atomics">这个库</a>)提供了有用的 Swift 扩展，还有<a href="https://github.com/bignerdranch/AtomicSwift" target="_blank" rel="external">这个库</a>提供类似的功能，你也可以通过最新 <a href="[GitHub - macmade/AtomicKit: Concurrency made simple in Swift.](https://github.com/macmade/AtomicKit">AtomicKit 库</a>)得到类似的功能。</p>
<p><a name="on_synchronized_blocks"></a></p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>在 Swift 中，不能像 Objective-C 创建一个 @synchronized 块那样去做并发操作，Swift 中没有对应可用的关键字。</p>
<p>在 Darwin 系统下，可以使用 <code>objc_sync_enter(OBJ)</code> 和 <code>objc_sync_exit(OBJ)</code>实现 @ synchronized 类似的功能，并且存在一个 @objc 的对象监控器。这种方式不推荐使用，还是使用更简单的锁机制来实现并发，更加有效。</p>
<p>正如接下来讨论 Dispatch Queues 时候会看到的那样，使用队列来实现类似的功能，在一个序列队列里面使用少量代码操作一个同步调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">serialQueue.sync &#123;</div><div class="line">    // 同时只有一个线程执行 </div><div class="line">    v += 1</div><div class="line">    print(&quot;Current value \(v)&quot;)    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="grand_central_dispatch"></a></p>
<h2 id="GCD-Grand-Central-Dispatch"><a href="#GCD-Grand-Central-Dispatch" class="headerlink" title="GCD: Grand Central Dispatch"></a><code>GCD: Grand Central Dispatch</code></h2><p>对于那些还对此 API 不熟悉的人来讲，Grand Central Dispatch (GCD) 其实就是一个基于队列的 API，允许你在工作池中执行闭包。</p>
<p>也就是说，闭包包含需要执行的任务，然后闭包将会被添加到队列中，队列将会使用一系列串行或者并行的线程执行它们，串行或并行执行取决于队列的配置选项。但是不管是那种类型的队列，任务的执行都遵从 FIFO 原则，意味着任务的执行顺序都会按照进入的顺序进行，完工时间取决于每个任务的持续时间。</p>
<p>这是一个通用的处理并发的模式，在每一个现代语言的运行时中都会看到。线程池是一种简单的方式，管理，查看和控制一系列的空闲或者未连接的线程。</p>
<p>GCD API 在 Swift 3 有少量的修改， <a href="[swift-evolution/0088-libdispatch-for-swift3.md at master · apple/swift-evolution · GitHub](https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md">SE-0088</a>) 优化了设计，让 API 变得面向对象。</p>
<p><a name="dispatch_queues"></a></p>
<h3 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h3><p>GCD 允许创建自定义队列，同时也提供访问预先定义好的系统队列的方式。</p>
<p>创建一个基本的串行队列，只需要提供一个字符串标签参数来识别它，通常推荐使用一个反向排序的域名前缀，用于在栈序列中查找队列的主人。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> serialQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.Serial1"</span>)  <span class="comment">//attributes: .serial</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.Concurrent1"</span>, attributes: .concurrent)</div></pre></td></tr></table></figure>
<p>第二个队列是并行队列，意味着这个队列使用线程中的可用线程来执行它包含的任务。在这种情况下，执行的顺序不可预测，不要假设闭包的完成顺序和插入顺序有任何的联系。</p>
<p>默认的队列可以使用 <code>DispatchQueue</code> 来获取：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> mainQueue = <span class="type">DispatchQueue</span>.main</div><div class="line"></div><div class="line"><span class="keyword">let</span> globalDefault = <span class="type">DispatchQueue</span>.global()</div></pre></td></tr></table></figure>
<p>主队列是一个顺序执行的队列，用于处理 iOS 和 macOS 可视化应用中的主事件循环，响应事件并且更新用户界面。众所周知，每一个对于用于界面的修改都将会在此队列中执行，每一个长时间的操作都会在此线程中绘制用户界面，这样用户界面会响应不及时。</p>
<p>运行时也提供了不同的优先级区分访问其他全局队列的方式，通过指定 <code>Quality of Service (Qos)</code>  参数来实现。</p>
<p>不同级别的优先级定义在 <code>DispatchQoS</code>类（译者注：DispatchQoS 是一个结构体，内含一个枚举类型表示优先级）中，从高到低如下：</p>
<ul>
<li>.userInteractive</li>
<li>.userInitiated</li>
<li>.default</li>
<li>.utility</li>
<li>.background</li>
<li>.unspecified</li>
</ul>
<p>需要重点注意的是，在手机设备上，提供低电量模式，在低电量情况下，<a href="https://mjtsai.com/blog/2017/04/03/beware-default-qos/" target="_blank" rel="external">后台队列会被挂起</a>。</p>
<p>为了获取一个特定优先级的全局队列，使用 <code>global(qos:)</code>指定需要的优先级：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> backgroundQueue = <span class="type">DispatchQueue</span>.global(qos: .background)</div></pre></td></tr></table></figure>
<p>同样的优先级指定符可以用来创建自定义队列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> serialQueueHighPriority = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.SerialH"</span>, qos: .userInteractive)</div></pre></td></tr></table></figure>
<p><a name="using_queues"></a></p>
<h3 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h3><p>任务以闭包的方式存在，可以使用两种方式将任务提交到队列中：<br>使用<code>sync</code>方法进行<em>同步操作</em>，或者使用<code>async</code>方法进行<em>异步操作</em>。</p>
<p>当使用前者时，<code>sync</code>调用将会被阻塞，换句话说，当闭包完成时，<code>sync</code>方法才会完成（当需要等待闭包完成情况下，这种方式是有效的，但是有更好的方法），而前者会将闭包加入到队列中，安排闭包延迟执行，并且允许当前的函数继续执行。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">globalDefault.async &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Async on MainQ, first?"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">globalDefault.sync &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Sync in MainQ, second?"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多个分发的调用可能会被嵌套，在一个设定好的队列上执行后台的，低优先级的操作，然后需要更新主队列的用户界面。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">DispatchQueue</span>.global(qos: .background).async &#123;</div><div class="line">    <span class="comment">// 后台运行的代码放在这里</span></div><div class="line"></div><div class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</div><div class="line">        <span class="comment">// 更新主界面</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"UI updated on main queue"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>闭包可以在指定延迟时间后执行，Swift 3 提供了简便的方式来指定需要的时间间隔，使用 <code>DispatchTimeInterval</code>枚举中的 4 个时间单位来组合不同的时间间隔：<code>.seconds(Int)</code>, <code>.milliseconds(Int),</code> <code>.microseconds(Int)</code>和 <code>.nanoseconds(Int)</code>.</p>
<p>使用 <code>asyncAfter(deadline:execute:)</code>带有一个时间间隔参数来计划一个未来执行的闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">globalDefault.asyncAfter(deadline: .now() + .seconds(<span class="number">5</span>)) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"After 5 seconds"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想同时执行一个相同的闭包多次（类似于使用 <em>dispatch_apply</em>的那样），可以使用<code>concurrentPerform(iterations:execute:)</code>来实现，需要注意的是，这些闭包可能会在当前的队列中并行执行，所以请记住把这个调用的方法包含在一个支持并发队列的同步和异步调用中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">globalDefault.sync &#123;  </div><div class="line">    <span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">5</span>) &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"\($0) times"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>While normally a queue is ready to process its closures upon creation, it can be configured to start in an idle state and to start processing jobs only when manually enabled.<br>通常一个队列在创建后就会执行它的闭包，但是也可以手动的启动任务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> inactiveQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.inactiveQueue"</span>, attributes: [.concurrent, .initiallyInactive])</div><div class="line">inactiveQueue.async &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Done!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"Not yet..."</span>)</div><div class="line">inactiveQueue.activate()</div><div class="line"><span class="built_in">print</span>(<span class="string">"Gone!"</span>)</div></pre></td></tr></table></figure>
<p>这是第一次需要指定多个属性的情况，正如代码所示，可以使用数组来添加多个属性。</p>
<p>任务可以使用继承自 <code>DispatchObject</code> 的方法来挂起或者恢复任务的执行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">inactiveQueue.suspend()</div><div class="line"></div><div class="line">inactiveQueue.resume()</div></pre></td></tr></table></figure>
<p><code>setTarget(queue:)</code> 方法可以用来配置非活跃队列的优先级（使用它来设置活跃队列将导致崩溃），调用此方法，把队列的优先级设置为作为参数传入队列的优先级。</p>
<p><a name="barriers"></a></p>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>在添加一系列闭包到指定的队列中（在不同的间隔）之后，这时想在所有异步任务完成之后执行一个任务。就需要使用屏障(Barriers)来做事。</p>
<p>添加 20 个（译者注：代码里面是 5 个）任务（每个任务将休眠一秒钟再执行）到之前创建的并发队列中，使用屏障在所有任务完成时打印一些东西，在最后一个 async 调用时候指定一个 <code>DispatchWorkItemFlags.barrier</code> 标识：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.Concurrent"</span>, attributes: .concurrent)</div><div class="line"></div><div class="line">concurrentQueue.async &#123; </div><div class="line">    <span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">5</span>) &#123; (id:<span class="type">Int</span>) <span class="keyword">in</span></div><div class="line">        sleep(<span class="number">1</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Async on concurrentQueue, 5 times: "</span>+<span class="type">String</span>(id))</div><div class="line">    &#125;</div><div class="line">&#125;   </div><div class="line"></div><div class="line">concurrentQueue.async (flags: .barrier) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"All 5 concurrent tasks completed"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>20 个任务将会并行乱序执行，可以看到打印消息会成组出现，打印数量是 Mac 系统的执行内核的个数，但是最后一个调用将会在最后执行。</p>
<p>屏障还被用于强制指定并发队列的执行顺序，不想让那些已经注册任务的执行按照一个重复的方式进行。</p>
<p>正如 Arthur Hammer 注明的那样，分发屏障不能作用与串行队列或者任何一种类型的<a href="[dispatch_barrier_async - Dispatch | Apple Developer Documentation](https://developer.apple.com/documentation/dispatch/1452797-dispatch_barrier_async?language=objc">全局并行队列</a>)，如果你想使用它，就必须自定义一个全新的并行队列。</p>
<p><a name="singletons_and_dispatch_once"></a></p>
<h3 id="单例和-Dispatch-once"><a href="#单例和-Dispatch-once" class="headerlink" title="单例和 Dispatch_once"></a>单例和 Dispatch_once</h3><p>众所周知，Swift 3 中已经没有了<code>dispatch_once</code>, 这个函数常用于构建线程安全的单例。</p>
<p>幸运的是，Swift 确保使用原子化的方式进行全局变量初始化，如果你确认常量不会在初始化后改变它的值，这两个特征确保全局常量是一个很好的实现单例的方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance: <span class="type">Singleton</span> = <span class="type">Singleton</span>()</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123; &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加类的<code>final</code>修饰确保没有子类可以继承它，并且把指定构造器设置为私有，这样就没有可能通过其他方式手动创建这个类的实例了。全局静态常量将会是 Singleton 唯一访问入口，用于获取单独的，共享的实例。</p>
<p>类似的行为用在定义块中，以下代码将执行一次：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">runMe</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">let</span> i: () = &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Once!"</span>)</div><div class="line">        &#125;()</div><div class="line">    &#125;</div><div class="line">    <span class="type">Inner</span>.i</div><div class="line">&#125;</div><div class="line"></div><div class="line">runMe()</div><div class="line">runMe() <span class="comment">// 常量已经被初始化了</span></div><div class="line">runMe() <span class="comment">// 常量已经被初始化了</span></div></pre></td></tr></table></figure>
<p>看起来不是那么优雅，但是能够运行，这是一种可以接受的实现方式，如果只是想执行一次性代码的话。</p>
<p>But if we need to replicate exactly the functionality and API of dispatch_once we need to implement it from scratch, as described in the synchronized blocks section with an extension:<br>如果想重现 <code>dispatch_once</code> 所提供的功能，需要重新实现，使用一个扩展在<a href="#on_synchronized_blocks">同步模块区域</a>添加代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> onceTokens = [<span class="type">Int</span>]()</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> internalQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"dispatchqueue.once"</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">once</span>(<span class="title">token</span>: <span class="title">Int</span>, <span class="title">closure</span>: (<span class="title">Void</span>)-&gt;<span class="title">Void</span>) </span>&#123;</div><div class="line">        internalQueue.sync &#123;</div><div class="line">            <span class="keyword">if</span> onceTokens.<span class="built_in">contains</span>(token) &#123;</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                onceTokens.append(token)</div><div class="line">            &#125;</div><div class="line">            closure()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> t = <span class="number">1</span></div><div class="line"><span class="type">DispatchQueue</span>.once(token: t) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"only once!"</span>)</div><div class="line">&#125;</div><div class="line"><span class="type">DispatchQueue</span>.once(token: t) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Two times!?"</span>)</div><div class="line">&#125;</div><div class="line"><span class="type">DispatchQueue</span>.once(token: t) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Three times!!?"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所愿，三个闭包中的第一个将会被真正的执行。</p>
<p><a name="dispatch_groups"></a></p>
<h3 id="调度组"><a href="#调度组" class="headerlink" title="调度组"></a>调度组</h3><p>如果你有多个任务，想添加到多个不同的队列中，并且想等待它们的完工，你可以把它们进行分组，添加到一个调度组中。</p>
<p>Let’s see an example, a task can be added to a specific group directly with the sync or async call:<br>下面是一个例子，直接使用 <code>sync</code> 或者 <code>async</code> 调用将一个任务添加到一个指定的组中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> mygroup = <span class="type">DispatchGroup</span>()</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</div><div class="line">    globalDefault.async(group: mygroup)&#123;</div><div class="line">        sleep(<span class="type">UInt32</span>(i))</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Group async on globalDefault:"</span>+<span class="type">String</span>(i))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任务将在 <code>globalDefault</code> 里面执行，但是可以注册一个 <code>mygroup</code> 的回调，一旦所有任务完成以后，将会在队列中执行一个闭包，<code>wait()</code>方法用于执行阻塞等待。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"Waiting for completion..."</span>)</div><div class="line">mygroup.notify(queue: globalDefault) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Notify received, done waiting."</span>)</div><div class="line">&#125;</div><div class="line">mygroup.wait()</div><div class="line"><span class="built_in">print</span>(<span class="string">"Done waiting."</span>)</div></pre></td></tr></table></figure>
<p>另外一种跟踪组任务方式是，手动在运行队列代码调用中进入和离开一个组，替换指定的方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</div><div class="line">    mygroup.enter()</div><div class="line">    sleep(<span class="type">UInt32</span>(i))</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Group sync on MAINQ:"</span>+<span class="type">String</span>(i))</div><div class="line">    mygroup.leave()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="dispatch_work_items"></a></p>
<h3 id="调度工作项"><a href="#调度工作项" class="headerlink" title="调度工作项"></a>调度工作项</h3><p>闭包不是队列中指定任务实现的唯一方式，有时可能需要一个容器类型来跟踪执行的状态，这个时候 <code>DispatchWorkItem</code> 就派上了用场，工作项的每一个方法，都包括一个闭包作为它的参数。</p>
<p>工作项封装了一个队列线程池执行的闭包，通过 perform()  来执行这个闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> workItem = <span class="type">DispatchWorkItem</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Done!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">workItem.perform()</div></pre></td></tr></table></figure>
<p><code>DispatchWorkItem</code> 同样提供其它有用的方法，比如: 和组的定义一样，<code>notify</code>方法将会在指定的队列执行完成以后执行一个闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">workItem.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Notify on Main Queue!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">defaultQueue.async(execute: workItem)</div></pre></td></tr></table></figure>
<p>也可以等待闭包执行结束，或者在队列尝试调用<code>cancel()</code>方法（这不是取消执行中的闭包）之前标记它删除。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"Waiting for work item..."</span>)</div><div class="line">workItem.wait()</div><div class="line"><span class="built_in">print</span>(<span class="string">"Done waiting."</span>)</div><div class="line">workItem.cancel()</div></pre></td></tr></table></figure>
<p>需要重点注意的是，<code>wait()</code>方法不仅仅是阻塞当前线程，等待完成，也会抬高所有队列中早先的工作项，试图尽快完成指定的项目。</p>
<p><a name="dispatch_semaphores"></a></p>
<h3 id="调度信号量"><a href="#调度信号量" class="headerlink" title="调度信号量"></a>调度信号量</h3><p>调度信号量是一种锁，根据当前计数的值，可以被多个线程获取。</p>
<p>线程会等待一个信号量，直到信号量减到 0 时，就可以获取它了。</p>
<p>访问信号量的槽将对等待线程释放，等待线程调用<code>signal</code>方法将会增加计数。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> sem = <span class="type">DispatchSemaphore</span>(value: <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">// 信号量将被两个线程池组持有</span></div><div class="line">globalDefault.sync &#123;</div><div class="line">    <span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">10</span>) &#123; (id:<span class="type">Int</span>) <span class="keyword">in</span></div><div class="line">        sem.wait(timeout: <span class="type">DispatchTime</span>.distantFuture)</div><div class="line">        sleep(<span class="number">1</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" acquired semaphore."</span>)</div><div class="line">        sem.signal()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a name="dispatch_assertions"></a></p>
<h3 id="调度断言"><a href="#调度断言" class="headerlink" title="调度断言"></a>调度断言</h3><p>Swift 3 引入了一个新的函数，用于在当前执行上下文中进行断言，用于验证一个闭包是否在预期的队列中被执行了。使用 <code>DispatchPredicate</code> 枚举的是三个值来断言执行的情况：<code>.onQueue</code>, 验证闭包是否执行在一个指定队列中，<code>.notOnQueue</code>, 验证相反的情况，<code>.onQueueAsBarrier</code>，验证当前闭包或者工作项是否作为一个队列的屏障存在。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">dispatchPrecondition(condition: .notOnQueue(mainQueue))</div><div class="line">dispatchPrecondition(condition: .onQueue(queue))</div></pre></td></tr></table></figure>
<blockquote>
<p>此文章和本博客相关文章代码可以从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="external">GitHub</a>和 <a href="https://www.uraimo.com/archives/2017-05-07-ConcurrencyInSwift.playground.zip" target="_blank" rel="external">Zipped</a>上下载。  </p>
</blockquote>
<p><a name="dispatch_sources"></a></p>
<h2 id="调度资源"><a href="#调度资源" class="headerlink" title="调度资源"></a>调度资源</h2><p>调度资源是一种处理系统级异步事件的方式，包括内核信号，系统，文件或者 socket 相关使用事件处理的事件。</p>
<p>有以下几种类型可用的调度资源，归类如下：</p>
<ul>
<li><strong>Timer Dispatch Sources</strong> : 用作产生与时间或者周期相关的事件（DispatchSourceTimer）。<br><strong>Signal Dispatch Sources</strong> : 用于处理 UNIX 信号（DispatchSourceSignal）。<br><strong>Memory Dispatch Sources</strong>:<br>用于注册与内存使用状态相关的通知（DispatchSourceMemoryPressure）。<br><strong>Descriptor Dispatch Sources</strong>:<br>用于注册文件和socket相关的不同事件（DispatchSourceFileSystemObject, DispatchSourceRead, DispatchSourceWrite）。<br><strong>Process dispatch sources</strong>:<br>用于监控外部进程相关执行状态的时间（DispatchSourceProcess）。<br><strong>Mach related dispatch sources</strong>:<br>用于处理 Mach 内核的 <a href="http://fdiv.net/2011/01/14/machportt-inter-process-communication" target="_blank" rel="external">IPC 工具</a>相关的事件（<em>DispatchSourceMachReceive</em>, <em>DispatchSourceMachSend</em>）。</li>
</ul>
<p>也可以在需要的时候自定义调度资源。所有的调度资源都遵从<code>DispatchSourceProtocol</code> 协议，需要定义注册处理器的基本操作，修改调度资源的激活状态等。</p>
<p>举一个 <code>DispatchSourceTimer</code> 的例子来理解如何使用这些对象。</p>
<p>使用 <code>DispatchSource</code> 的工具函数来创建资源对象，在下面代码中使用 <code>makeTimerSource</code>， 指定需要执行处理的调度队列。</p>
<p>时间资源没有其它参数，只需要指定队列来创建资源，调度资源可以处理多个时间，通常需要指定处理事件的标识符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> t = <span class="type">DispatchSource</span>.makeTimerSource(queue: <span class="type">DispatchQueue</span>.global())</div><div class="line">t.setEventHandler&#123; <span class="built_in">print</span>(<span class="string">"!"</span>) &#125;</div><div class="line">t.scheduleOneshot(deadline: .now() + .seconds(<span class="number">5</span>), leeway: .nanoseconds(<span class="number">0</span>))</div><div class="line">t.activate()</div></pre></td></tr></table></figure>
<p>资源建立以后，使用<code>setEventHandler(closure:)</code>注册一个时间处理器，如果没有其它配置了，使用<code>activate()</code>开启调度资源（前一个版本的<code>libDispatch</code> 使用的是 <code>resume()</code>方法）。</p>
<p>调度资源初始是不激活的，意味着不会立刻执行事件。当一切准备情绪后，资源将使用<code>activate()</code>激活分发事件，也可以使用<code>suspend()</code>挂起和使用<code>resume()</code>恢复。</p>
<p>时间资源需要一个额外的步骤来配置哪种类型的时间事件会被对象调度。在下面的例子中，定义一个会在 5 秒后执行的调度事件。</p>
<p>也可以定义一个周期事件，和在 <a href="https://www.uraimo.com/swiftbites/nstimer-in-swift-3/" target="_blank" rel="external">Timer</a> 对象所做的一样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">t.scheduleRepeating(deadline: .now(), interval: .seconds(<span class="number">5</span>), leeway: .seconds(<span class="number">1</span>))</div></pre></td></tr></table></figure>
<p>当完成一个调度资源时，想完全阻止调度事件，可以使用<code>cancel()</code>来完成，这样可以停止资源事件，取消已经设置的处理器，并且进行一些清理操作，比如注销处理器等。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">t.cancel()</div></pre></td></tr></table></figure>
<p>其它调度资源类型的 API 是类似的，看一个 <a href="https://github.com/IBM-Swift/Kitura-net/blob/master/Sources/KituraNet/IncomingSocketHandler.swift#L96" target="_blank" rel="external">Kitura</a> 初始化读取资源的例子，用于处理在一个建立连接的 socket 的异步写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">readerSource = <span class="type">DispatchSource</span>.makeReadSource(fileDescriptor: socket.socketfd,</div><div class="line">                                             queue: socketReaderQueue(fd: socket.socketfd))</div><div class="line"></div><div class="line">readerSource.setEventHandler() &#123;</div><div class="line">    <span class="number">_</span> = <span class="keyword">self</span>.handleRead()</div><div class="line">&#125;</div><div class="line">readerSource.setCancelHandler(handler: <span class="keyword">self</span>.handleCancel)</div><div class="line">readerSource.resume()</div></pre></td></tr></table></figure>
<p>当 socket 中接收数据缓存中有新的字节可用时， <code>handleRead()</code> 将在一个专用的队列中调用。Kitura 同样使用 <code>WriteSource</code> 来操作一个缓存写，使用分发资源事件进行<a href="https://github.com/IBM-Swift/Kitura-net/blob/master/Sources/KituraNet/IncomingSocketHandler.swift#L328" target="_blank" rel="external">高效的写操作</a>，当 socket 管道可以发送字节时，就写入新的字节。在 *nix 平台下去进行 I/O 操作，调度资源是一个很好的高阶方案，替代那些底层的 API。</p>
<p>对于和文件相关的调度资源，另外一个有用的对象是 <code>DispatchSourceFileSystemObject</code>， 它允许监听指定文件的变化，从名字的变化到属性的变化都可以监听。使用调度资源，你也可以接受文件修改或者删除的通知，这是 Linux 中 inotify 内核子系统的一个子集。</p>
<p>剩余的资源类型操作是类似的，你可以从 <a href="https://developer.apple.com/reference/dispatch/dispatchsource" target="_blank" rel="external">libDispatch 文档</a>中获取更多的细节，但是请记住的是，像 <code>Mach</code> 资源和内存压力资源只能在 <code>Darwin</code> 平台中使用。</p>
<p><a name="operations_and_operationqueues"></a></p>
<h3 id="操作和操作队列"><a href="#操作和操作队列" class="headerlink" title="操作和操作队列"></a>操作和操作队列</h3><p>简单来说说操作队列，这是建立在 GCD 顶层的附加 API，把并行队列和模型任务看作为操作，易于取消，依赖其它操作完成情况来执行任务。</p>
<p>操作可以有优先级，定义了执行的顺序，也可以添加到 <code>OperationQueues</code> 异步执行。</p>
<p>看看一个基本的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> queue = <span class="type">OperationQueue</span>()</div><div class="line">queue.name = <span class="string">"My Custom Queue"</span></div><div class="line">queue.maxConcurrentOperationCount = <span class="number">2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> mainqueue = <span class="type">OperationQueue</span>.main <span class="comment">// 引用主线程中的队列</span></div><div class="line"></div><div class="line">queue.addOperation&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Op1"</span>)</div><div class="line">&#125;</div><div class="line">queue.addOperation&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Op2"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以创建一个<em>阻塞操作</em>对象，在添加到队列之前进行配置，并且可以添加多个闭包到这个类型的操作中。</p>
<p>需要注意的是，在 Swift 中， <code>NSInvocationOperation</code>, 不再可用，这个类可以使用<br><code>target+selector</code> 来创建操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> op3 = <span class="type">BlockOperation</span>(block: &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Op3"</span>)</div><div class="line">&#125;)</div><div class="line">op3.queuePriority = .veryHigh</div><div class="line">op3.completionBlock = &#123;</div><div class="line">    <span class="keyword">if</span> op3.isCancelled &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Someone cancelled me."</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Completed Op3"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> op4 = <span class="type">BlockOperation</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Op4 always after Op3"</span>)</div><div class="line">    <span class="type">OperationQueue</span>.main.addOperation&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"I'm on main queue!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>操作会有优先级，第二个完整的闭包将在主闭包完成后执行一次。</p>
<p>还可以添加 <code>op4</code> 对 <code>op3</code> 的依赖，这样 <code>op4</code> 将等待 <code>op3</code> 的完成。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">op4.addDependency(op3)</div><div class="line">queue.addOperation(op4)  <span class="comment">// op3 会一直在 op4 之前执行</span></div><div class="line">queue.addOperation(op3)</div></pre></td></tr></table></figure>
<p>也可以使用 <code>removeDependency(operation:)</code> 移除依赖，依赖是存储在一个公开访问的依赖数组中。</p>
<p>操作的状态可以使用指定的属性查看：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">op3.isReady       <span class="comment">// 是否准备好执行？</span></div><div class="line">op3.isExecuting   <span class="comment">// 是否执行中？</span></div><div class="line">op3.isFinished    <span class="comment">// 是否执行完成或被取消掉？</span></div><div class="line">op3.isCancelled    <span class="comment">// 是否被手动取消？</span></div></pre></td></tr></table></figure>
<p>调用 <code>cancelAllOperations</code> 可以取消一个现存队列中所有的操作，在队列中存在的所有操作都会被设置 <code>isCancelled</code> 标识。调用 cancel 方法可以取消单个操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">queue.cancelAllOperations() </div><div class="line">op3.cancel()</div></pre></td></tr></table></figure>
<p>推荐执行时对 <code>isCancelled</code> 属性进行检查，当计划在队列中执行这个操作时，一旦操作被取消，可以检查<code>isCancelled</code>来跳过这个执行。</p>
<p>最后，可以在操作队列中停止新操作的执行（当前执行中的操作不会被影响）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">queue.isSuspended = <span class="literal">true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>此文章和本博客相关文章代码可以从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="external">GitHub</a>和 <a href="https://www.uraimo.com/archives/2017-05-07-ConcurrencyInSwift.playground.zip" target="_blank" rel="external">Zipped</a>上下载。  </p>
</blockquote>
<p><a name="closing_thoughts"></a></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这篇文章很好的总结了 Swift 中目前可用的外部并发框架。</p>
<p>即将到来的此系列第二部分将聚焦在如何在不引入外部库的情况下，使用原生语言特性来处理并发。借助现有的一些开源实现，介绍一些有趣的范式。</p>
<p>我希望这两篇文章是一个打开并发编程之门的很好的介绍，这将有助于理解和参与在 swift-evolution 中的讨论，至于何时会引入原生的支持，希望是 Swift 5吧。</p>
<p>查看更多关于 Swift 和并发有趣的故事，可以查看博客：<a href="https://www.cocoawithlove.com/tags/asynchrony.html" target="_blank" rel="external">Cocoa With Love</a>。</p>
<p>喜欢这篇文章吗？给我 <a href="https://www.twitter.com/uraimo" target="_blank" rel="external">twitter</a> 留言吧！</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Umberto Raimondi，&lt;a href=&quot;https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-05-07&lt;br&gt;译者：&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;shanks&lt;/a&gt;；校对：&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;shanks&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;当前最新版本的 Swift 语言（译者注：当前最新稳定版本为 3.1.1）还没有包含任何原生并发特性，但是在其他现代编程语言中是带有这个特性的，比如 Go 和 Rust。&lt;br&gt;如果你想并发地执行任务，这时就需要处理与结果相关的竞态条件，目前唯一的选择就是使用第三方库，比如 libDispatch，或者 Foundation 和其他 OS 中提供的同步原语。&lt;br&gt;在这一系列文章的第一部分，看看 Swift 3 给出的处理方案，覆盖以下一些内容：Foundation 中的锁，线程和计时器提供语言层面的保证，最近不断增强的 GCD(Grand Central Dispatch) 和操作队列（Operation Queues）。&lt;/p&gt;
&lt;p&gt;同时也会讨论到基础的并发原理和一些通用的并发模式。&lt;/p&gt;
    
    </summary>
    
      <category term="uraimo" scheme="https://swift.gg/categories/uraimo/"/>
    
    
      <category term="Swift 进阶，并发编程" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于 Purple Train 的说明</title>
    <link href="https://swift.gg/2017/07/31/announcing-purple-train/"/>
    <id>https://swift.gg/2017/07/31/announcing-purple-train/</id>
    <published>2017-07-30T16:00:00.000Z</published>
    <updated>2017-09-05T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Ian C. Anderson，<a href="https://robots.thoughtbot.com/announcing-purple-train" target="_blank" rel="external">原文链接</a>，原文日期：2017-1-9<br>译者：<a href="undefined">Tuccuay</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<p>我一直想开发一个 iOS 应用，现在我可以很高兴的告诉大家，在许多同事的帮助下终于在今年完成了 <a href="https://purpletrainapp.com/" target="_blank" rel="external">Purple Train</a>。</p>
<p><img src="/img/articles/announcing-purple-train/TujwAPQD6B8G2RoVixXA_purple-train-iphone-app-f7b427aaec509ee65069d07f2e809152.png1501462197.36" alt=""></p>
<a id="more"></a>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>Purple Train 为了解决一个简单的问题：我关心的下一趟 MBTA 通勤火车什么时候出发？市场上几个类似的 app 都感觉不太好用。我只想很快速的打开它并得到想要的信息，然后返回。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>如果你想从一个固定的「家」和波士顿之间通勤，这个应用能为你提供一个简单而有效的界面：选择你家附近的车站，然后就能离开看到往返于波士顿之间的列车。如果有快车不在选择的车站停车，它将会被自动过滤掉以免带来不必要的干扰。</p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>在开始开发 app 之前，有不少人讲过 React Native 的优点，所以我尝试了一下。我感兴趣的原因并不是因为能使用 JavaScript 开发，而是因为它能够进行 <a href="https://robots.thoughtbot.com/rapid-cross-platform-mobile-development-with-react-native" target="_blank" rel="external">跨平台开发</a>。我已经很熟悉使用 React 和 Redux 进行函数式响应式编程。所以想在 Purple Train 上尝试一下看看它带来多大生产力的提升。</p>
<p><a href="https://twitter.com/twnsndco" target="_blank" rel="external">Cole Townsend</a> 在完成 app 的初期设计工作的时候觉得非常舒服，他使用 React Native 的 <a href="https://facebook.github.io/react-native/docs/stylesheet.html" target="_blank" rel="external">StyleSheet</a> 来实现这些设计。</p>
<p>基本功能在 iOS 上正常运行之后，<a href="https://twitter.com/kenyonj" target="_blank" rel="external">Justin Kenyon</a> 和我花了半天时间把它移植到 Android。让我们感到高兴的是这个过程很简单，并且整个 app 中没有针对某个特定平台的兼容代码，在所有的工作中只用到了 React Native 和几个第三方库。</p>
<p>感谢 <a href="https://twitter.com/blakewilliams__" target="_blank" rel="external">Blake Williams</a>, <a href="https://twitter.com/kenyonj" target="_blank" rel="external">Justin Kenyon</a>, <a href="https://twitter.com/derekprior" target="_blank" rel="external">Derek Prior</a>, and <a href="https://twitter.com/mborsare" target="_blank" rel="external">Mike Borsare</a> 所做的前端工作！</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>这个 app 的后端是一个 Elixir Phoenix 应用，用于缓存 <a href="http://realtime.mbta.com/portal" target="_blank" rel="external">MBTA’s Realtime API</a> 的响应并且能够返回针对移动应用优化过的更精简的 JSON。</p>
<p>这个 Phoenix 使用 Elixir 提供的 <a href="http://elixir-lang.org/getting-started/mix-otp/agent.html" target="_blank" rel="external">Agent</a> 模块存储来自 MBTA API 的响应。这让我们有了一个非常迅速的内存缓存，使得后端能够快速响应。</p>
<p>后端还有一些可以过滤掉用户不关心的车次（比如已经离开用户所在车站或者不停靠用户所在站点的快车）的功能。这使得前端的工作更方便并且保持较小的 JSON 响应，这也有助于提升移动设备的性能。</p>
<p>感谢 <a href="https://twitter.com/derekprior" target="_blank" rel="external">Derek Prior</a> 和 <a href="https://twitter.com/joshuaclayton" target="_blank" rel="external">Josh Clayton</a> 编写并优化的后端！</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><p>Web 开发工程师和设计师都可以立即开始使用 React Native。他们对 JavaScript 语言、Cmd + R 或者 Live Reloading 重新加载的工作流、函数式响应式编程和样式表都已经很熟悉了。</p>
<p>尽管使用 JavaScript 还可能存在很多问题，但这种熟悉的方式提供的生产力让 React Native 成为许多跨平台 app 选择。</p>
<h2 id="Elm-Native"><a href="#Elm-Native" class="headerlink" title="Elm Native"></a>Elm Native</h2><p>我们喜欢这个工作流，也喜欢这些概念，还熟悉这些语言。但是相比起 Swift 和 Kotlin 这些原生的编译型语言来说，则少了一些安全性和重构的便利性。</p>
<p>我们如何才能有一个高效的工作流，而不会遇到 JavaScript 错误，比如 undefined is not a function？如果使用 <a href="http://elm-lang.org/" target="_blank" rel="external">Elm</a> 语言可以让我们更自信地说代码是正确的吗？</p>
<p>幸运的是 Purple Train 是个很简单的 app，这让它能够很好地成为试验新技术的测试平台，请持续关注我们是如何使用 <a href="https://github.com/ohanhi/elm-native-ui" target="_blank" rel="external">elm-native-ui</a> 将 Purple Train 迁移到 <a href="http://elm-lang.org/" target="_blank" rel="external">Elm</a> 的！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://purpletrainapp.com/" target="_blank" rel="external">Purple Train</a> 主页</li>
<li>阅读 <a href="https://robots.thoughtbot.com/rapid-cross-platform-mobile-development-with-react-native" target="_blank" rel="external">Rapid cross-platform mobile development with React Native</a></li>
<li>收听 <a href="http://bikeshed.fm/86" target="_blank" rel="external">Bikeshed Podcast episode about Purple Train</a><blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      关于 Purple Train 的说明
    
    </summary>
    
      <category term="Thoughtbot" scheme="https://swift.gg/categories/Thoughtbot/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #76</title>
    <link href="https://swift.gg/2017/07/26/swift-weekly-issue-76/"/>
    <id>https://swift.gg/2017/07/26/swift-weekly-issue-76/</id>
    <published>2017-07-25T16:00:00.000Z</published>
    <updated>2017-09-05T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-76/" target="_blank" rel="external">原文链接</a>，原文日期：2017-06-29<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="external">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="external">Cwift</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<p><em>本期作者：<a href="https://twitter.com/garricn" target="_blank" rel="external">Garric Nahapetian</a></em></p>
<p>Swift 的 <a href="https://github.com/apple/swift" target="_blank" rel="external">git 仓库</a>这周特别忙，这里有一些 GitHub 的数据：</p>
<blockquote>
<p>除了 Merge 之外，总共有 39 个作者 push 了 156 个 commit 到主分支，所有分支算起来有 284 个 commit。在主分支，401 个文件被修改，增 12589 删 9215 …</p>
</blockquote>
<p>在 WWDC 结束不久就完成了这么多的事情实属不易，在 Swift 4 立项之后核心团队和别的贡献者完成了惊人的进展。</p>
<a id="more"></a>
<p>iOS 11 beat 2，tvOS 11 beta 2 和 Swift Playgrounds 2 beta 2 都开放下载了，点击<a href="https://developer.apple.com/download/" target="_blank" rel="external">此处下载</a>，遇到 bug 记得要反馈哦！</p>
<blockquote>
<p><strong>赞助链接</strong></p>
<p><a href="http://www2.bignerdranch.com/l/299472/2017-06-21/8rxl/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_76" target="_blank" rel="external">提升你的技能 — 成就你的职业生涯</a></p>
<p>专家带你入门到精通只需一周时间。</p>
<p><a href="http://www2.bignerdranch.com/l/299472/2017-06-21/8rxl/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_76" target="_blank" rel="external">bignerdranch.com</a></p>
</blockquote>
<h2 id="Swift-Unwrapped"><a href="#Swift-Unwrapped" class="headerlink" title="Swift Unwrapped"></a>Swift Unwrapped</h2><p>在<a href="https://spec.fm/podcasts/swift-unwrapped/70319" target="_blank" rel="external">第 17 集：Swift 里的测试</a>，Jesse 和 JP 讨论了如何使用 Swift 和相应的工具进行测试，保证每一个上线版本都井然有序。</p>
<h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>Greg Heo <a href="https://swiftunboxed.com/stdlib/json-encoder-encodable/" target="_blank" rel="external">写了一篇文章</a>讲述 Swift 里 <code>Encoder</code> 和 <code>Encodable</code> 的原理，这个新功能会影响到很多开源的软件，了解它的原理更有助于你理解它们相关的 PR。</p>
<p>Matt Godbolt 的<em>探索编译器</em>现已<a href="https://twitter.com/Catfish_Man/status/877991651548975104" target="_blank" rel="external">支持 Swift</a>。（译者注：这是一个学习编译原理的网站，输入代码，就可以看到编译后在对应平台上的汇编码）</p>
<p>David Owens 放出了一个 <a href="https://owensd.io/2017/06/02/apous-early-preview/" target="_blank" rel="external">VSCode 的插件</a>，让 VSCode 也能支持 Swift。</p>
<p>Swift 支援团队<a href="https://twitter.com/swift_evolution/status/878322333471068160" target="_blank" rel="external">开源</a>了 Swift-Evolution 的 App — <a href="https://itunes.apple.com/us/app/evolution-app/id1210898168?mt=8" target="_blank" rel="external">Evo</a>。</p>
<p>Steven Hepting <a href="https://twitter.com/stevenhepting/status/878339681485635585" target="_blank" rel="external">讲述</a>了 Swift 的 <code>sort()</code> 方法是怎么优化的，这里可以找到相应的<a href="https://github.com/apple/swift/blob/02e2bd5380af69948d2324b936bfc61e1454d8ea/stdlib/public/core/Sort.swift.gyb#L232-L301" target="_blank" rel="external">源码</a>。</p>
<p><a href="https://www.meetup.com/Learn-Swift-Queens-Meetup/" target="_blank" rel="external">Learn Swift 皇后区</a> &amp; <a href="https://www.meetup.com/Learn-Swift-Portland/" target="_blank" rel="external">Learn Swift 波兰</a>, 都落下了帷幕。 这是11期  <a href="https://wordpress.com/post/swiftcoders.org/178" target="_blank" rel="external">Learn Swift {城市}</a> 系列的合集！下次会是在哪座城市呢？</p>
<p><a href="https://github.com/br1sk/brisk" target="_blank" rel="external">Brisk，一个反馈 bug 的 macOS app</a> 上线了 <a href="https://github.com/br1sk/brisk/releases/tag/1.0.0" target="_blank" rel="external">1.0 版本</a> ，并且快速迭代发布了 <a href="https://github.com/br1sk/brisk/releases/tag/1.0.1" target="_blank" rel="external">1.0.1 版本</a>，记得要帮忙反馈 bug 哦！</p>
<p>元组门又有了更多的<a href="https://twitter.com/s1ddok/status/879406585939984386" target="_blank" rel="external">进展</a>，这对我来说很有趣，因为<a href="https://github.com/garricn/GGNObservable/blob/master/GGNObservable/Classes/Observable.swift#L53" target="_blank" rel="external">我个人也使用过类似的方式</a>。就像 <a href="https://twitter.com/slava_pestov/status/879446070190800896" target="_blank" rel="external">Slava 指出</a>的那样，这件事情始终还有<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160307/012299.html" target="_blank" rel="external">优化的空间</a>。（译者注：元组门就是闭包里的元组不再自动展开的事情，<a href="http://swift.gg/2017/07/16/swift_weekly_issue_74/">前两周</a>的<a href="http://swift.gg/2017/07/24/swift-weekly-issue-75/">周报</a>都有提到，详情请看 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md" target="_blank" rel="external">SE-0029</a>，<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md" target="_blank" rel="external">SE-0066</a> 和 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0110-distingish-single-tuple-arg.md" target="_blank" rel="external">SE-0110</a>）。</p>
<h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Ben Cohen 发起一个新的<a href="https://github.com/apple/swift-evolution/pull/728" target="_blank" rel="external">合并请求</a>，让 <code>Substring</code> 可以添加到 <code>Hashable</code> 容器里（详情请看下面的邮件列表讨论）。</p>
<p>Itai Ferber <a href="https://github.com/apple/swift/pull/10538" target="_blank" rel="external">通过了一个合并请求</a>，修复了 <a href="https://bugs.swift.org/browse/SR-5277" target="_blank" rel="external">SR-5277</a>，让 class 可以与父类共用一个 Encoder/Decoder。更多详情请看这里的<a href="https://twitter.com/garricn/status/878426105585127425" target="_blank" rel="external">讨论进程</a>。</p>
<p>Philippe Hausler <a href="https://github.com/apple/swift/pull/10584" target="_blank" rel="external">通过了一个合并请求</a>，修复了 <a href="https://bugs.swift.org/browse/SR-5292" target="_blank" rel="external">SR-5292</a>。修复了 Foundation 里使用 slice 嵌套 slice 时产生的 bug。</p>
<p>Joe Groff  <a href="https://github.com/apple/swift/pull/10556" target="_blank" rel="external">通过了一个合并请求</a>，让 KeyPath 支持可选链（Optional Chainning）和强制解包（Force Unwrapping）。</p>
<p>Doug Gregor <a href="https://github.com/apple/swift/pull/10565" target="_blank" rel="external">通过了一个合并请求</a> ，优化了基本类型，类型别名和递归的处理逻辑，并且修复了 <a href="https://bugs.swift.org/browse/SR-4295" target="_blank" rel="external">SR-4295</a>，<a href="https://bugs.swift.org/browse/SR-4757" target="_blank" rel="external">SR-4757</a>，<a href="https://bugs.swift.org/browse/SR-4786" target="_blank" rel="external">SR-4786</a>，<a href="https://bugs.swift.org/browse/SR-5014" target="_blank" rel="external">SR-5014</a> 和 <a href="https://bugs.swift.org/browse/SR-4737" target="_blank" rel="external">SR-4737</a>。</p>
<p>Dave Abrahams <a href="https://github.com/apple/swift/pull/9806" target="_blank" rel="external">发起一个合并请求</a>，实现了 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="external">SE-0180</a> 字符串索引越界（后面有详细介绍）。</p>
<p>在命令行里运行 <code>man swift</code> 时展示的手册<a href="https://github.com/apple/swift/pull/10241" target="_blank" rel="external">已获得更新</a>。</p>
<p>Maxim Moiseev <a href="https://github.com/apple/swift/pull/9466" target="_blank" rel="external">通过了一个合并请求</a>，修复了 <code>[String]</code> 使用 <code>flatMap</code> 时的向后兼容性，有兴趣了解的话可以查看这里的 <a href="https://twitter.com/codafi_/status/878330155642396673" target="_blank" rel="external">Swift 迷思- by Robert Widmann</a>。</p>
<p>David Farler <a href="https://github.com/apple/swift-clang/pull/95" target="_blank" rel="external">通过了一个合并请求</a>，内容主要是 Xcode 9 里编译时索引功能（index-while-building）在这段时间里的改进。</p>
<p>如果你想知道某个修复了 <code>rdar://</code> 的 PR 的细节，<a href="https://twitter.com/garricn/status/879551154316689408" target="_blank" rel="external">放心大胆地问就可以了</a>。</p>
<h2 id="审核中的提案"><a href="#审核中的提案" class="headerlink" title="审核中的提案"></a>审核中的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="external">SE-0180</a>: String Index Overhaul 在一些讨论之后重新退回<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037653.html" target="_blank" rel="external">审核阶段</a>。</p>
<h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>Erica Sadun <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037730.html" target="_blank" rel="external">写了一篇文章</a>关于 <code>!!</code> 这个她称为“解包或崩溃”的操作符。你可以在<a href="https://gist.github.com/erica/423e4b1c63b95c4c90338cdff4939a9b" target="_blank" rel="external">这个 Gist</a> 里找到相应的草稿。</p>
<blockquote>
<p>使用一个操作符，在解包失败时提供反馈信息，已经成为 Swift 开发者社区里普遍会实现的一个东西了，你对于把这个广泛使用的操作符加入到标准库有什么想法？</p>
<p><em>译者注：使用了 <code>!!</code> 的代码会类似于这样 <code>let _ = optionalObject !! &quot;空的对象&quot;</code>，能够在强制解包失败的时候提供 debug 信息，思路很棒，建议大家看一下。</em></p>
</blockquote>
<p>Ben Cohen <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037776.html" target="_blank" rel="external">发了一篇文章</a>，内容主要是关于 <code>Substring</code> 性能的讨论。</p>
<blockquote>
<p>作为 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0163-string-revision-1.md" target="_blank" rel="external">SE-0163</a> 的要点之一，<code>Substring</code> 显式转换到 <code>String</code> 的问题都推迟到第一版实现之后讨论。直到现在，收到的反馈也都没有让我们觉得这样的显式转换很有必要 — 从 3.2 迁移到 4.0 的时候也不怎么需要用到   <code>Substring</code> 到 <code>String</code>的转换。即便不在开发目标里，只要是这方面的版本迁移问题，收到您的反馈我们都会很感谢。</p>
<p>[…]</p>
</blockquote>
<p>Itai Ferber <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037672.html" target="_blank" rel="external">在 Swift-Evolution 发了一条信息</a> ，征求 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0166-swift-archival-serialization.md" target="_blank" rel="external">SE-0166</a> 和 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0167-swift-encoders.md" target="_blank" rel="external">SE-0167</a> 的反馈，希望社区了解到之前的很多建议已经被采纳并实现，继续提供建议和意见。</p>
<p>Robert Bennett 提了一个<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037676.html" target="_blank" rel="external">有趣的建议</a>，希望 protocol 里可以声明 <code>let</code>。但我并不认为他提的算是一个问题。</p>
<blockquote>
<p>我在处理协议的时候遇上了一个恼人的问题。在一个 <code>class</code> 或者 <code>struct</code> 里使用 <code>let</code> 去修饰一个属性并且在 <code>init</code> 方法里初始化是很常见的情况，但却没办法在一个 protocol extension 里实现一个这样的 <code>init</code> 方法。</p>
<p>[…]</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>“索取”<a href="https://twitter.com/harlanhaskins/status/878499165663240192" target="_blank" rel="external">有时候</a>比“给予”感觉更好</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      Swift 周报
    
    </summary>
    
      <category term="Swift 进阶" scheme="https://swift.gg/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Jesse Squires" scheme="https://swift.gg/tags/Jesse-Squires/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #75</title>
    <link href="https://swift.gg/2017/07/24/swift-weekly-issue-75/"/>
    <id>https://swift.gg/2017/07/24/swift-weekly-issue-75/</id>
    <published>2017-07-23T16:00:00.000Z</published>
    <updated>2017-09-05T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-75/" target="_blank" rel="external">原文链接</a>，原文日期：2017-06-22<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="external">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="external">Cwift</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<p><em>本期作者: <a href="https://twitter.com/gregheo" target="_blank" rel="external">Greg Heo</a></em></p>
<p>我不知道你怎么样，但我还沉浸在 WWDC 的余兴里没恢复过来。</p>
<p>回到实际生活中，苹果发布了 iOS 和 Xcode 的第二个 beta 版。查看<a href="https://developer.apple.com/" target="_blank" rel="external">开发者网站</a>，Xcode 9 Beta 2 的更新说明特别提到了 Swift 4 的更新和修复。</p>
<a id="more"></a>
<blockquote>
<p><strong>赞助</strong>  </p>
<p><a href="https://www.eventbrite.com/o/plausible-labs-12068803363/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_75" target="_blank" rel="external">Advanced Swift Workshops</a>  </p>
<p>磨炼你的 Swift 技能，在 workshop 里学习一些更深入的主题。诸如 Mike Ash 这样世界知名的开发者，Swift 的专家齐聚一堂，他们将会带领你探索协议，泛型，反射和 C 语言的桥接。7 月 13 日华盛顿场，以及 7 月 24 日纽约场。  </p>
<p><a href="https://www.eventbrite.com/o/plausible-labs-12068803363/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_75" target="_blank" rel="external">eventbrite.com</a>  </p>
</blockquote>
<h2 id="社区任务"><a href="#社区任务" class="headerlink" title="社区任务"></a>社区任务</h2><p>写测试是一种探索标准库和语言特性的好方式，也能避免给项目留坑。</p>
<ul>
<li><a href="https://bugs.swift.org/browse/SR-4824" target="_blank" rel="external">SR-4824</a>：编译期添加集合类型约束的检查</li>
<li><a href="https://bugs.swift.org/browse/SR-5040" target="_blank" rel="external">SR-5040</a>：将 “Exclude” 相关的功能性检查改为单元测试</li>
</ul>
<p>可以通过 <a href="https://github.com/SwiftWeekly/swiftweekly.github.io/compare" target="_blank" rel="external">pull request</a> 或者 <a href="https://twitter.com/swiftlybrief" target="_blank" rel="external">tweet</a> 提交任务。</p>
<h2 id="Swift-Unwrapped"><a href="#Swift-Unwrapped" class="headerlink" title="Swift Unwrapped"></a>Swift Unwrapped</h2><p>在 <a href="https://spec.fm/podcasts/swift-unwrapped/72297" target="_blank" rel="external">第 16 集：Swift 的错误处理 — 发展历史</a> 里，主持人提到了 <code>rethrows</code> 和 “类型” 很多次，缅怀 Objective-C，畅谈 Swift 错误处理机制的发展史。</p>
<h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>Swift 团队的巨星 <a href="https://twitter.com/jckarter/status/875401073447419904" target="_blank" rel="external">Joe Groff</a> 要暂时离开 Twitter，Joe 在 Twitter 上一直对社区积极响应，我们希望他早日回归。</p>
<p>聊到 Joe，<a href="https://www.youtube.com/watch?v=Ntj8ab-5cvE" target="_blank" rel="external">他的前任</a> <a href="https://twitter.com/clattner_llvm/status/877341760812232704" target="_blank" rel="external">Chris Lattner</a> （你们应该都认识）要重新找工作，虽然他说自己有 <a href="https://twitter.com/clattner_llvm/status/877353276676612102" target="_blank" rel="external">七年 Swift 开发经验</a>，但我估计大部分公司还是想找一个有十年经验的 <code>¯\_(ツ)_/¯</code></p>
<p>Xcode 9 和 Swift 4 现在还在测试阶段，现在是一个回顾所有提案的好机会，看一看 <a href="https://twitter.com/ecerney" target="_blank" rel="external">Eric Cerney</a> 总结出来的 <a href="https://www.raywenderlich.com/163857/whats-new-swift-4" target="_blank" rel="external">What’s New in Swift 4?</a>。</p>
<p><a href="https://twitter.com/aciidb0mb3r/status/877653585844031493" target="_blank" rel="external">Ankit Aggarwal</a> 在 Swift 的博客里写了一篇 <a href="https://swift.org/blog/swift-package-manager-manifest-api-redesign/" target="_blank" rel="external">重新设计 Swift Package Manager 的 API</a>，讲述新的 API 设计。Swift 的 package 描述是使用 Swift 写的，新的 API / 格式现在已经更新到了最新的语言设计规范。</p>
<h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Philippe Hausler 提了一些关于 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0170-nsnumber_bridge.md" target="_blank" rel="external">SE-0170: NSNumber 与数字类型的桥接</a> 的<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170612/037499.html" target="_blank" rel="external">反馈</a>，主要是与 Float 和 Double 有关。如果你之前被浮点数的精度问题困扰过的话，可以查看<a href="https://github.com/apple/swift/commit/c358afe6555e5e32633e879f96a3664dc7a5f3dc" target="_blank" rel="external">“减少Double 和 Float 桥接的约束条件”的 commit</a>.</p>
<p>Swift 迁移工具已经 merge 到仓库里了！迁移工具的核心就是把一个文件作为输入，然后输出一份文件，包含了所有修改建议，具体细节请查看 <a href="https://github.com/apple/swift/tree/master/lib/Migrator" target="_blank" rel="external">Swift migrator library</a> 文件夹。</p>
<p>Swift 4 里大家最喜欢的 <code>Encodable</code> 协议，<a href="https://github.com/apple/swift/pull/10321" target="_blank" rel="external">添加了对于 non-strong（weak，unowned，unmanaged）属性的支持</a>。</p>
<p>Swift 问题追踪的第二个 bug 终于终于被修复了！🎉 <a href="https://bugs.swift.org/browse/SR-2" target="_blank" rel="external">SR-2</a> 和 <a href="https://bugs.swift.org/browse/SR-4196" target="_blank" rel="external">SR-4196</a> 描述了 switch 语法嵌入到 <code>#if</code> / <code>#endif</code> 里的时候不能很好地运行，<a href="https://github.com/apple/swift/pull/9457/commits/5d478bdb3b7638f5df6f0e1f4e574bececae9b80" target="_blank" rel="external">最近的一个 commit</a> 终于修复了这个问题.</p>
<p>Xcode 9 里你可以使用 <a href="https://developer.apple.com/documentation/code_diagnostics/undefined_behavior_sanitizer" target="_blank" rel="external">Undefined Behavior Sanitizer</a> 检测所有未定义行为，<a href="https://developer.apple.com/documentation/code_diagnostics/main_thread_checker" target="_blank" rel="external">Main Thread Checker</a> 利用现有的 Address Sanitizer 和 Thread Sanitizer 来检测在非主线程刷新 UI 的行为，而。这些新功能都已经 <a href="https://github.com/apple/swift-lldb/pull/211/commits" target="_blank" rel="external">merge 到 swift-lldb 里了</a>，如果你感兴趣的话可以去看源代码。</p>
<h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>作为<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/015920.html" target="_blank" rel="external">这篇去年发布的文章</a>的跟进，<a href="https://github.com/erica" target="_blank" rel="external">Erica Sadun</a>，<a href="https://github.com/AliSoftware" target="_blank" rel="external">Olivier Halligon</a>，<a href="https://github.com/calebd" target="_blank" rel="external">Caleb Davenport</a> 和 <a href="https://github.com/KingOfBrian" target="_blank" rel="external">Brian King</a> 提交了一个<a href="https://github.com/erica/swift-evolution/blob/2f2778797ceb9edc0b8acd3b68af5f81f9a95775/proposals/XXXX-role-keywords.md" target="_blank" rel="external">关于 protocol extention 函数的 “role keywords” 的提案草稿</a>。主要是讲了重写 protocol extension 里的函数时，需要加上一个关键字显式地声明这是一个 override 行为。</p>
<p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0110-distingish-single-tuple-arg.md" target="_blank" rel="external">SE-0110</a> 想要让多个参数 <code>(String, Int)</code>  的函数和单个元组 <code>(String, Int)</code> 参数区分开来。他们看起来是不是一样？就像 Doug Gregor 在邮件列表里提到的，<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037616.html" target="_blank" rel="external">这个修改会让编译过程变得有点复杂：</a></p>
<blockquote>
<p>Swift 4 已经实现了超出 SE-0110 的内容了，特别对于闭包来说，使用体验差了很多。  </p>
<p>[…]  </p>
<p>Swift 核心团队觉得这些使用体验的牺牲对于 Swift 4 来说是不可接受的。已经有好几个计划内的解决方案，给闭包提供一个更好的模型，解决用户体验的问题，但完整的设计和实现已经超出了 Swift 4 的开发目标了。所以，我们打算“回滚” SE-0110 在 Swift 4关于函数参数的修改。  </p>
</blockquote>
<p>没人可以预知未来，很难了解这些提案对于 Swift 的影响，但这也是为什么我们有 snapshots builds 和 beta 版本。至于说 <a href="http://ericasadun.com/2017/06/20/more-on-se-0110-important-fallout-please-read/" target="_blank" rel="external">SE-0110 带来的影响</a> ，我觉得我们应该全部参与进社区里，去鼓励 <a href="https://twitter.com/austinzheng/status/877054901620101120" target="_blank" rel="external">Austin Zheng</a>（SE-0110 的作者）继续坚持下去。</p>
<p>没有新的提案，但照例，更多细节请查看 <a href="https://apple.github.io/swift-evolution/" target="_blank" rel="external">Swift Evolution status page</a>。</p>
<h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>还记得 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md" target="_blank" rel="external">SE-0104: Protocol-oriented integers</a> 吗？<a href="https://github.com/xwu" target="_blank" rel="external">Xiaodi Wu</a> 最近写了一些优化实现方式的<a href="https://gist.github.com/xwu/d68baefaae9e9291d2e65bd12ad51be2" target="_blank" rel="external">想法和建议</a>。</p>
<p>Halen Wooten 开了一个新的<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/004829.html" target="_blank" rel="external">讨论</a>，讨论作为社区的成员该如何为社区贡献。我知道邮件列表的界面很粗糙，但查看<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/thread.html#4829" target="_blank" rel="external">整个讨论</a>总能有一些收获。根据<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/004833.html" target="_blank" rel="external">文档</a><a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/004835.html" target="_blank" rel="external">尽量使用增量编译节省时间</a>，我希望类似的这些技巧可以收集起来做成一份入门指南。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>学完 Swift 之后，你会希望做出什么样的语言？<a href="https://twitter.com/slava_pestov/status/875150641269571584" target="_blank" rel="external">例如这个</a>，<a href="https://twitter.com/slava_pestov/status/875153089174446080" target="_blank" rel="external">可能直接把访问权限去掉</a>? 😱</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      Swift 周报
    
    </summary>
    
      <category term="Swift 进阶" scheme="https://swift.gg/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Jesse Squires" scheme="https://swift.gg/tags/Jesse-Squires/"/>
    
  </entry>
  
  <entry>
    <title>Sprite Kit 教程：二维图形动画</title>
    <link href="https://swift.gg/2017/07/20/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/07/20/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/</id>
    <published>2017-07-19T16:00:00.000Z</published>
    <updated>2017-09-05T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/sprite-movement-actions-sprite-kit-ios-tutorial-ios10" target="_blank" rel="external">原文链接</a>，原文日期：2017-04-18<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<p>Sprite Kit 里，精灵（译者注：精灵的英文单词为 Sprite，计算机图形学，指包含于场景中的二维图像或动画）运动的机制是使用动作（actions）。将某种类型的动作添加到一个节点（node）上，Sprite Kit 自动更新位置直到动作完成。更棒的是，可以将多个动作（actions）组合起来。在本节教程中，我们将学习如何给精灵添加动作。本节教程使用 Xcode 8.3 和 iOS 10.3。<br><a id="more"></a></p>
<h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，使用 Game 模板创建工程。</p>
<p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/xcode-game-templateformat=1500w1500530564.45" alt=""></p>
<p>Product Name 使用 <strong>SpriteKitActionsTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p>
<p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/spritekit-actions-projectformat=1500w1500530565.94" alt=""></p>
<p>本节教程需要一个精灵，所以<a href="https://www.ioscreator.com/s/Apple.png" target="_blank" rel="external">下载</a>图片，将图片放到 Assets 目录中。</p>
<p>打开 <strong>GameViewController.swift</strong> 文件，按如下所示修改 <strong>viewDidLoad</strong> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">    <span class="keyword">let</span> scene = <span class="type">GameScene</span>(size: <span class="type">CGSize</span>(width:<span class="number">750</span>, height: <span class="number">1334</span>))</div><div class="line">    scene.scaleMode = .aspectFill</div><div class="line">        </div><div class="line">    <span class="keyword">let</span> skView = <span class="keyword">self</span>.view <span class="keyword">as</span>! <span class="type">SKView</span></div><div class="line">    skView.presentScene(scene)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>gameScene 场景创建好了。打开 <strong>GameScene</strong> 文件，已经定义好了 GameScene 类，删除所有的代码，然后如下所示添加 <strong>didMove(to:)</strong> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didMove</span><span class="params">(to view: SKView)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> apple = <span class="type">SKSpriteNode</span>(imageNamed: <span class="string">"Apple.png"</span>)</div><div class="line">    apple.position = <span class="type">CGPoint</span>(x: size.width/<span class="number">2</span>, y: size.height/<span class="number">2</span>)</div><div class="line">        </div><div class="line">    <span class="keyword">self</span>.addChild(apple)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将 Apple.png 图片赋给变量 apple，将其居中添加到当前场景。<strong>运行</strong>工程，可以看到苹果已经居中出现在屏幕上了。</p>
<p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/center-spritekit-simulatorformat=750w1500530566.73" alt=""></p>
<p>为了让该精灵运动，需要创建一个运动动作（move action），让该精灵运行此运动动作。将下列代码添加到 <strong>didMove(to:)</strong> 方法的尾部：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> moveBottomLeft = <span class="type">SKAction</span>.move(to: <span class="type">CGPoint</span>(x: <span class="number">100</span>,y: <span class="number">100</span>), duration:<span class="number">2.0</span>)</div><div class="line">apple.run(moveBottomLeft)</div></pre></td></tr></table></figure>
<p><strong>运行</strong>工程，精灵会从中间移动到左下角，耗时 2 秒。</p>
<p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/bottomleft-spritekit-simulatorformat=750w1500530567.46" alt=""></p>
<p><strong>moveTo:duration</strong> 方法使用的是绝对位置，想让精灵移动到相对的位置，只需要使用 moveBy 变量（To move the sprite relative of the current position you can use the moveBy variant，这句翻译不确定）。只需改变一下两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> moveRight = <span class="type">SKAction</span>.moveBy(x: <span class="number">50</span>, y:<span class="number">0</span>, duration:<span class="number">1.0</span>)</div><div class="line">apple.run(moveRight)</div></pre></td></tr></table></figure>
<p>这会让精灵向右移动 50 points。使用 sequence（连贯） 可以将将动作连起来。删除 run 这行代码，添加下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> moveBottom = <span class="type">SKAction</span>.moveBy(x: <span class="number">0</span>, y:-<span class="number">100</span>, duration:<span class="number">3.0</span>)</div><div class="line"><span class="keyword">let</span> sequence = <span class="type">SKAction</span>.sequence([moveRight, moveBottom])</div><div class="line">        </div><div class="line">apple.run(sequence)</div></pre></td></tr></table></figure>
<p><strong>运行</strong>，可以看到连贯的动作。</p>
<p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/sequence-spritekit-simulatorformat=750w1500530568.15" alt=""></p>
<p>通过调用 <strong>reversedAction</strong>，有些动作可以做反向处理，也就是说，新动作是之前旧动作的相反方向。删除 sequence 这行代码然后填写下列代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> reversedMoveBottom = moveBottom.reversed()</div><div class="line"><span class="keyword">let</span> sequence = <span class="type">SKAction</span>.sequence([moveRight, moveBottom, reversedMoveBottom])</div></pre></td></tr></table></figure>
<p><strong>运行</strong>工程，这时可以看到 moveBottom 动作后面跟着一个相反的动作。还可以让动作重复多次或者无限循环，删除 run 这行代码添加下列代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> endlessAction = <span class="type">SKAction</span>.repeatForever(sequence)</div><div class="line">apple.run(endlessAction)</div></pre></td></tr></table></figure>
<p><strong>运行</strong>工程，这些动作会无限循环。</p>
<p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/repeat-forever-spritekit-simulatorformat=750w1500530569.94" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>SpriteKitActionsTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      Sprite Kit 教程：二维图形动画
    
    </summary>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="IOSCREATOR" scheme="https://swift.gg/tags/IOSCREATOR/"/>
    
  </entry>
  
  <entry>
    <title>TableViewController 的最佳实践</title>
    <link href="https://swift.gg/2017/07/19/the-best-table-view-controller-mar-2016-edition/"/>
    <id>https://swift.gg/2017/07/19/the-best-table-view-controller-mar-2016-edition/</id>
    <published>2017-07-18T16:00:00.000Z</published>
    <updated>2017-09-05T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Dominik Hauser，<a href="http://swiftandpainless.com/the-best-table-view-controller-mar-2016-edition/" target="_blank" rel="external">原文链接</a>，原文日期：2016-03-28<br>译者：<a href="undefined">Doye</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<p>在阅读 <a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="external">obc.io关于轻量级的viewConroller相关讨论</a>之后，每隔几个月我都会反思怎样做才是TableviewController 的最佳实践，我曾经尝试过几种不同的方法包括把 datasource 和 delefate 放到一个独立的类中或者使用 MVVM 架构来对 Cell 进行定制。</p>
<p>本篇是在 2016 年我对这个问题的思索，而且我对这个方案十分满意，方案涉及到了泛型，协议，和值类型。<br><a id="more"></a></p>
<p>最主要的一部分是 TableviewController 的基类，它管理着模型数据存储的数组，还需要注册 Cell 类和实现 tableView 所需要的 datasoure 相关的函数。</p>
<p>我们的类定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>&lt;<span class="title">T</span>, <span class="title">Cell</span>: <span class="title">UITableViewCell</span> <span class="title">where</span> <span class="title">Cell</span>: <span class="title">Configurable</span>&gt;: <span class="title">UITableViewController</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个我们设计的基类是一个 <strong>UITableViewController</strong> 的子类，形参 <em>Cell<strong> 是一个遵循 </strong>Configurable<strong> 协议的 </strong>UITableViewCell*</em>，这个协议十分简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Configurable</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">config</span><span class="params">(withItem item: Any)</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 Cell 将会在 <strong>TableViewController</strong> 中注册然后塞进队列，对于这个 Cell 的 identifier 我们可以有一个私有属性的对应：</p>
<p>然后我们需要一个数组来存储要在 table View 中要展示的数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [<span class="type">T</span>]() &#123;</div><div class="line">  <span class="keyword">didSet</span> &#123;</div><div class="line">    tableView.reloadData()</div><div class="line">    <span class="keyword">if</span> tableView.numberOfRowsInSection(<span class="number">0</span>) &gt; <span class="number">0</span> &#123;</div><div class="line">      tableView.scrollToRowAtIndexPath(<span class="type">NSIndexPath</span>(forRow: <span class="number">0</span>,inSection: <span class="number">0</span>),</div><div class="line">                                       atScrollPosition: .<span class="type">Top</span>,</div><div class="line">                                       animated: <span class="literal">true</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论数据什么时候被更新，在列表视图中的 <strong>reloadData()</strong> 方法会被调用，而且整个列表视图将上滑至顶部，下面我们定义初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">init</span>() &#123; <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>) &#125;</div></pre></td></tr></table></figure>
<p>在 <strong>viewDidLoad()</strong> 之中我们对于 TableView 进行设置：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">super</span>.viewDidLoad()</div><div class="line">  tableView.registerClass(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: cellIdentifier)</div><div class="line">  tableView.rowHeight = <span class="type">UITableViewAutomaticDimension</span></div><div class="line">  tableView.estimatedRowHeight = <span class="number">60</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剩下的就是对 <strong>UITableViewDataSource</strong> 进行补全：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">  <span class="keyword">return</span> data.<span class="built_in">count</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView,</span></span></div><div class="line">                        cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line">  <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(cellIdentifier,</div><div class="line">                                                         forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></div><div class="line">  cell.config(withItem: data[indexPath.row])</div><div class="line">  <span class="keyword">return</span> cell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里一个需要注意的部分是 <strong>cell.config(withItem: data[indexPath.row])</strong> 这意味着 cell 将负责其内部各种控件展示的内容的填充。</p>
<p>这里是完整的基类的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>&lt;<span class="title">T</span>, <span class="title">Cell</span>: <span class="title">UITableViewCell</span> <span class="title">where</span> <span class="title">Cell</span>: <span class="title">Configurable</span>&gt;: <span class="title">UITableViewController</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">let</span> cellIdentifier = <span class="type">String</span>(<span class="type">Cell</span>)</div><div class="line">  <span class="keyword">var</span> data = [<span class="type">T</span>]() &#123;</div><div class="line">    <span class="keyword">didSet</span> &#123;</div><div class="line">      tableView.reloadData()</div><div class="line">      <span class="keyword">if</span> tableView.numberOfRowsInSection(<span class="number">0</span>) &gt; <span class="number">0</span> &#123;</div><div class="line">        tableView.scrollToRowAtIndexPath(<span class="type">NSIndexPath</span>(forRow: <span class="number">0</span>,inSection: <span class="number">0</span>),</div><div class="line">                                         atScrollPosition: .<span class="type">Top</span>,</div><div class="line">                                         animated: <span class="literal">true</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">init</span>() &#123; <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>) &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    tableView.registerClass(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: cellIdentifier)</div><div class="line">    tableView.rowHeight = <span class="type">UITableViewAutomaticDimension</span></div><div class="line">    tableView.estimatedRowHeight = <span class="number">60</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// MARK: - Table view data source</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> data.<span class="built_in">count</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView,</span></span></div><div class="line">                          cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(cellIdentifier,</div><div class="line">                                                           forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></div><div class="line">    cell.config(withItem: data[indexPath.row])</div><div class="line">    <span class="keyword">return</span> cell</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以利用这个基类来定义一个 TableViewController 来实现让用户输入一个字符串对于 Github 的用户来进行匹配查找：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSearchTableViewController</span>&lt;<span class="title">T</span>: <span class="title">protocol</span>&lt;<span class="title">DictCreatable</span>, <span class="title">LabelsPresentable</span>, <span class="title">UserProtocol</span>&gt;&gt;: <span class="title">TableViewController</span>&lt;<span class="title">T</span>, <span class="title">TwoLabelCell</span>&gt;, <span class="title">UISearchBarDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> searchString: <span class="type">String</span>? &#123;</div><div class="line">    <span class="keyword">didSet</span> &#123;</div><div class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> searchString = searchString <span class="keyword">where</span> searchString.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">      <span class="keyword">let</span> fetch = <span class="type">APIClient</span>&lt;<span class="type">T</span>&gt;().fetchUsers(forSearchString: searchString)</div><div class="line">      fetch &#123; (items, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> theItems = items <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">        <span class="keyword">self</span>.data = theItems.<span class="built_in">map</span> &#123; $<span class="number">0</span> &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    </div><div class="line">    title = <span class="string">"User"</span></div><div class="line">    </div><div class="line">    <span class="keyword">let</span> searchBar = <span class="type">UISearchBar</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: view.frame.size.width, height: <span class="number">40</span>))</div><div class="line">    searchBar.placeholder = <span class="string">"Github username"</span></div><div class="line">    searchBar.delegate = <span class="keyword">self</span></div><div class="line">    tableView.tableHeaderView = searchBar</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">searchBarSearchButtonClicked</span><span class="params">(searchBar: UISearchBar)</span></span> &#123;</div><div class="line">    searchBar.resignFirstResponder()</div><div class="line">    searchString = searchBar.text</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> next = <span class="type">RepositoriesTableViewController</span>&lt;<span class="type">Repository</span>&gt;()</div><div class="line">    next.username = <span class="keyword">self</span>.data[indexPath.row].name</div><div class="line">    navigationController?.pushViewController(next, animated: <span class="literal">true</span>)</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上便是一个完整的 TableViewController，大部分的代码对于 searchBar 的展示和逻辑处理，是不是很简洁？</p>
<p>我们会这样来初始化 <strong>UserSearchTableViewController</strong>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> viewController = <span class="type">UserSearchTableViewController</span>&lt;<span class="type">User</span>&gt;()</div></pre></td></tr></table></figure>
<p>最后，这里是 <strong>TwoLabelCell</strong> 我自己的实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoLabelCell</span>: <span class="title">UITableViewCell</span>, <span class="title">Configurable</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> nameLabel: <span class="type">UILabel</span></div><div class="line">  <span class="keyword">let</span> descriptionLabel: <span class="type">UILabel</span></div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCellStyle</span>, reuseIdentifier: <span class="type">String</span>?) &#123;</div><div class="line">    nameLabel = <span class="type">UILabel</span>()</div><div class="line">    nameLabel.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleHeadline</span>)</div><div class="line">    </div><div class="line">    descriptionLabel = <span class="type">UILabel</span>()</div><div class="line">    descriptionLabel.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleSubheadline</span>)</div><div class="line">    descriptionLabel.numberOfLines = <span class="number">2</span></div><div class="line">    </div><div class="line">    <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>(arrangedSubviews: [nameLabel, descriptionLabel])</div><div class="line">    stackView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></div><div class="line">    stackView.axis = .<span class="type">Vertical</span></div><div class="line">    </div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</div><div class="line">    </div><div class="line">    addSubview(stackView)</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> views = [<span class="string">"stackView"</span>: stackView]</div><div class="line">    <span class="keyword">var</span> layoutConstraints = [<span class="type">NSLayoutConstraint</span>]()</div><div class="line">    layoutConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"|-[stackView]-|"</span>, options: [], metrics: <span class="literal">nil</span>, views: views)</div><div class="line">    layoutConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"V:|-[stackView]-|"</span>, options: [], metrics: <span class="literal">nil</span>, views: views)</div><div class="line">    <span class="type">NSLayoutConstraint</span>.activateConstraints(layoutConstraints)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">    <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">config</span><span class="params">(withItem item: Any)</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> item = item <span class="keyword">as</span>? <span class="type">LabelsPresentable</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">    <span class="keyword">let</span> texts = item.texts</div><div class="line">    <span class="keyword">if</span> texts.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">      nameLabel.text = texts[<span class="number">0</span>]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> texts.<span class="built_in">count</span> &gt; <span class="number">1</span> &amp;&amp; texts[<span class="number">1</span>].characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">      descriptionLabel.text = texts[<span class="number">1</span>]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<a href="https://github.com/dasdom/TableViewMarch2016" target="_blank" rel="external">Github</a>有源码还有另一个遵循类似架构的 TableViewController 实例</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      TableViewController的最佳实践
    
    </summary>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift And Painless" scheme="https://swift.gg/tags/Swift-And-Painless/"/>
    
  </entry>
  
  <entry>
    <title>如何检测摇一摇手势</title>
    <link href="https://swift.gg/2017/07/18/detect-shake-gestures-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/07/18/detect-shake-gestures-ios-tutorial-ios10/</id>
    <published>2017-07-17T16:00:00.000Z</published>
    <updated>2017-09-05T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/detect-shake-gestures-ios-tutorial-ios10" target="_blank" rel="external">原文链接</a>，原文日期：2017-04-18<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<p>iOS 设备可以检测摇一摇手势，在本节教程中，我们将学习如何检测摇一摇手势，检测到该手势后，更新 label 的文案。本节教程使用的是 Xcode 8.3 和 iOS 10.3。<br><a id="more"></a></p>
<h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，创建一个 Single View Application。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/single-view-xcode-templateformat=1500w1500341429.27" alt=""></p>
<p>Product Name 使用 <strong>IOS10ShakeGestureTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-projectformat=1500w1500341431.78" alt=""></p>
<p>打开 <strong>Storyboard</strong>，从 Object Library 中拖拽一个 Label 控件放到 View Controller 上，双击 Label 控件将文案修改为 <em>“Shake me”</em>。选中该 Label，点击 Auto Layout 的 Align 按钮。选中 “Horizontally in Container”，点击 “Add 1 Constraint”。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/auto-layout-horizontally-in-containerformat=750w1500341433.06" alt=""></p>
<p>选中 Label，点击 Auto Layout 的 Pin 按钮，选中上边距约束线，点击 “Add 1 Constraint”。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/auto-layout-pin-to-topformat=750w1500341433.89" alt=""></p>
<p>Storyboard 看起来应如下图所示。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-storyboardformat=1000w1500341434.83" alt=""></p>
<p>打开 Assistant Editor，确保 <strong>ViewController.swift</strong> 可见。按住 Control 键，将 Label 拖拽到 ViewController 类下，创建下图的 Outlet。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-label-outletformat=750w1500341435.62" alt=""></p>
<p>打开 ViewController.swift 文件，首先要让 View Controller 回应点击事件，可以通过 ViewController FirstResponder 实现，添加下列方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">becomeFirstResponder</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，要想检测摇一摇手势，添加 <strong>motionEnded(_:with:)</strong> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">motionEnded</span><span class="params">(<span class="number">_</span> motion: UIEventSubtype, with event: UIEvent?)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> motion == .motionShake &#123;</div><div class="line">        shakeLabel.text = <span class="string">"Shaken, not stirred"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果确实是一个 Shake Gesture（摇一摇），那么 Label 的文案就会更新。运行工程，摇一摇测试机。可以点击 iOS 模拟器菜单栏 Hardware 选项下的 Shake Gesture 来摇一摇。</p>
<p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-simulatorformat=750w1500341436.36" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>IOS10ShakeGestureTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      如何检测摇一摇手势
    
    </summary>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="IOSCREATOR" scheme="https://swift.gg/tags/IOSCREATOR/"/>
    
  </entry>
  
  <entry>
    <title>iOS 教程：属性字符串</title>
    <link href="https://swift.gg/2017/07/17/attributed-strings-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/07/17/attributed-strings-ios-tutorial-ios10/</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-09-05T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/attributed-strings-ios-tutorial-ios10" target="_blank" rel="external">原文链接</a>，原文日期：2017-04-04<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>译者注：本文是之前一篇文章的更新版本，<a href="https://www.ioscreator.com/tutorials/attributed-strings-tutorial-ios8-swift" target="_blank" rel="external">旧文链接</a>，旧文使用的 Swift 版本不是 3.0，本文更新了代码，升级到了 Swift 3.0。</p>
</blockquote>
<p>属性字符串（Attributed Strings）可以为文本赋予各种各样的属性，还能一次给（部分）文本赋值多个属性。在本节教程中，将学会给 label 文本里的每个单词各设置不一样的样式。本节教程使用的是 Xcode 8 和 iOS 10。<br><a id="more"></a></p>
<p>打开 Xcode，创建一个 Single View Application。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/single-view-xcode-templateformat=1500w1500254455.03" alt=""></p>
<p>Product Name 使用 <strong>IOS10AttributedStringsTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/attributed-strings-projectformat=1500w1500254455.98" alt=""></p>
<p>打开 <strong>Storyboard</strong>，从 Object-Library（控件库）中拖拽一个 Label 控件到主界面，点击 Storyboard 右下角 Auto Layout 的 Align 按钮，添加下图所示约束，点击 “Add 1 Constraint”。。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/auto-layout-horizontally-in-containerformat=750w1500254456.86" alt=""></p>
<p>点击 Auto Layout 的 Pin 按钮，添加如下图所示约束，点击 “Add 1 Constraint”。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/auto-layout-pin--to-topformat=750w1500254457.69" alt=""></p>
<p>点击 Assistant Editor，确保 <strong>ViewController.swift</strong> 文件可见。按住 Control 键，将 Label 控件拖拽到 ViewController 类下面，创建下列 Outlet 连接。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/attributes-label-outletformat=750w1500254459.19" alt=""></p>
<p>打开 <strong>ViewController.swift</strong> 文件，如下所示对 <strong>viewDidLoad</strong> 方法进行修改。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">    <span class="comment">// 1</span></div><div class="line">    <span class="keyword">let</span> string = <span class="string">"Testing Attributed Strings"</span></div><div class="line">    <span class="keyword">let</span> attributedString = <span class="type">NSMutableAttributedString</span>(string: string)</div><div class="line">        </div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">let</span> firstAttributes:[<span class="type">String</span>:<span class="type">Any</span>] = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.blue, <span class="type">NSBackgroundColorAttributeName</span>: <span class="type">UIColor</span>.yellow, <span class="type">NSUnderlineStyleAttributeName</span>: <span class="number">1</span>]</div><div class="line">    <span class="keyword">let</span> secondAttributes:[<span class="type">String</span>:<span class="type">Any</span>] = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.red, <span class="type">NSBackgroundColorAttributeName</span>: <span class="type">UIColor</span>.blue, <span class="type">NSStrikethroughStyleAttributeName</span>: <span class="number">1</span>]</div><div class="line">    <span class="keyword">let</span> thirdAttributes:[<span class="type">String</span>:<span class="type">Any</span>] = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.green, <span class="type">NSBackgroundColorAttributeName</span>: <span class="type">UIColor</span>.black, <span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">40</span>)]</div><div class="line">        </div><div class="line">    <span class="comment">// 3</span></div><div class="line">    attributedString.addAttributes(firstAttributes, range: <span class="type">NSRange</span>(location: <span class="number">0</span>, length: <span class="number">8</span>))</div><div class="line">    attributedString.addAttributes(secondAttributes, range: <span class="type">NSRange</span>(location: <span class="number">8</span>, length: <span class="number">11</span>))</div><div class="line">    attributedString.addAttributes(thirdAttributes, range: <span class="type">NSRange</span>(location: <span class="number">19</span>, length: <span class="number">7</span>))</div><div class="line">        </div><div class="line">    <span class="comment">// 4</span></div><div class="line">    attributedLabel.attributedText = attributedString</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建一个普通的字符串，将会转换成多种属性字符串。</li>
<li>创建见 3 个字典，存储属性的键和值。</li>
<li>将属性添加到 <code>attributedString</code> 对象中。</li>
<li>最后，将属性字符串赋值给 Label。</li>
</ol>
<p><strong>运行</strong>程序，属性字符串的实现效果如下。</p>
<p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/attributed-strings-simulatorformat=750w1500254459.94" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>IOS10AttributedStringsTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      iOS 教程：属性字符串
    
    </summary>
    
      <category term="iOS" scheme="https://swift.gg/categories/iOS/"/>
    
      <category term="Swift 入门" scheme="https://swift.gg/categories/iOS/Swift-%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="IOSCREATOR" scheme="https://swift.gg/tags/IOSCREATOR/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #74</title>
    <link href="https://swift.gg/2017/07/16/swift_weekly_issue_74/"/>
    <id>https://swift.gg/2017/07/16/swift_weekly_issue_74/</id>
    <published>2017-07-15T16:00:00.000Z</published>
    <updated>2017-09-05T02:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-74/" target="_blank" rel="external">原文链接</a>，原文日期：2017-06-15<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="external">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="external">Cwift</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<p>WWDC 已经过去一周了，你有大概了解你的代码要怎么迁移到 Swift 4 吗？我最先接触到的是一堆警告，提示有多余的协议遵守，查证得知<a href="https://bugs.swift.org/browse/SR-5153" target="_blank" rel="external">这是个 bug</a>。但说回来，比起去年我花了两个星期迁移到 Swift 3 来说，这次的升级已经好很多了。</p>
<p>而且，牢记 Swift 3.2 版本实际是在 Swift 3 兼容模式下运行 Swift 4 的编译器（<code>-swift-version 3</code>，通过这届 WWDC，我理解了很多东西）。当你在浏览  <a href="https://bugs.swift.org/" target="_blank" rel="external">bugs.swift.org</a>  时记住这一点也会很有帮助。<br><a id="more"></a></p>
<blockquote>
<p>想要赞助 Swift Weekly Brief 吗? <a href="https://swiftweekly.github.io/sponsorship/" target="_blank" rel="external">点击此处了解更多</a>  </p>
</blockquote>
<h2 id="社区任务"><a href="#社区任务" class="headerlink" title="社区任务"></a>社区任务</h2><ul>
<li>SR-4866：Stack overflow: 空括号表达式语法分析错误</li>
<li>SR-4830：编译器的 log 加上颜色区分</li>
</ul>
<p>可以通过 <a href="https://github.com/SwiftWeekly/swiftweekly.github.io/compare" target="_blank" rel="external">pull request</a> 或者 <a href="https://twitter.com/swiftlybrief" target="_blank" rel="external">tweet</a> 提交任务。</p>
<h2 id="Swift-扩展"><a href="#Swift-扩展" class="headerlink" title="Swift 扩展"></a>Swift 扩展</h2><p>第 15 集： <a href="https://spec.fm/podcasts/swift-unwrapped/70809" target="_blank" rel="external">Swift 更新内容， Part 2</a></p>
<p>JP Simard 和 Jesse Squires 继续讨论 Swift 的更新内容</p>
<h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>John Sundell 写了篇<a href="https://www.swiftbysundell.com/posts/exploring-the-new-string-api-in-swift-4" target="_blank" rel="external">关于 Swift 4 新的字符串 API 的文章</a>，这篇文章包括了很多实用的例子，展示了如何在 Swift 日常开发中使用新的字符串 API。</p>
<p>Slava Pestov 在 Twitter <a href="https://twitter.com/slava_pestov/status/873751462630760449" target="_blank" rel="external">提了一个谜题</a>：<code>print(type{ })</code>会输出什么？为什么？（<a href="https://twitter.com/nicklockwood/status/873796388768841728" target="_blank" rel="external">答案在这里</a>）</p>
<p>Slava 也<a href="https://twitter.com/slava_pestov/status/873744097353256961" target="_blank" rel="external">强调了</a> Swift 编译器团队，自从 2014 年的<a href="https://github.com/apple/swift/commit/d8ce0b80cbb7732cb32b245f9fadd47c11a4b163" target="_blank" rel="external">这一个 commit</a> 开始已经修复了<strong>超过 5500 个 bug 了</strong>。</p>
<h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Slava Pestove <a href="https://github.com/apple/swift/pull/10195" target="_blank" rel="external">修复了一个 Swift 3.1 和 Swift 4 的 bug</a>， 当一个类的父类初始化方法是一个 Objective-C 里定义的类工厂方法时，Swift 可能会报错提示 <code>self.init</code> 会让 self 逃逸，所以不能通过编译。</p>
<p>Devin Coughlin <a href="https://github.com/apple/swift/pull/10191" target="_blank" rel="external">加入了对于 inout 的静态分析</a>，加强 Swift 4 的内存安全特性。</p>
<p>Nate Cook 给新的 Swift 4 的 stdlib <a href="https://github.com/apple/swift/pull/10229" target="_blank" rel="external">补充和修改了一大堆文档内容</a>。</p>
<p>Dave Abrahams 开了一个新的 PR 以便<a href="https://github.com/apple/swift/pull/10223" target="_blank" rel="external">改进 String 的性能</a>。</p>
<p>Roman Levenstein 减少了标准库的代码体积，大概 5-6% 左右，然后从主分支 <a href="https://github.com/apple/swift/pull/10263" target="_blank" rel="external">cherry-pick 了一个 patch</a> 到 Swift 4 分支。</p>
<h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>这周没有提案的更新！具体的可以到<a href="[Swift Evolution]https://apple.github.io/swift-evolution/">这里</a>查看。</p>
<h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>本周的讨论围绕 Swift-Evolution 邮件列表应该扮演什么角色的话题展开，因为邮件列表的责任是展示一些有帮助的讨论内容以及提案的审核结果，鉴于邮件主题是由 Swift 发布周期/阶段引导的，什么时候才应该把一个想法带入严肃的讨论中（也许这个想法跟当前开发阶段的主题毫无联系）很值得讨论。</p>
<p>Ted Kremenek 这么<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170612/037339.html" target="_blank" rel="external">写到</a>：</p>
<blockquote>
<p>各位：这是一个很好的讨论，很感谢大家对于这件事情的思考。这其实是 Ben Cohen 和我私下聊完之后，我们打算带着核心团队一起讨论这件事。  </p>
<p>[…]  </p>
<p>根据 Xiaodi 的观察，evolution 的列表对于推进当前开发目标内的提案的作用是最大的。有很多不同的主题大家想讨论，而且很明显所有人都有点焦虑，想要都参与但人的精力是有限的，很难每一个主题都深入地参与进去。也许把这些移到一个讨论版（我们一直想做，但一直没有精力做的一个东西），提供一个非正式的讨论社区，就像 Xiaodi 提到的 Swift.org 论坛那样的东西，但要把开发目标内外主题明确分开，让大家可以去讨论他们感兴趣的主题。  </p>
<p>[…]  </p>
</blockquote>
<p>如果你对于 Swift Evolution 的发展感兴趣的话，那可以考虑深入阅读，看看这个过程是如何围绕着“开发目标内”呈现有建设性的讨论，以及该如何处理那些不在“当前开发目标内”的想法。</p>
<p>Chris Lattner 在回顾 <a href="https://lists.swift.org/pipermail/swift-evolution//Week-of-Mon-20170612/037514.html" target="_blank" rel="external">SE-0110</a> 的一个<a href="https://lists.swift.org/pipermail/swift-evolution//Week-of-Mon-20170612/037514.html" target="_blank" rel="external">长期讨论</a>里做了回应：</p>
<blockquote>
<p>核心团队今天讨论了这件事情，大家一致认为需要为了重新获得语法的便捷性而做出改变。 讨论之后大家更倾向于（至少）保留闭包里使用括号展开元组的形式，但这件事情还需要更多的讨论。  </p>
<p>说一个题外话，给元组里面的元素命名的形式以后某个时间点应该会被取消掉。不仔细看的话，你能分清下面声明了哪个变量吗？：  </p>
<p><code>let (a : Int, b : Float) = foo()</code>  </p>
<p>?  </p>
</blockquote>
<p>我们在这里回顾一下<a href="https://swiftweekly.github.io/issue-72/" target="_blank" rel="external">第 72 期的周报</a>。在 Swift 4 里，n 个元素的元组已经不会在闭包里拓展为 n 个参数了（元组展平行为）。这意味着闭包将会接收一个元组类型的参数，而你需要手动去把它们展开。这很明显就不符合直觉，开发体验也很差。很高兴看到核心团队重新考虑这个决定！谁说 Swift-Evolution 不好的？😉</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有关 Swift 2 的<a href="https://twitter.com/jckarter/status/874397984712163331" target="_blank" rel="external">一些感想</a>🍺。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      Swift 周报
    
    </summary>
    
      <category term="Swift 进阶" scheme="https://swift.gg/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Jesse Squires" scheme="https://swift.gg/tags/Jesse-Squires/"/>
    
  </entry>
  
  <entry>
    <title>Swift 3.0 下 Notifications 与 userInfo 的使用</title>
    <link href="https://swift.gg/2017/06/13/notifications-and-userinfo-with-swift-3-0/"/>
    <id>https://swift.gg/2017/06/13/notifications-and-userinfo-with-swift-3-0/</id>
    <published>2017-06-12T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Joe，<a href="http://dev.iachieved.it/iachievedit/notifications-and-userinfo-with-swift-3-0/" target="_blank" rel="external">原文链接</a>，原文日期：2016-09-17<br>译者：<a href="undefined">Tony Han</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 3.0 版本给 Swift 语言带来了相当多的改变，包括去掉 Foundation 框架中 NS 前缀的 <a href="https://developer.apple.com/videos/play/wwdc2016/403/" target="_blank" rel="external">Great Renaming</a>。<code>NSThread</code> 被简写作 <code>Thread</code>，<code>NSData</code> 被简写作 <code>Data</code>，就是这个意思。</p>
<a id="more"></a>
<p>这意味着，需要更新通过 <code>userInfo</code> 使用 <code>NSNotificationCenter</code>，哦不，<code>NotificationCenter</code> 的用法。这是 Swift 2 和 Swift 3 之间的巨大差别。</p>
<p>现在获取默认的 <code>NotificationCenter</code> 的方法已经变成 <code>let nc = NotificationCenter.default</code>。另外，当接收到通知时，使用选择器的模型已经改变为指定要执行的代码块或函数。</p>
<p>例如，在 Swift 2 中这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> nc = <span class="type">NSNotificationCenter</span>.defaultCenter()</div><div class="line">nc.addObserver(<span class="keyword">self</span>, </div><div class="line">               selector: #selector(<span class="type">ViewController</span>.catchNotification),</div><div class="line">               name: <span class="string">"MyNotification"</span>, </div><div class="line">               object: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>而 Swift 3 中要这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span> <span class="comment">// 注意：default 是属性，不是方法调用</span></div><div class="line">nc.addObserver(forName:<span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>),</div><div class="line">               object:<span class="literal">nil</span>, queue:<span class="literal">nil</span>,</div><div class="line">               using:catchNotification)</div></pre></td></tr></table></figure>
<p>上面的例子设置了通知中心将 <code>MyNotification</code> 通知传递给具有 <code>(Notification) -&gt; Void</code> 方法签名的 <code>catchNotification</code> 函数。或者也可以使用闭包调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span> <span class="comment">// 注意：default 是属性，不是方法调用</span></div><div class="line">nc.addObserver(forName:<span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>),</div><div class="line">               object:<span class="literal">nil</span>, queue:<span class="literal">nil</span>) &#123;</div><div class="line">  notification <span class="keyword">in</span></div><div class="line">  <span class="comment">// 处理通知</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h4><p>下面看看如何发送通知。Swift 2.0 中的 <code>postNotificationName</code> 方法在 Swift 3.0 中已经被替换为 <code>post</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span></div><div class="line">nc.post(name:<span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>),</div><div class="line">        object: <span class="literal">nil</span>,</div><div class="line">        userInfo: [<span class="string">"message"</span>:<span class="string">"Hello there!"</span>, <span class="string">"date"</span>:<span class="type">Date</span>()])</div></pre></td></tr></table></figure>
<p><code>userInfo</code> 使用 <code>[AnyHashable：Any]?</code> 作为参数，这在 Swift 中被称作字典字面量。注意，<code>userInfo</code> 的值不需要统一类型（即 <code>Any</code> 所占位置）；这里发送了一个 <code>String</code> 类型和一个 <code>Date</code> 类型。</p>
<h4 id="处理通知"><a href="#处理通知" class="headerlink" title="处理通知"></a>处理通知</h4><p><code>guard</code> 语法用来从 <code>userInfo</code> 中解包并验证期望数据，这是一个很不错的方式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">catchNotification</span><span class="params">(notification:Notification)</span></span> -&gt; <span class="type">Void</span> &#123;</div><div class="line">  <span class="built_in">print</span>(<span class="string">"Catch notification"</span>)</div><div class="line">  </div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> userInfo = notification.userInfo,</div><div class="line">        <span class="keyword">let</span> message  = userInfo[<span class="string">"message"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</div><div class="line">        <span class="keyword">let</span> date     = userInfo[<span class="string">"date"</span>]    <span class="keyword">as</span>? <span class="type">Date</span> <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"No userInfo found in notification"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"Notification!"</span>,</div><div class="line">                                message:<span class="string">"\(message) received at \(date)"</span>,</div><div class="line">                                preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</div><div class="line">  alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</div><div class="line">  <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要验证 <code>guard</code> 的作用，可以使用 <code>String</code> 类型或其他的对象类型代替 <code>Date()</code> 来调用 <code>post</code> 方法。可以在控制台的输出中看到 <code>No userInfo found in notification</code>。</p>
<h4 id="实例源码"><a href="#实例源码" class="headerlink" title="实例源码"></a>实例源码</h4><p>可以在一个简单的 iOS 项目中尝试使用上面的代码。创建 <strong>Single View Application</strong> 项目，并且使用以下内容替换 <code>ViewController.swift</code> 中的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">let</span> myNotification = <span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span></div><div class="line">    nc.addObserver(forName:myNotification, object:<span class="literal">nil</span>, queue:<span class="literal">nil</span>, using:catchNotification)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidAppear(animated)</div><div class="line">    <span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span></div><div class="line">    nc.post(name:myNotification,</div><div class="line">            object: <span class="literal">nil</span>,</div><div class="line">            userInfo:[<span class="string">"message"</span>:<span class="string">"Hello there!"</span>, <span class="string">"date"</span>:<span class="type">Date</span>()])</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">catchNotification</span><span class="params">(notification:Notification)</span></span> -&gt; <span class="type">Void</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Catch notification"</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> userInfo = notification.userInfo,</div><div class="line">          <span class="keyword">let</span> message  = userInfo[<span class="string">"message"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</div><div class="line">          <span class="keyword">let</span> date     = userInfo[<span class="string">"date"</span>]    <span class="keyword">as</span>? <span class="type">Date</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"No userInfo found in notification"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"Notification!"</span>,</div><div class="line">                                  message:<span class="string">"\(message) received at \(date)"</span>,</div><div class="line">                                  preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</div><div class="line">    alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</div><div class="line">    <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li><code>Notification</code> 的“名字”不再是字符串类型，而是 <code>Notification.Name</code> 类型，因此在声明通知的时候使用 <code>let myNotification = Notification.Name(rawValue:&quot;MyNotification&quot;)</code>。这样可以允许我们在任何需要使用 <code>Notification.Name</code> 的地方来使用 <code>myNotification</code>，比如，<code>NotificationCenter.addObserver</code> 和 <code>NotificationCenter.post</code> 方法。</li>
<li>推荐使用分开的 <code>catchNotification</code> 方法而不是纠缠在一起的代码块。</li>
</ul>
<p>就是这样，简洁而有效！</p>
<h4 id="评论内容"><a href="#评论内容" class="headerlink" title="评论内容"></a>评论内容</h4><p>声明并使用通知的改进：</p>
<p>1) 首先声明通知名称：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Notification</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">MyNotification</span> = <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">"Notification.MyApp.MyNotification"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2) 使用通知名称发送通知：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: <span class="type">Notification</span>.<span class="type">MyApp</span>.<span class="type">MyNotification</span>, object: <span class="keyword">self</span>)</div></pre></td></tr></table></figure>
<p>3) 监听通知：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">Notification</span>.<span class="type">MyApp</span>.<span class="type">MyNotification</span>, object: <span class="literal">nil</span>, queue: <span class="type">OperationQueue</span>.main) &#123;</div><div class="line">      pNotification <span class="keyword">in</span></div><div class="line"> </div><div class="line">  <span class="comment">// Your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Joe，&lt;a href=&quot;http://dev.iachieved.it/iachievedit/notifications-and-userinfo-with-swift-3-0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-09-17&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;Tony Han&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 3.0 版本给 Swift 语言带来了相当多的改变，包括去掉 Foundation 框架中 NS 前缀的 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2016/403/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Great Renaming&lt;/a&gt;。&lt;code&gt;NSThread&lt;/code&gt; 被简写作 &lt;code&gt;Thread&lt;/code&gt;，&lt;code&gt;NSData&lt;/code&gt; 被简写作 &lt;code&gt;Data&lt;/code&gt;，就是这个意思。&lt;/p&gt;
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #73</title>
    <link href="https://swift.gg/2017/06/10/issue-73/"/>
    <id>https://swift.gg/2017/06/10/issue-73/</id>
    <published>2017-06-09T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-73/" target="_blank" rel="external">原文链接</a>，原文日期：2017-06-09<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="external">四娘</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>这周的事情很多！今天是 <a href="https://developer.apple.com/videos/wwdc2017/" target="_blank" rel="external">WWDC 2017</a> 的最后一天，Swift 4 随着 <a href="https://developer.apple.com/xcode/" target="_blank" rel="external">Xcode 9</a>，一起放出了开发者公测版。Xcode 和 Swift 都有好几个重大的改进和新的功能 — 这个版本真的很棒。整个<a href="https://twitter.com/ericasadun/status/871819962888802304" target="_blank" rel="external">社区</a>的<a href="https://twitter.com/SmileyKeith/status/871852588844556288" target="_blank" rel="external">反响</a><a href="https://twitter.com/fpillet/status/871987276187828224" target="_blank" rel="external">都</a><a href="https://twitter.com/chriseidhof/status/873066951739703296" target="_blank" rel="external">很</a><a href="https://twitter.com/tonyarnold/status/873017116298846208" target="_blank" rel="external">正</a><a href="https://twitter.com/ayanonagon/status/871850052498489344" target="_blank" rel="external">面</a>。恭喜 Apple 的 Xcode, Swift 和开发工具组！</p>
<a id="more"></a>
<blockquote>
<p>想要赞助 Swift Weekly Brief 吗？<a href="https://swiftweekly.github.io/sponsorship/" target="_blank" rel="external">点击此处了解更多</a>  </p>
</blockquote>
<h2 id="Swift-解包"><a href="#Swift-解包" class="headerlink" title="Swift 解包"></a>Swift 解包</h2><p>第 14 集：<a href="https://spec.fm/podcasts/swift-unwrapped/70808" target="_blank" rel="external">Swift 更新内容，Part 1</a></p>
<p>我们讨论了 Swift 4 里的一些新功能和改进。</p>
<h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>Apple <a href="https://www.apple.com/newsroom/2017/06/swift-playgrounds-expands-coding-education-to-robots-drones-and-musical-instruments/" target="_blank" rel="external">宣布</a> Swift Playgrounds 已经支持对玩具机器人和无人机的编程了。他们正与多家公司合作，包括 Lego, Sphero 等一众公司。 这件事情很棒很好玩，你可以在这里查看<a href="https://www.youtube.com/watch?v=v7926MzvXOQ" target="_blank" rel="external">相关视频</a>。</p>
<p>Erica Sadun 的新书 <a href="http://ericasadun.com/2017/06/01/swift-style-wwdc-sale/" target="_blank" rel="external">Swift Style</a> 这周正式开始销售。</p>
<p>objc.io 已经放出了他们的新书，<a href="https://www.objc.io/blog/2017/06/02/optimizing-collections/" target="_blank" rel="external">Optimizing Collections</a>。作者 <a href="https://twitter.com/lorentey" target="_blank" rel="external">Károly Lőrentey</a> 在这本书里介绍了如何使用 Swift 编写高效的自定义集合类型。</p>
<p><a href="https://developer.apple.com/news/?id=06052017d" target="_blank" rel="external">Xcode 9 beta 以及新的 SDK</a> 全都放出来啦！</p>
<h2 id="WWDC-里关于-Swift-的视频"><a href="#WWDC-里关于-Swift-的视频" class="headerlink" title="WWDC 里关于 Swift 的视频"></a>WWDC 里关于 Swift 的视频</h2><ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/402/" target="_blank" rel="external">What’s new in Swift</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/408/" target="_blank" rel="external">What’s new in Swift Playgrounds</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/416/" target="_blank" rel="external">Teaching with Swift Playgrounds</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/212/" target="_blank" rel="external">What’s new in Foundation</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/407/" target="_blank" rel="external">Understanding undefined behavior</a></li>
</ul>
<h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Rober Widmann <a href="https://github.com/apple/swift/pull/10175" target="_blank" rel="external">合并了修改</a>，使用了 Xcode 新的未定义行为检测器，来修复了一些未定义的行为。</p>
<p>Roman Levenstein <a href="https://github.com/apple/swift/pull/10096" target="_blank" rel="external">做了一些小调整</a>，让标准库的代码体积减少了 1.5% ！！！</p>
<p>Swift 服务端 API 工作组发布了一个<a href="https://github.com/swift-server/http" target="_blank" rel="external">新的 repo</a>，主要是关于跨平台 HTTP API 的开发。</p>
<p>Ben Cohen 向 <code>swift-4.0 分支</code><a href="https://github.com/apple/swift/pull/10161" target="_blank" rel="external">发起了一个合并的请求</a>，用于提高 substring 比较的性能。Nate Cook <a href="https://github.com/apple/swift/pull/10156" target="_blank" rel="external">也发起了一个提高字典效率的合并请求</a>，现在已经有<a href="https://github.com/apple/swift/pulls?utf8=✓&amp;q=is%3Apr%20%5B4.0%5D%20in%3Atitle" target="_blank" rel="external">好几个 Swift 4 的合并请求</a> 了，希望那些已经请求完成的合并请求可以尽快通过。我们应该可以在接下来的 beta 版里看到这些改进。</p>
<p>Slava Pestov <a href="https://github.com/apple/swift/pull/10162" target="_blank" rel="external">修复</a>了几个 Bug。👏</p>
<h2 id="正在-review-的提案"><a href="#正在-review-的提案" class="headerlink" title="正在 review 的提案"></a>正在 review 的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="external">SE-0180</a>：字符串索引类型统一，Dave Abrahams，<a href="https://lists.swift.org/pipermail/swift-evolution-announce/2017-June/000384.html" target="_blank" rel="external">正在 review</a></p>
<blockquote>
<p>现在 <code>String</code> 跟它的 <code>CharacterView</code> 共用一个 <code>Index</code> 类型，但 <code>UTF8View</code>，  <code>UTF16View</code> 以及 <code>UnicodeScalarView</code> 就不是了。这个提案重新定义了这几个类型的 <code>Index</code> 类型，让它们跟 <code>String</code> 保持一致。并且暴露一个公开的 <code>encodedOffset</code> 属性和构造器，用于序列化和反序列化 <code>String</code> 和 <code>Substring</code> 的索引值。  </p>
<p>[…]</p>
<p>这样的结果就是很多 API 都无法从原本的设计中获益，通常来说，一个 view 的索引如果可以在另一个 view 有对应的索引值的话，这些索引值的转换都应该在内部完成，而不是像现在这样需要写很多不必要的代码。 </p>
<p>[…]  </p>
<p>所有 String 的 view 都会使用同一种 Index 类型 (<code>String.Index</code>)，这样索引值就可以在内部进行转换，而不用显式地去完成。  </p>
<p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="external">查看原文…</a>  </p>
</blockquote>
<h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>Ted Kremenek 发布了<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170605/004751.html" target="_blank" rel="external">一个公告</a>，关于即将开源的重构工具，以及其它在 WWDC 公布的事情：</p>
<blockquote>
<p>今天下午在 WWDC 上，我们发布了 Xcode 9 里新的重构功能(支持 Swift，C，Objective-C 和 C++)。我们同时宣布将会把这个引擎的核心代码开源出来，包括 Xcode 编译时才会索引的新功能。 </p>
<p>大概会在接下来的几个星期里, 我们将会分阶段把这些代码发布出来： </p>
<ul>
<li><p>关于 Swift 的重构功能，我们还需要做一些收尾工作，例如文档的编写，我们想在发布之前完成。 Argyrios Kyrtzidis 和他的团队负责处理这个计划。  </p>
</li>
<li><p>关于 C/C++/Objective-C 的重构功能，我们想和 LLVM 社区一起完成然后并入 LLVM。第一阶段应该会在 swift-clang 的 repo 里完成，但是他们想做的不只是这些。Duncan Exon Smith 和他的团队负责这个计划。  </p>
</li>
<li><p>我们也会开源编译器对于编译时索引的支持，包括了 Clang 和 Swift。Argyrios 和他的团队负责推进这件事。关于 Clang 的改变他们应该会在也会在 swift-clang 上完成，然后跟 LLVM 社区讨论如何将他们并入 Clang 里。  </p>
</li>
<li><p>最后，我们将会把 Swift 迁移工具剩余的部分开源出来。Argyrios 和他的团队负责推进这件事情，这些修改只会在 Swift 仓库里完成。  </p>
</li>
</ul>
<p>和之前一样，我们还需要完成 Swift 与 Apple 最新的 SDK 的桥接工作。希望可以在下周之前完成，之后我们就会暂时关闭仓库的 commit 权限。相关的细节之后会通过邮件公布。在此之前， Swift.org 的可下载的工具链都可以跟 Xcode 8.3.2 交互。在这之后, 我们可下载的工具链就主要会面向 Xcode 9 beta。这件事情很必要，因为之后最上层的 API 会依赖于最新的 SDK。  </p>
</blockquote>
<p>Rick Ballard 发了一个关于 Swift 4 包管理器的<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170605/037002.html" target="_blank" rel="external">公告</a>:</p>
<blockquote>
<p>Hello, Swift Pacakage Manager 的社区。  </p>
<p>我想要汇报一下 Swift 4 里 SwiftPM 的开发进度。我们已经在这个春季实现了一系列的 evolution 提案： </p>
<ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0152-package-manager-tools-version.md" target="_blank" rel="external">SE-0152</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0158-package-manager-manifest-api-redesign.md" target="_blank" rel="external">SE-0158</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0151-package-manager-swift-language-compatibility-version.md" target="_blank" rel="external">SE-0151</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0146-package-manager-product-definitions.md" target="_blank" rel="external">SE-0146</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0175-package-manager-revised-dependency-resolution.md" target="_blank" rel="external">SE-0175</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0150-package-manager-branch-support.md" target="_blank" rel="external">SE-0150</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0162-package-manager-custom-target-layouts.md" target="_blank" rel="external">SE-0162</a> […]  </li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0149-package-manager-top-of-tree.md" target="_blank" rel="external">SE-0149</a> […]  </li>
</ul>
<p>除了这些提案，我们还实现了一些重大的改进： </p>
<ul>
<li><p>在 macOS 上，包的交互和包的编译现在都沙盒化了，能够减轻恶意软件带来的损耗。 </p>
</li>
<li><p>许多错误信息和诊断都加强了，包括依赖管理时出现的冲突。</p>
</li>
<li><p>Xcode 工程文件生成器也改进了，现在允许在重新生成工程文件时让 scheme 引用包里的 target。  </p>
</li>
<li><p>并且做了大量的小改进和 bug 修复。  </p>
</li>
</ul>
<p>Xcode 9 在新的编译系统里为 Swift 包管理提供了原生的支持。这个编译系统提供了灵活性和拓展性，让 Xcode 可以支持新的编译模型，例如 Swift 包管理。此外, SwiftPM 为 SwiftPM 的库做了大量的工作，让 Swift 包管理的工具可以轻松嵌入诸如 Xcode 的软件里。</p>
<p>那 SwiftPM 4 还有什么？首先，我们将会实现 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0179-swift-run-command.md" target="_blank" rel="external">SE-0179</a>，支持 <code>swift package run</code> 命令。另外，我们还希望开始放下现在的版本，然后开始计划后面，虽然我们还是在接收建议和 evolution 的提案   </p>
<p>[…]  </p>
<p>其它功能我们应该会考虑在下个版本进行支持，例如包资源(例如图片)，许可证和元数据支持，用于处理源代码控制分支的显式支持，以及一个泛用的机制去处理编译工具不支持包管理的情况。最后, 我们确实考虑了之后建立一个中心化的包索引机制，我们也许会在接下来一年为这件事情做一些基础工作。 </p>
<p><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170605/037002.html" target="_blank" rel="external">查看原文…</a>  </p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后 – <a href="https://twitter.com/NeoNacho/status/871143591258734594" target="_blank" rel="external">self storage</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Jesse Squires，&lt;a href=&quot;https://swiftweekly.github.io/issue-73/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-09&lt;br&gt;译者：&lt;a href=&quot;https://kemchenj.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;四娘&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这周的事情很多！今天是 &lt;a href=&quot;https://developer.apple.com/videos/wwdc2017/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WWDC 2017&lt;/a&gt; 的最后一天，Swift 4 随着 &lt;a href=&quot;https://developer.apple.com/xcode/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Xcode 9&lt;/a&gt;，一起放出了开发者公测版。Xcode 和 Swift 都有好几个重大的改进和新的功能 — 这个版本真的很棒。整个&lt;a href=&quot;https://twitter.com/ericasadun/status/871819962888802304&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;社区&lt;/a&gt;的&lt;a href=&quot;https://twitter.com/SmileyKeith/status/871852588844556288&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;反响&lt;/a&gt;&lt;a href=&quot;https://twitter.com/fpillet/status/871987276187828224&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;都&lt;/a&gt;&lt;a href=&quot;https://twitter.com/chriseidhof/status/873066951739703296&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;很&lt;/a&gt;&lt;a href=&quot;https://twitter.com/tonyarnold/status/873017116298846208&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;正&lt;/a&gt;&lt;a href=&quot;https://twitter.com/ayanonagon/status/871850052498489344&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;面&lt;/a&gt;。恭喜 Apple 的 Xcode, Swift 和开发工具组！&lt;/p&gt;
    
    </summary>
    
      <category term="Jesse Squires" scheme="https://swift.gg/categories/Jesse-Squires/"/>
    
    
      <category term="Swift 周报" scheme="https://swift.gg/tags/Swift-%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>把代码迁移到协调器上</title>
    <link href="https://swift.gg/2017/06/09/migrating-to-coordinators/"/>
    <id>https://swift.gg/2017/06/09/migrating-to-coordinators/</id>
    <published>2017-06-08T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/04/migrating-to-coordinators/" target="_blank" rel="external">原文链接</a>，原文日期：2017-4-25<br>译者：<a href="http://weibo.com/277195544" target="_blank" rel="external">Cwift</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>这篇文章是 <a href="http://khanlou.com/tag/advanced-coordinators/" target="_blank" rel="external">Coordinators（协调器）进阶教程系列</a>的第一篇。如果你没有阅读过<a href="http://khanlou.com/2015/01/the-coordinator/" target="_blank" rel="external">原始的帖子</a>及其<a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="external">后续</a>，请务必首先查阅这些文章。该系列将涵盖几项进阶的 Coordinator 使用技巧、疑点、常见问题以及其他细碎的内容。让我们开始吧。</p>
<a id="more"></a>
<p>常有人问我，如何把一个使用 Storyboard 构建或者是使用纯代码编写 ViewController 构建的应用重构成使用 Coordinators 的应用。只要方法正确，重构可以逐步完成。即使重构未完成，你的应用仍旧可以部署。</p>
<p>要实现这个目标，最好的做法是从根路径出发，在 Coordinators 中称之为 “AppCoordinator”。AppDelegate 持有该 AppCoordinator，AppCoordinator 调度 App 可以加载的所有 ViewController。</p>
<p>想要理解为什么从 App 的根路径开始，可以从反面来思考。如果从一些叶子流程开始（比如，一个 <code>CheckoutCoordinator</code>），那么需要保持对该 Coordinator 的强引用，以防它被释放。如果 Coordinator 被释放，它内部的代码就都不能执行了。所以，深入一个 App 中去，如果我们创建一个 Coordinator，必须让某个对象长久地持有它。</p>
<p>有两种方案可以防止对象被释放。第一种方案是使用静态引用。因为系统里可能只有一个 <code>CheckoutCoordinator</code>，所以很容易将其填充到一个全局变量中。虽然这种方案有效果，但是不是一个理想的选择，因为全局变量阻碍了可测试性和灵活性。第二种方案是让当前展示的 ViewController 持有 Coordinator。这将迫使当前的 ViewController 变得复杂一些，但是可以降低 Coordinator 所管理的所有 ViewController 的复杂性。然而，这种关系本质上是有缺陷的。ViewController 是 Coordinator 的“孩子”，编程时，孩子们不应该不知道他们的父母是谁。类似于一个 <code>UIView</code> 持有了一个 <code>UIViewController</code> 的引用：这种事是不该发生的。</p>
<p>如果你遇到了必须从子流程开始的情况，你可以使用上述两种方法之一。但是，如果可以选择，我的建议是从根路径开始。</p>
<p>从根路径开始的另一个好处是认证流程通常更靠近 App 的根路径。身份认证是一个很好的流程，可以抽象成单独的对象，很适合用来验证 App 中的 Coordinator。</p>
<p>将 App 的 RootViewController 交付给 <code>AppCoordinator</code> 之后，你可以对代码进行 Commit/Pull Request/Code Review。因为其他的 ViewController 仍在正常运转，所以 App 可以在这个未完工的状态下继续工作。基于这点，逐步改造，你可以将更多的 ViewController 交付给 Coordinator。将每个“流程”都交付给 Coordinator 之后，你可以提交代码或者创建一个 pr，不会影响 App 的正常工作。正如最佳重构一样，这些步骤只是移动代码，有时根据需要创建新的 Coordinator。</p>
<p>一旦所有的场景切换都转移到了 Coordinator 中，你就可以开始下一步的重构了，例如将 iPhone 和 iPad 的 Coordinator 封装到单独的对象（而不是一个切换状态的 Coordinator），让子流程可复用，更好地依赖注入，这些都可以应用到你的新架构中。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2017/04/migrating-to-coordinators/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-4-25&lt;br&gt;译者：&lt;a href=&quot;http://weibo.com/277195544&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cwift&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这篇文章是 &lt;a href=&quot;http://khanlou.com/tag/advanced-coordinators/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Coordinators（协调器）进阶教程系列&lt;/a&gt;的第一篇。如果你没有阅读过&lt;a href=&quot;http://khanlou.com/2015/01/the-coordinator/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始的帖子&lt;/a&gt;及其&lt;a href=&quot;http://khanlou.com/2015/10/coordinators-redux/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;后续&lt;/a&gt;，请务必首先查阅这些文章。该系列将涵盖几项进阶的 Coordinator 使用技巧、疑点、常见问题以及其他细碎的内容。让我们开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Table View 中开启文本菜单功能</title>
    <link href="https://swift.gg/2017/06/09/use-context-menu-with-table-view-tutorial-ios10/"/>
    <id>https://swift.gg/2017/06/09/use-context-menu-with-table-view-tutorial-ios10/</id>
    <published>2017-06-08T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/use-context-menu-with-table-view-tutorial-ios10" target="_blank" rel="external">原文链接</a>，原文日期：2017-01-09</p>
<h2 id="译者：Crystal-Sun；校对：walkingway；定稿：CMB"><a href="#译者：Crystal-Sun；校对：walkingway；定稿：CMB" class="headerlink" title="译者：Crystal Sun；校对：walkingway；定稿：CMB"></a>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></h2></blockquote>
<!--此处开始正文-->
<p>长按所选的对象后，弹出文本菜单（Context Menu），允许用户进行剪切、复制、粘贴操作。默认情况下，文本菜单功能在 Table View 中是关闭状态。在本节教程中，将学习如何在 Table View Cell 中开启文本菜单功能，将所选的文本复制到 Text Filed（文本输入框）中。本节教程使用的是 Xcode 8.1 和 iOS 10。</p>
<a id="more"></a>
<h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，创建一个 Single View Application。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58ff88928419c2b2a27d0754/1493141675229/single-view-xcode-template?format=1500w" alt=""></p>
<p>点击 Next。Product Name 使用 <strong>IOS10ContextMenuTableViewTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587284518419c2902d0b4038/1483899997903/?format=1500w" alt=""></p>
<p>打开 <strong>Main.storyboard</strong> 文件，从 Object Library 中拖拽一个 Table View 到主界面，然后选中 Table View，找到 Attribute Inspector，在 Table View 部分，将 Prototype Cells 的值改为1。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728478414fb539f1673cc0/1483900034219/?format=500w" alt=""></p>
<p>选中 Table View Cell，找到 Attribute Inspector ，在 Table View Cell 区域，将 Indentifier 的值设置为 “cell”。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728493bf629afa514967a5/1483900060894/?format=750w" alt=""></p>
<p>选中 Table View，点击右下角的 Pin 按钮，点击上方、左、右三条线，选择 Height，设置成固定高度。在 Update Frames 的下拉菜单中选择 Items of New Contraints，接下来点击 “Add 4 Constraints”。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587284b5725e2549f7b0a58c/1483900094417/?format=750w" alt=""></p>
<p>从 Object Library 中拖拽一个 Text Field 控件，放到 Table View 的下方。按住 Control 键，将其拖拽到 Table View 上，松开 Control 键，选择 “Vertical Spacing” 和 “Center Horizontally”。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587285ead1758edd735361d8/1483900403738/Autolayout-Pinleftandright.png?format=500w" alt=""></p>
<p>选中 Text Field，点击右下角的 Pin 按钮，选中左、右两条线。如下图添加约束。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587286031e5b6c9fdaadb7b3/1483900432899/?format=750w" alt=""></p>
<p>View Controller 需要成为 Table View 的代理（delegate）。选中 TableView，按住 Control 键，将其拖拽到 View Controller 顶部的黄色图标上，点击 dataSource，重复上述步骤，点击 delegate。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728664bebafb08e6a84d26/1483900526787/?format=300w" alt=""></p>
<p>对 Text Field 控件也重复上述步骤，使 View Controller 成为 Text Field 的代理（delegate）。然后打开 <strong>ViewController.swift</strong> 文件，将类的声明改成如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITextFieldDelegate</span> </span>&#123;</div></pre></td></tr></table></figure>
<p>接着添加下列属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pasteBoard = <span class="type">UIPasteboard</span>.generalPasteboard()</div><div class="line"><span class="keyword">var</span> tableData: [<span class="type">String</span>] = [<span class="string">"dog"</span>,<span class="string">"cat"</span>,<span class="string">"fish"</span>]</div></pre></td></tr></table></figure>
<p>pasteBoard 属性将用于复制粘贴操作，tableData 存储展示在 Table View Cell 上的数据。接下来，如下所示修改 Table View 的 delegate 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> tableData.<span class="built_in">count</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>, <span class="keyword">for</span>: indexPath)</div><div class="line">        </div><div class="line">    cell.textLabel?.text = tableData[indexPath.row]</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> cell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Table View 现在会展示 tableData 数组中的值，想要开启文本菜单功能，需要实现以下三个 delegate 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, shouldShowMenuForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">Bool</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, canPerformAction action: Selector, forRowAt indexPath: IndexPath, withSender sender: Any?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">if</span> (action == #selector(<span class="type">UIResponderStandardEditActions</span>.copy(<span class="number">_</span>:))) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, performAction action: Selector, forRowAt indexPath: IndexPath, withSender sender: Any?)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> cell = tableView.cellForRow(at: indexPath)</div><div class="line">    pasteBoard.string = cell!.textLabel?.text</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>tableView:shouldShowMenuForRowAt</strong> 方法必须返回 true，才能长按显示文本菜单。<strong>tableView:canPerformAction:forRowAt</strong> 方法，让文本菜单只显示 copy（复制）一个选项。<strong>tableView:performAction:forRowAt:withSender</strong> 方法将选中的文本复制到 pasteBoard 变量中。</p>
<p>最后，通过 <strong>textFieldShouldReturn</strong> 方法，在点击 Text Field 后让键盘消失。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">self</span>.view.endEditing(<span class="literal">true</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>运行</strong>工程，长按一行 Table View Cell，然后选择 copy（复制） 选项，粘贴到 Text Field（文本框）里。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728d2c1b631b6a2299ad67/1483902262012/?format=750w" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>IOS10ContextMenuTableViewTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/use-context-menu-with-table-view-tutorial-ios10&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-01-09&lt;/p&gt;
&lt;h2 id=&quot;译者：Crystal-Sun；校对：walkingway；定稿：CMB&quot;&gt;&lt;a href=&quot;#译者：Crystal-Sun；校对：walkingway；定稿：CMB&quot; class=&quot;headerlink&quot; title=&quot;译者：Crystal Sun；校对：walkingway；定稿：CMB&quot;&gt;&lt;/a&gt;译者：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/h2&gt;&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;长按所选的对象后，弹出文本菜单（Context Menu），允许用户进行剪切、复制、粘贴操作。默认情况下，文本菜单功能在 Table View 中是关闭状态。在本节教程中，将学习如何在 Table View Cell 中开启文本菜单功能，将所选的文本复制到 Text Filed（文本输入框）中。本节教程使用的是 Xcode 8.1 和 iOS 10。&lt;/p&gt;
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的安全性</title>
    <link href="https://swift.gg/2017/06/06/safety-in-swift/"/>
    <id>https://swift.gg/2017/06/06/safety-in-swift/</id>
    <published>2017-06-05T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/04/safety-in-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2017-04-05<br>译者：<a href="undefined">Doye</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 是一门注重安全性的语言，如<a href="https://Swift.org/" target="_blank" rel="external">Swift官网</a>的<a href="https://Swift.org/about/" target="_blank" rel="external">关于页面</a>中所言</p>
<blockquote>
<p>Swift 是一门通用编程语言，采用现代化的方法来保证安全性与性能，套用软件设计模式。</p>
</blockquote>
<a id="more"></a>
<p>还有它的说明</p>
<ul>
<li><p><strong>安全性</strong>：那些显而易见而又便捷的编程方法应该保证是安全的。未定义的行为会破坏软件的安全性。在软件发布之前就要把开发者的错误扼杀在萌芽之中。强调安全性有时会让你觉得 Swift 语法过于严苛，但是它带来的代码的明晰从长远来看还是利大于弊的。</p>
</li>
<li><p><strong>高性能</strong>: Swift旨在替代 C 系语言（C，C ++和Objective-C），因此 Swift 必须在绝大多数任务中与这些语言有着接近的性能指数，而且性能需要具有可预测性。而且这种指数需要是一种普遍的性能指数，而不是昙花一现的仅仅几种任务类型的高性能。具有各种特性的语言有很多，但仍保持着如此高性能却实属罕见。</p>
</li>
<li><p><strong>表现力</strong>:  Swift 受益于计算机科学的几十年发展，提供了开发人员期望的现代功能并具有有趣的语法。而且 Swift 并不止步于此，Swift 社群会关注编程语言的发展并取其精华，使得 Swift 一直保持进化，变得更好。</p>
</li>
</ul>
<p>举例来说，类似 <strong>Optional</strong> 这种类型就是 Swift 考虑安全性的一个体现，在其他的编程语言当中，你并不能知道哪个变量可以为空(null)哪个不能，而 <strong>Optional</strong> 携带着改变量可能为空的信息，这就强制开发者去考虑可能为空的情况。对于”可空”（nullable）的类型，如果你用强解包符号（<strong>!</strong>）来处理该类型，有些时候它会直接 crash。Swift 的安全性相当于一条安全带，你可以自行解开它，但是风险也要自己来承担。</p>
<p>然而在某些情况下，安全性看起来并不足够。比如举例来说，如果我们有一个字典，我们需要通过一些 key 来提取到返回值类型为 optional 的 value</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> person: [<span class="type">String</span>: <span class="type">String</span>] = <span class="comment">//...</span></div><div class="line">type(of: person[<span class="string">"name"</span>]) <span class="comment">// =&gt; Optional&lt;String&gt;</span></div></pre></td></tr></table></figure>
<p>但是如果我们对数组进行类似的操作，我们并不会得到一个 optional:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> users: [<span class="type">User</span>] = <span class="comment">//...</span></div><div class="line">type(of: users[<span class="number">0</span>]) <span class="comment">// =&gt; User</span></div></pre></td></tr></table></figure>
<p>原因是数组可能没有元素，如果 <strong>users</strong> 的数组为空的话，这段程序将会直接crash，从这方面来看，好像Swift并没有做到足够安全。</p>
<p>Swift仍然在开放的演进中，你可能就此问题提些建议到 <a href="http://khanlou.com/2017/04/safety-in-swift/" target="_blank" rel="external">Swift evolution邮件组</a><br>不，那也不会有什么改变，在 <strong>Swift evolution</strong> 的 github 库里 <a href="https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md" target="_blank" rel="external">”常见驳回”提议页</a> 当中描述了不会接受这项提议：</p>
<ul>
<li>Array&lt; T &gt; 的下标获取操作不返回一个 <strong>T</strong> 而是返回一个 <strong>T?</strong> 或者 <strong>T!</strong>，当前的数组的逻辑是<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002446.html" target="_blank" rel="external">故意为之</a>，它准确反映了访问越界的数组下标是一个逻辑错误。如果改变目前的逻辑会降低数组的读取到一个无法接受的程度，这项提议<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002425.html" target="_blank" rel="external">提出多次</a>并不会被社区采纳。</li>
</ul>
<p>这里指出的原因是在这种特殊情况下，性能至关重要。但是如果我们回过头来看上面引用的关于页当中的信息，”安全性”的地位应该是高于”速度”的，难道安全性不应该比速度更为重要么？</p>
<p>这里存在着一个根本的争议点，在于”安全性”一词的定义。对于”安全性”一个普遍的理解是不 crash，而 Swift 核心成员的定义是”永远不会在无意中访问错误的内存”。</p>
<p>从这点来看，Swift 的下标操作是”安全的”，它永远都不会去访问在数组自身分配之外的内存，当你想访问数组越界的内存时它会立即 crash，如 Optional 类型避免了当前存在的各种空指针引用的 bug 一样，数组这里的考虑避免了缓冲区溢出的 bug。</p>
<p>Chris Lattner（Swift 作者）在<a href="https://overcast.fm/+CdTE-_oY/24:37" target="_blank" rel="external">这段采访</a>的24.39处有段说明</p>
<blockquote>
<p>我们采用的安全性策略是在综合的一种妥协。我们想使Swift成为一门安全的编程语言，但这种安全并不是没有bug，而是我们保障内存安全的的基础上同时提供高性能而且采用一直前进的编程语言范式。</p>
</blockquote>
<p>或许，内存安全相对于安全是一个更好的名词，有些开发者可能更偏向于得到一个 optional 的返回值，而不是在数组越界访问的问题里纠结，每个人都同意直接让程序crash会好过让程序携带着非法的数据继续运行下去，而这种情况还可能会被栈溢出的攻击所利用。</p>
<p>第二种权衡（直接 crash 而不是允许越界访问）的决定看起来显而易见，但是有些语言不会做这种保证，在 C 中，访问越界的数组将会导致未知的行为（具体取决于使用的编译器对这种行为的实现），在 Swift 中开发者会快速的意识到自己犯了类似数组越界的错误，Swift团队觉得这是一个合适的 crash 时机，所以并不会返回一个 optional 甚至是返回一段未知的数据。</p>
<p>使用这里”安全”的定义也明确了”不安全”的 API 的定义，因为它们直接访问内存进行编程，程序员们自己必须十分小心保证自己不会访问到无效的内存，这点尤为困难，即使专家在这种情景也会犯错，如果对这个主题感兴趣去查阅 <a href="https://www.cocoawithlove.com/blog/2016/02/16/use_it_or_lose_it_why_safe_c_is_sometimes_unsafe_swift.html" target="_blank" rel="external">Matt Gallagher的博客</a>中以安全的方式桥接 C 到 Swift 的相关讨论。</p>
<p>Swift 的团队对于安全的定义可能与你预想的并不完全一致，但是它们的种种策略确实可以避免大多数的程序员去考虑各种常见的 bug，将“安全”的定义细化为“内存安全”可以让我更好的理解 Swift 团队对于安全的定义。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2017/04/safety-in-swift/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-04-05&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;Doye&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 是一门注重安全性的语言，如&lt;a href=&quot;https://Swift.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swift官网&lt;/a&gt;的&lt;a href=&quot;https://Swift.org/about/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于页面&lt;/a&gt;中所言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Swift 是一门通用编程语言，采用现代化的方法来保证安全性与性能，套用软件设计模式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="khanlou.com" scheme="https://swift.gg/categories/khanlou-com/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>[Jinkey 原创]震惊！iOS 系统居然自带悬浮窗口调试工具</title>
    <link href="https://swift.gg/2017/05/27/ui-debugging-information-overlay/"/>
    <id>https://swift.gg/2017/05/27/ui-debugging-information-overlay/</id>
    <published>2017-05-26T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>原文链接 : <a href="http://www.jianshu.com/p/736353b5cfaf?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends&amp;from=singlemessage&amp;isappinstalled=1" target="_blank" rel="external">震惊！iOS 系统居然自带悬浮窗口调试工具 —— Jinkey 原创</a></li>
<li>原文作者 : <a href="http://www.jianshu.com/u/8354f5625fe4" target="_blank" rel="external">Jinkey</a></li>
</ul>
</blockquote>
<!--此处开始正文-->
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><blockquote>
<p>英文原文：<br><a href="http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/" target="_blank" rel="external">http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/</a></p>
<p>我写得这个并不是翻译而是用自己的理解重新表述这个功能，和原文内容有出入，有能力的可以查看英文原文。</p>
</blockquote>
<p>我们经常使用各种调试工具，或者开源库来支持悬浮窗调试信息，但苹果的私有方法就提供了 <code>UIDebuggingInformationOverlay</code> 。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-2ef0080f4eea8935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<h2 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2 如何使用"></a>2 如何使用</h2><p>在 <code>AppDelegate</code> 的 <code>didFinishLaunchingWithOptions</code> 方法中加入两行代码即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> overlayClass = <span class="type">NSClassFromString</span>(<span class="string">"UIDebuggingInformationOverlay"</span>) <span class="keyword">as</span>? <span class="type">UIWindow</span>.<span class="type">Type</span></div><div class="line"><span class="number">_</span> = overlayClass?.perform(<span class="type">NSSelectorFromString</span>(<span class="string">"prepareDebuggingOverlay"</span>))</div></pre></td></tr></table></figure>
<p>运行程序后，两根手指点击状态栏即可调起这个调试的悬浮层。</p>
<h2 id="3-能做什么"><a href="#3-能做什么" class="headerlink" title="3 能做什么"></a>3 能做什么</h2><h3 id="3-1-查看整个-window-的-View-嵌套关系"><a href="#3-1-查看整个-window-的-View-嵌套关系" class="headerlink" title="3.1 查看整个 window 的 View 嵌套关系"></a>3.1 查看整个 <code>window</code> 的 <code>View</code> 嵌套关系</h3><blockquote>
<p>View Hierarchy</p>
</blockquote>
<p>这个功能可以查看页面层级的结构树，点击感叹号进入详情页（点 <code>cell</code>  是没反应的），会展示那个 <code>view</code> 的 <code>frame</code> 、 <code>bounds</code> 和其他一些实例变量。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-66b7d3e56dd27cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="3-2-查看当前-ViewController-的属性"><a href="#3-2-查看当前-ViewController-的属性" class="headerlink" title="3.2 查看当前 ViewController 的属性"></a>3.2 查看当前 <code>ViewController</code> 的属性</h3><blockquote>
<p>VC Hierarchy</p>
</blockquote>
<p>查看激活的 <code>ViewController</code> 的 <code>childrenViewCotroller</code> 的结构树和相关属性：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-bbae2392b4a80173.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="3-3-查看-UIApplication-的成员属性"><a href="#3-3-查看-UIApplication-的成员属性" class="headerlink" title="3.3 查看 UIApplication 的成员属性"></a>3.3 查看 <code>UIApplication</code> 的成员属性</h3><blockquote>
<p>Ivar Explorer</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-04044fb28c7d6910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="3-4-测量组件大小"><a href="#3-4-测量组件大小" class="headerlink" title="3.4 测量组件大小"></a>3.4 测量组件大小</h3><blockquote>
<p>Measure</p>
</blockquote>
<p>一开始还挺懵逼不知道要怎么用，后来发现手指是直接在悬浮窗的外部进行进行拖动就可以了，如果你的组件被悬浮窗挡住了好像就没办法了。<br><br>选择 Vertical ，手指在屏幕拖动即可显示某个组件的高度；<br><br>选择 Horizontal ，手指在屏幕拖动即可显示某个组件的 宽度；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-7f0f0d183cc50196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="3-5-效果对比"><a href="#3-5-效果对比" class="headerlink" title="3.5 效果对比"></a>3.5 效果对比</h3><blockquote>
<p>Spec Compare</p>
</blockquote>
<p>从相册读取一个图片（你必须在info.plist 先配置相册权限NSPhotoLibraryUsageDescription）和当前界面对比。</p>
<p>点击 Add -&gt; 从相册选择一个界面截图 -&gt; 点击刚添加的截图 -&gt; 手指在屏幕（悬浮窗外部）上下滑动 -&gt; 即可动态改变截图的透明度来对比截图和当前界面的差异 -&gt; 双击退出。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/854231-d8eae18f88927c88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我的微信公众号 <code>jinkey-love</code> 欢迎交流</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文链接 : &lt;a href=&quot;http://www.jianshu.com/p/736353b5cfaf?utm_campaign=hugo&amp;amp;utm_medium=reader_share&amp;amp;utm_content=note&amp;amp;utm_source=weixin-friends&amp;amp;from=singlemessage&amp;amp;isappinstalled=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;震惊！iOS 系统居然自带悬浮窗口调试工具 —— Jinkey 原创&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者 : &lt;a href=&quot;http://www.jianshu.com/u/8354f5625fe4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jinkey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1 背景&quot;&gt;&lt;/a&gt;1 背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;英文原文：&lt;br&gt;&lt;a href=&quot;http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ryanipete.com/blog/ios/swift/objective-c/uidebugginginformationoverlay/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我写得这个并不是翻译而是用自己的理解重新表述这个功能，和原文内容有出入，有能力的可以查看英文原文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们经常使用各种调试工具，或者开源库来支持悬浮窗调试信息，但苹果的私有方法就提供了 &lt;code&gt;UIDebuggingInformationOverlay&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/854231-2ef0080f4eea8935.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="投稿" scheme="https://swift.gg/categories/%E6%8A%95%E7%A8%BF/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>给每一个 Swift 版本设定开发主题</title>
    <link href="https://swift.gg/2017/05/26/swift-themed-releases/"/>
    <id>https://swift.gg/2017/05/26/swift-themed-releases/</id>
    <published>2017-05-25T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/03/swift-themed-releases/" target="_blank" rel="external">原文链接</a>，原文日期：2017-03-20<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="external">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="external">Cwift</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>大概一个星期之前，<a href="https://swift.org/community/#core-team" target="_blank" rel="external">Swift 核心团队</a>成员 Ben Cohen 在 <a href="https://swift.org/community/#swift-evolution" target="_blank" rel="external">Swift-Evolution</a> 发了<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170306/033699.html" target="_blank" rel="external">一条的很值得思考的信息</a>，回答了一个<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170220/033092.html" target="_blank" rel="external">问题</a> — 再给 <a href="https://github.com/apple/swift/blob/master/CHANGELOG.md#swift-40" target="_blank" rel="external">Swift 4</a> 提一个新提案, 被通过的几率有多大。</p>
<p>Ben 阐述了核心团队决定提案是否要推迟的主要依据。主旨就是 Swift 每一个版本都应该专注于一小部分主题，符合主题的提案给予更高的优先级。</p>
<a id="more"></a>
<p>我认为 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170306/033699.html" target="_blank" rel="external">这篇文章</a> 并没有引起足够的重视，这也是为什么我把它完全引用过来的原因(链接和注解是我自己加的)：</p>
<blockquote>
<p><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html" target="_blank" rel="external">Swift 4 的主题</a>设定好之后，一些不符合主题的提案还是进入了我们的讨论，这显得一点意义也没有。例如一些关于 <a href="https://developer.apple.com/reference/swift/string" target="_blank" rel="external">String</a> ， <a href="https://developer.apple.com/reference/swift/dictionary" target="_blank" rel="external">Dictionary</a> 和 <a href="https://developer.apple.com/reference/swift/sequence" target="_blank" rel="external">Sequence</a> / <a href="https://developer.apple.com/reference/swift/collection" target="_blank" rel="external">Collection</a> 的提案被采纳。在 Swift 接下来的版本里，很可能这些与目标不符合的提案，例如 String 进一步的完善(原生的正则表达式)，move-only 类型，异步，反射，或者是泛型的加强，都会进入讨论。<strong>我们觉得专注于特定的主题对于一门语言的演变特别重要，这些散乱的，与当前开发主题无关的提案，应该要设置更高的采纳门槛。</strong></p>
<p>其中一个原因是核心团队和社区的精力有限。专注一部分目标进行讨论，可以让别的社区更容易参与到我们的讨论里(尽管<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170206/031657.html" target="_blank" rel="external">加入提案模板</a>也会有帮助)。而且如果保证每一个提案都能够为这个阶段的目标服务，我们就可以避免一些提案虽然被采纳，但从未有机会实现的情况出现。  </p>
<p>此外，专注于某个目标进行讨论时，针对这个目标，我们可以有完成度更高，更加具有一致性的功能设计。可以探讨如何在 Swift 4 里把<a href="https://github.com/apple/swift/blob/master/CHANGELOG.md#swift-40" target="_blank" rel="external">所有新的泛型功能</a>合理地组合到一起，构建一个完善，高度一致的体系，让我们更容易使用和理解。或者是新的字符串功能如何<a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md" target="_blank" rel="external">更加便捷地处理字符串</a>。<strong>一方面是向大家传递 Swift 4 想要完成的目标，一方面更利于我们去完成一个条理清晰，连贯的设计。</strong></p>
<p>一个条理清晰的设计不止对于版本的迭代很重要 — 因为这可以让开发者更容易学习使用新功能，<strong>而且对于语言的长期发展也是一样重要。</strong>没有明确目标的提案，会让我们非常难理解单个提案怎么融入到 Swift 整体的发展方向里。我们想要避免进行了一些局部的改进过后，后续再次触及相关的部分时，却发现当时的改进并不符合整体设计。同时还有一种情况是，我们考虑了太多分开看起来很合理的功能，但将它们拼凑到一起时却并不合适。  </p>
<p>例如，最近的一些提案围绕着<a href="https://github.com/DevAndArtist/swift-evolution/blob/refactor_existential_metatypes/proposals/0126-refactor-metatypes.md" target="_blank" rel="external">重构 meta types</a> ，但这必须在反射这个大框架下讨论才可以，所以我们应该等到这个主题被提上议程再去讨论。另外一个例子: 最近的提案 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0154-dictionary-key-and-value-collections.md" target="_blank" rel="external">SE-154</a> 提议可以自定义存储字典键值对的集合，这种做法并没有降低耦合度，它只是提供了一种略微笨重的方式去解决问题 — 给字典提供一个初始值，然后去更新这个值。但它需要作为<a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md" target="_blank" rel="external">ABI 稳定</a>的一部分去思考。这也是我们决定在 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170213/032116.html" target="_blank" rel="external">第二阶段</a> <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170213/032118.html" target="_blank" rel="external">展开关于字典的讨论</a>的原因。  </p>
<p>对于 <a href="https://github.com/apple/swift-evolution/blob/master/releases/swift-3_0.md" target="_blank" rel="external">Swift 3</a> 和 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html" target="_blank" rel="external">Swift 4</a> ，核心团队给每一个版本都设定了主题。<strong>核心团队想要在这个过程中，让社区更早加入到讨论中，帮助核心团队决定接下来的目标，但也会同时思考更好的方式。</strong></p>
</blockquote>
<p>Swift 4.0 的开发周期已经过半，但还不能太早决定接下来 Swift 5 的目标。 <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md" target="_blank" rel="external">ABI 稳定</a> 肯定优先，但除此之外呢？字符串再进一步的改进？异步？反射?</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/03/swift-themed-releases/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-03-20&lt;br&gt;译者：&lt;a href=&quot;https://kemchenj.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;四娘&lt;/a&gt;；校对：&lt;a href=&quot;http://weibo.com/277195544&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cwift&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;大概一个星期之前，&lt;a href=&quot;https://swift.org/community/#core-team&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swift 核心团队&lt;/a&gt;成员 Ben Cohen 在 &lt;a href=&quot;https://swift.org/community/#swift-evolution&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swift-Evolution&lt;/a&gt; 发了&lt;a href=&quot;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170306/033699.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一条的很值得思考的信息&lt;/a&gt;，回答了一个&lt;a href=&quot;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170220/033092.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;问题&lt;/a&gt; — 再给 &lt;a href=&quot;https://github.com/apple/swift/blob/master/CHANGELOG.md#swift-40&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swift 4&lt;/a&gt; 提一个新提案, 被通过的几率有多大。&lt;/p&gt;
&lt;p&gt;Ben 阐述了核心团队决定提案是否要推迟的主要依据。主旨就是 Swift 每一个版本都应该专注于一小部分主题，符合主题的提案给予更高的优先级。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>SpriteKit 技巧之添加背景图片</title>
    <link href="https://swift.gg/2017/05/19/display-background-with-spritekit-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/05/19/display-background-with-spritekit-ios-tutorial-ios10/</id>
    <published>2017-05-18T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/display-background-with-spritekit-ios-tutorial-ios10" target="_blank" rel="external">原文链接</a>，原文日期：2017/01/17<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>Sprite Kit 是硬件加速的动画系统，为创建 2D 游戏进行了专门的优化。在本节教程中，将使用 Game 模板来添加一张背景图片。本节教程使用的是 Xcode 8.2.1 和 iOS 10.2。</p>
<a id="more"></a>
<p>打开 Xcode，选择 iOS -&gt; Application -&gt; Game 模板。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587dfce23a04118eabdf7d95/1484651758293/?format=1500w" alt=""></p>
<p>Product Name 使用 <strong>SpriteKitBackgroundTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Game Technology 一栏选择 SpriteKit，Devices 一栏选择 iPhone。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58ff88c71b10e3c8c1dc6a0d/1493141718478/facebook-project?format=1500w" alt=""></p>
<p>本节教程需要一张图片作为背景图，从这里<a href="https://www.ioscreator.com/s/background.jpg" target="_blank" rel="external">下载</a>图片，添加到工程中，确保在添加时选择 “Copy items if needed” 选项。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587dff5d46c3c46130f0a478/1484652392518/?format=1500w" alt=""></p>
<p>在 Xcode 的 Game 模板中，已经做了很多初始化的工作。在 Sprite Kit 框架中，每个场景（scene）控制 App 的一屏（screen）。找到 <strong>GameViewController.swift</strong> 文件，在 GameViewController 类里，已经定义好了 <strong>viewDidLoad</strong> 方法，在这个方法里创建场景，呈现 GameScene 对象。将 viewDidLoad 方法代码更改成如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">    <span class="keyword">let</span> scene = <span class="type">GameScene</span>(size:<span class="type">CGSize</span>(width: <span class="number">1080</span>, height: <span class="number">1920</span>))</div><div class="line">        </div><div class="line">    <span class="keyword">let</span> skView = <span class="keyword">self</span>.view <span class="keyword">as</span>! <span class="type">SKView</span></div><div class="line">    scene.scaleMode = .aspectFill</div><div class="line">    skView.presentScene(scene)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>找到 <strong>GameScene.swift</strong> 方法，已经定义好了 GameScene 类，在 <strong>didMove</strong> 方法中，实现自定义的代码。删除 GameScene 类里面所有的代码，然后添加 didMove 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameScene</span>: <span class="title">SKScene</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didMove</span><span class="params">(to view: SKView)</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> background = <span class="type">SKSpriteNode</span>(imageNamed: <span class="string">"background.jpg"</span>)</div><div class="line">        background.position = <span class="type">CGPoint</span>(x: size.width/<span class="number">2</span>, y: size.height/<span class="number">2</span>)</div><div class="line">        addChild(background)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Sprite Kit 框架有个指定的类来创建控制 sprite（精灵）（译者注：sprite 是计算机图形学的专有名词，意为包含于场景中的二维图像或动画），就是 SKSpriteNode 类。在该节点（node）下，图片加载完成。接下来，将图片添加到场景中。最后，删除 GameScene.sks 和 Action.sks 文件，目前不需要这两个文件。</p>
<p><strong>运行</strong>工程。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587e00d546c3c46130f0ae45/1484652772003/?format=750w" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>SpriteKitBackgroundTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/display-background-with-spritekit-ios-tutorial-ios10&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017/01/17&lt;br&gt;译者：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Sprite Kit 是硬件加速的动画系统，为创建 2D 游戏进行了专门的优化。在本节教程中，将使用 Game 模板来添加一张背景图片。本节教程使用的是 Xcode 8.2.1 和 iOS 10.2。&lt;/p&gt;
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>改变状态栏的颜色</title>
    <link href="https://swift.gg/2017/05/18/change-color-status-bar-tutorial/"/>
    <id>https://swift.gg/2017/05/18/change-color-status-bar-tutorial/</id>
    <published>2017-05-17T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/change-color-status-bar-tutorial" target="_blank" rel="external">原文链接</a>，原文日期：2016/12/29<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；校对：<a href="http://chengway.in/" target="_blank" rel="external">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>状态栏可以有两种外观：dark（黑色） 和 light（白色）。在本章教程中，将学习如何改变状态栏的外观。本节教程使用的是 Xcode 8.0 和 iOS 10。</p>
<a id="more"></a>
<p>打开 Xcode，创建一个 Single View Application。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58ff88928419c2b2a27d0754/1493141675229/single-view-xcode-template?format=1500w" alt=""></p>
<p>Product Name 使用 <strong>IOS10StatusBarColorTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57ea5a84e58c62718aa3048b/1474976400272/?format=1500w" alt=""></p>
<p>打开 Storyboard，选中 View，在 Attributes Inspetor 里将 Background Color 改成 Light Gray。运行工程，默认的状态栏颜色是黑色（dark）。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57ea5aa5e58c62718aa30530/1474976432868/?format=750w" alt=""></p>
<p>而我们想要实现的效果是白色的状态栏。打开 ViewController.swift 文件，添加下列代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="keyword">var</span> preferredStatusBarStyle: <span class="type">UIStatusBarStyle</span> &#123;</div><div class="line">    <span class="keyword">return</span> .lightContent</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码将 UIStatusBarStyle 枚举项设为 lightContent。运行工程，这时状态栏的颜色变成了白色（light）。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57ea5ad8e58c62718aa3063d/1474976482842/?format=750w" alt=""></p>
<p>接下来回到 Storyboard，选中 View Controller，在 Editor 菜单中选择 Embed in Navigation Controller。选中 Navigation Bar，在 Attribute Inspector 里将 Bar Tint color 设置为 red。storyboard 应该如下图所示。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57eaaf88893fc08c39f02235/1474998157337/?format=1500w" alt=""></p>
<p>运行工程，状态栏又变成了黑色，也就是默认状态。产生这个问题的原因是，iOS 请求的是 navigation controller 状态栏风格，不是 navigation controller 所包含的 controller 风格。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57eab046bebafbd7890070a9/1474998347300/?format=750w" alt=""></p>
<p>为了改变 Navigation controller 的风格（style），需要在 <strong>AppDelegate.swift</strong> 文件里如下修改代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="comment">// Override point for customization after application launch.</span></div><div class="line">        </div><div class="line">    <span class="type">UINavigationBar</span>.appearance().barStyle = .blackOpaque</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行工程，这时状态栏的颜色变成了白色。</p>
<p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/57eab0ce37c581c584f0a3a9/1474998487766/?format=750w" alt=""></p>
<p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a> 上下载 <strong>IOS10StatusBarColorTutorial</strong> 教程的源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      iOS 开发中如何改变状态栏的颜色
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 入门" scheme="https://swift.gg/tags/iOS-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unowned 还是 Weak？生命周期和性能对比</title>
    <link href="https://swift.gg/2017/05/16/unowned-or-weak-lifetime-and-performance/"/>
    <id>https://swift.gg/2017/05/16/unowned-or-weak-lifetime-and-performance/</id>
    <published>2017-05-15T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Umberto Raimondi，<a href="https://www.uraimo.com/2016/10/27/unowned-or-weak-lifetime-and-performance/" target="_blank" rel="external">原文链接</a>，原文日期：2016-10-27<br>译者：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>每当处理循环引用（retain cycles）时，需要考量对象生命周期来选择<code>unowned</code>或者<code>weak</code>标识符，这已经成为了一个共识。但是有时仍然会心存疑问，在具体的使用中应该选择哪一个，或者退一步讲，保守的只使用 weak 是不是一个好的选择呢？</p>
<p>本文首先对循环引用的基础知识做一个简要介绍，然后会分析 Swift 源代码的一些片段，讲解 <code>unowned</code> 和 <code>weak</code>  在生命周期和性能上的差异点，希望看完本文以后，在的使用场景中，能使用正确的弱引用类型。</p>
<a id="more"></a>
<p><strong>目录:</strong></p>
<ul>
<li><a href="#the_basic">基础知识</a></li>
<li><a href="#the_question_unowned_or_weak">问题来了: unowened 还是 weak?</a></li>
<li><a href="#performance_a_look_under_the_hood">性能：深度探索</a></li>
<li><a href="#deconstructing_capture_lists_handling">捕获列表处理解析</a></li>
<li><a href="#conclusion">结论</a></li>
<li><a href="#footnotes">脚注</a></li>
</ul>
<blockquote>
<p>从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="external">GitHub</a> 或者 <a href="https://www.uraimo.com/archives/2016-10-27-UnownedWeakPlayground.playground.zip" target="_blank" rel="external">zipped</a> 获取本文相关的 Playground 代码。然后从<a href="https://www.uraimo.com/archives/closure.zip" target="_blank" rel="external">这里</a>获取闭包案例和 SIL，SILGen 以及 LLVM IR 的输出。</p>
</blockquote>
<p><a name="the_basic"></a></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>众所周知，<code>Swift</code> 利用古老并且有效的自动引用计数（ARC, Automatic Reference Counting）来管理内存，带来的后果和在 Objective-C 中使用的情况类似，需要手动使用弱引用来解决循环引用问题。</p>
<p>如果对 <code>ARC</code> 不了解，只需要知道的是，每一个<em>引用类型</em>实例都有一个引用计数与之关联，这个引用计数用来记录这个对象实例正在被变量或常量引用的总次数。当引用计数变为 <code>0</code> 时，实例将会被析构，实例占有的内存和资源都将变得重新可用。</p>
<p>当有两个实例通过某种形式互相引用时，就会形成循环引用（比如：两个类实例都有一个属性指向对方的类实例；双向链表中两个相邻的节点实例等…）, 由于两个实例的引用计数都一直大于 <code>0</code>， 循环引用将会阻止这些实例的析构。</p>
<p>为了解决这个问题，和其他一些有类似问题的语言一样， 在 <code>Swift</code> 中，<em>弱引用</em> 的概念被提了出来，弱引用不会被 <code>ARC</code> 计算，也就是说，当一个弱引用指向一个引用类型实例时，引用计数不会增加。</p>
<p>弱引用不会阻止实例的析构, 只需要记住的是，在任何情况下，弱引用都不会拥有它指向的对象。在正式的场景中不是什么大问题，但是在我们处理这类引用的时候，需要意识到这一点。</p>
<p>在 Swift 中有 2 种 <em>弱</em> 引用形式，<code>unowned</code> 和 <code>weak</code>。</p>
<p>虽然它们的作用类似，但与它们相关实例生命周期的假设会略有不同，并且具有不同的性能特征。</p>
<p>为了举例说明循环引用，这里不使用大家期望看到的类之间的循环引用，而使用闭包的上下文案例，这在 <code>Objective-C</code> 日常开发中处理循环引用时经常会遇到的情况。和类的循环引用类似，通过创建一个强引用指向外部实例，或捕获它，阻止它析构。</p>
<p>在 <code>Objective-C</code> ，按照标准的做法，定义一个弱引用指向闭包外部的实例，然后在闭包内部定义强引用指向这个实例，在闭包执行期间使用它。当然，有必要在使用前检查引用的有效性。</p>
<p>为了更方便的处理循环引用，<code>Swift</code> 引入了一个新的概念，用于简化和更加明显地表达在闭包内部外部变量的捕获：<em>捕获列表（capture list）</em>。使用捕获列表，可以在函数的头部定义和指定那些需要用在内部的外部变量，并且指定引用类型(译者注：这里是指 <code>unowned</code> 和 <code>weak</code>）。</p>
<p>接下来举一些例子，在各种情况下捕获变量的表现。</p>
<p>当不使用捕获列表时，闭包将会创建一个外部变量的强引用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> i1 = <span class="number">1</span>, i2 = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> fStrong = &#123;</div><div class="line">    i1 += <span class="number">1</span></div><div class="line">    i2 += <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">fStrong()</div><div class="line"><span class="built_in">print</span>(i1,i2) <span class="comment">//Prints 2 and 3</span></div></pre></td></tr></table></figure>
<p>闭包内部对变量的修改将会改变外部原始变量的值，这与预期是一致的。</p>
<p>使用捕获列表，闭包内部会创建一个新的可用常量。如果没有指定常量修饰符，闭包将会简单地拷贝原始值到新的变量中，对于值类型和引用类型都是一样的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fCopy = &#123; [i1] <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(i1,i2)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fStrong()</div><div class="line"><span class="built_in">print</span>(i1,i2) <span class="comment">//打印结果是 2 和 3  </span></div><div class="line"></div><div class="line">fCopy()  <span class="comment">//打印结果是 1 和 3</span></div></pre></td></tr></table></figure>
<p>在上面的例子中，在调用 <code>fStrong</code> 之前定义函数 <code>fCopy</code> ,在该函数定义的时候，私有常量已经被创建了。正如你所看到的，当调用第二个函数时候，仍然打印 <code>i1</code> 的原始值。</p>
<p>对于外部引用类型的变量，在捕获列表中指定 <code>weak</code> 或 <code>unowned</code>，这个常量将会被初始化为一个弱引用，指向原始值，这种指定的捕获方式就是用来处理循环引用的方式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">aClass</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c1 = aClass()</div><div class="line"><span class="keyword">var</span> c2 = aClass()</div><div class="line"></div><div class="line"><span class="keyword">var</span> fSpec = &#123; [<span class="keyword">unowned</span> c1, <span class="keyword">weak</span> c2] <span class="keyword">in</span></div><div class="line">    c1.value += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> c2 = c2 &#123;</div><div class="line">        c2.value += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fSpec()</div><div class="line"><span class="built_in">print</span>(c1.value,c2.value) <span class="comment">//Prints 2 and 2</span></div></pre></td></tr></table></figure>
<p>两个 <code>aClass</code> 捕获实例的不同的定义方式，决定了它们在闭包中不同的使用方式。</p>
<p>unowned 引用使用的场景是，原始实例永远不会为 <em>nil</em>，闭包可以直接使用它，并且直接定义为显式解包可选值。当原始实例被析构后，在闭包中使用这个捕获值将导致崩溃。</p>
<p>如果捕获原始实例在使用过程中可能为 <em>nil</em> ，必须将引用声明为 <code>weak</code>， 并且在使用之前验证这个引用的有效性。</p>
<p><a name="the_question_unowned_or_weak"></a></p>
<h3 id="问题来了-unowened-还是-weak"><a href="#问题来了-unowened-还是-weak" class="headerlink" title="问题来了: unowened 还是 weak?"></a>问题来了: unowened 还是 weak?</h3><p>在实际使用中如何选择这两种弱引用类型呢？</p>
<p>这个问题的答案可以简单由原始对象和引用它的闭包的<strong>生命周期来解释</strong>。</p>
<p><img src="https://www.uraimo.com/imgs/unownedbig.png" alt=""></p>
<p>有两个可能出现的场景：</p>
<ul>
<li><p>闭包和捕获对象的生命周期相同，所以对象可以被访问，也就意味着闭包也可以被访问。外部对象和闭包有相同的生命周期(比如：对象和它的父对象的简单返回引用）。在这种情况下，你应该把引用定义为 <strong>unowned</strong>。</p>
<p>一个经典的案例是: <code>[unowned self]</code>, 主要用在闭包中，这种闭包主要在他们的父节点上下文中做一些事情，没有在其他地方被引用或传递，不能作用在父节点之外。</p>
</li>
</ul>
<ul>
<li><p>闭包的生命周期和捕获对象的生命周期相互独立，当对象不能再使用时，闭包依然能够被引用。这种情况下，你应该把引用定义为 <code>weak</code>，并且在使用它之前验证一下它是否为 <code>nil</code>（请不要对它进行强制解包).</p>
<p>一个经典的案例是: <code>[weak delegate = self.delegate!]</code>，可以在某些使用闭包的场景中看到，闭包使用的是完全无关（生命周期独立）的代理对象。</p>
</li>
</ul>
<p>当无法确认两个对象之间生命周期的关系时，是否不应该去冒险选择一个无效 <code>unowned</code> 引用？而是保守选择 <code>weak</code> 引用是一个更好的选择？</p>
<p>答案是否定的，不仅仅是因为对象生命周期了解是一件必要的事情，而且这两个修饰符在性能特性上也有很大的不同。</p>
<p>弱引用最常见的实现是，每次一个新的引用生成时，都会把每个弱引用和它指向的对象信息存储到一个附加表中。</p>
<p>当没有任何强引用指向一个对象时，<code>Swift</code> 运行时会启动析构过程，但是在这之前，运行时会把所有相关的弱引用置为 <em>nil</em> 。弱引用的这种实现方式我们称之为”零和弱引用”。</p>
<p>这种实现有实际的开销，考虑到需要额外实现的数据结构，需要确保在并发访问情况下，对这个全局引用结构所有操作的正确性。一旦析构过程开始了，在任何环境中，都不允许访问弱引用所指向的对象了。</p>
<p>弱引用（包括 <code>unowned</code> 和一些变体的 <code>weak</code>)在 Swift 使用了更简单和快速的实现机制。</p>
<p><code>Swift</code> 中的每个对象保持了两个引用计数器，一个是强引用计数器，用来决定 <code>ARC</code> 什么时候可以安全地析构这个对象，另外一个附加的弱引用计数器，用来计算创建了多少个指向这个对象的 <code>unowned</code> 或者 <code>weak</code> 引用，当这个计数器为零时，这个对象将被 <em>析构</em> 。</p>
<p>需要重点理解的是，只有等到所有 <code>unowned</code> 引用被释放后，这个对象才会被真正地析构，然后对象将会保持未解析可访问状态，当析构发生后，对象的内容才会被回收。</p>
<p>每当 <code>unowned</code> 引用被定义时，对应的 <code>unowned</code> 引用计数会进行原子级别地增加(使用<a href="http://llvm.org/docs/Atomics.html#libcalls-atomic" target="_blank" rel="external">原子gcc/llvm操作</a>，进行一系列快速且线程安全的基本操作，例如：增加，减少，比较，交换等)，以保证线程安全。在增加计数之前，会检查强引用计数以确保对象是有效的。</p>
<p>试图访问一个无效的对象，将会导致错误的断言，你的应用在运行时中会报错(这就是为什么这里的 <code>unownd</code> 实现方式叫做 <code>unowned(safe)</code> 实现)</p>
<p>为了更好的优化，应用编译时带有 <code>-OFast</code>，<code>unowned</code> 引用不会去验证引用对象的有效性，<code>unowned</code> 引用的行为就会像 <code>Objective-C</code> 中的 <code>__unsafe_unretained</code> 一样。如果引用对象无效，<code>unowned</code> 引用将会指向已经释放垃圾内存（这种实现称之 <code>unowned(unsafe)</code>）。</p>
<p>当一个 <code>unowned</code> 引用被释放后，如果这时没有其他强引用或 <code>unowned</code> 引用指向这个对象，那么最终这个对象将被析构。这就是为什么一个引用对象不能在强引用计数器等于零的情况下，被析构的原因，所有的引用计数器必须能够被访问用来验证 <code>unowned</code> 引用和强引用数量。</p>
<p>Swift 的 <code>weak</code> 引用添加了附加层，间接地把 <code>unowned</code> 引用包裹到了一个可选容器里面，在指向的对象析构之后变成空的情况下，这样处理会更加的清晰。但是需要付出的代价是，附加的机制需要正确地处理可选值。</p>
<p>考虑到以上因素，在对象关系生命周期允许的情况下，<strong>优先选择</strong>使用 <code>unowned</code> 引用。但是这不是此故事的结局，接下来比较一下两者性能<sup><a href="#1">1</a></sup>上的差别。</p>
<p><a name="performance_a_look_under_the_hood"></a></p>
<h3 id="性能：深度探索"><a href="#性能：深度探索" class="headerlink" title="性能：深度探索"></a>性能：深度探索</h3><p>在查看 <code>Swift</code> 项目源码验证之前，需要理解 <code>ARC</code> 如何管理这两种引用类型，并且还需要解释 <code>swiftc</code>，<code>LLVM</code> 和 <code>SIL</code> 的相关知识。</p>
<p>接下来试着简要介绍本文所需要的必备知识点，如果想了解更多，将在最后的脚注中找到一些有用的链接。</p>
<p>使用一个图来解释 <em>swiftc</em> 整个编译过程的包含的模块：</p>
<p><img src="https://www.uraimo.com/imgs/swiftc.png" alt=""></p>
<p><code>Swiftc</code> 和 <em>clang</em> 一样构建在 LLVM 上，遵循 <em>clang</em> 编译器相似的编译流程。</p>
<p>在编译过程的第一部分，使用一个特定语言前端进行管理，<code>swift</code> 源代码被解释生成一个抽象语法树(AST)表达<sup><a href="#2">2</a></sup>，然后抽象语法树的结果从语义角度进行分析，找出语义错误。</p>
<p>在这个点上，对于其他的基于 LLVM 的编译器来讲，在通过一个附加步骤对源代码进行静态分析后（必要时可以显示错误和警告），接着 <em>IRGen</em> 模块 会把 <code>AST</code> 的内容会转换成一个轻量的和底层的机器无关的表示，我们称之为 <a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="external">LLVM IR</a>(<code>LLVM</code> 中间表示)。</p>
<p>尽管两个模块都需要做一些相同检查，但是这两个模块是区分开的，在两个模块之间也存在许多重复的代码。</p>
<p><code>IR</code> 是一种<a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="external">静态单赋值形式</a>（<code>SSA-form</code>）一致语言，可以看做注入了 <code>LLVM</code> 的虚拟机下的 <code>RISC</code> 类型<a href="https://idea.popcount.org/2013-07-24-ir-is-better-than-assembly/" target="_blank" rel="external">汇编语言</a>。基于 <code>SSA</code> 将简化接下来的编译过程，从语言前端提供的中间表达会在 <code>IR</code> 进行多重优化。</p>
<p>需要重点注意的是，<code>IR</code> 其中一个特点是，它具有三种不同的形式：内存表达（内部使用），序列化位代码形式（你已经知道的<a href="https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html" target="_blank" rel="external">位代码形式</a>）和可读形式。</p>
<p>最后一种形式非常有用，用来验证 <code>IR</code> 代码的最终结构，这个结构将会传入到整个过程中的最后一步，将会从机器独立的 <code>IR</code> 代码转换成平台相关的表达(比如：x86，ARM 等等)。最后一步将被 <code>LLVM</code> 平台后端执行。</p>
<p>那么 <code>swiftc</code> 和其他基于 <code>LLVM</code> 的编译器有什么不同呢？</p>
<p><code>swiftc</code> 和其他编译器从结构形式上的差别主要体现在一个附加组件，这个附加组件是 <em>SILGen</em> ，在 <em>IRGen</em> 之前，执行代码的监测和优化，生成一个高级的中间表达，我们称之为 <em>SIL</em> （Swift Intermediate Language，Swift 中间语言），最后 SIL 将会转换成 LLVM IR。这一步加强了在单个软件模块上所有具体语言的检查，并且简化了 <em>IRGen</em>。</p>
<p>从 <code>AST</code> 到 <code>IR</code> 的转换分为两个步骤。<em>SILGen</em> 把 <code>AST</code> 源代码转换为原始 <code>SIL</code> ，然后编译器进行 <code>Swift</code> 语法检查（需要时打印错误或者警告信息），优化有效的原始 <code>SIL</code> ，通过一些步骤最后生成标准化 <code>SIL</code> 。如上面的示意图显示那样，标准化 <code>SIL</code> 的最后转化为 <code>LLVM IR</code>。</p>
<p>再次强调，<code>SIL</code> 是一个 <code>SSA</code> 类型语言，使用附加的结构扩展了 <code>Swift</code> 的语法。它依赖 <code>Swift</code> 的类型系统，并且能理解 <code>Swift</code> 的定义，但是需要重点记住的是，当编译一个手写的 <code>SIL</code> 源码（是的，可以手动写 <code>SIL</code> 然后编译它）时，高阶的 <code>Swift</code> 代码或者函数内容将被编译器忽略。</p>
<p>在接下来的章节，我们将分析一个标准化 <code>SIL</code> 的案例，来理解 <code>unowned</code> 和 <code>weak</code> 引用如何被编译器处理。一个包含捕获列表的基本闭包的例子，查看这个例子生成的 <code>SIL</code> 代码，可以看到被编译器添加的所有 <code>ARC</code> 相关的函数调用。</p>
<blockquote>
<p>从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="external">GitHub</a> 或者 <a href="https://www.uraimo.com/archives/2016-10-27-UnownedWeakPlayground.playground.zip" target="_blank" rel="external">zipped</a> 获取本文相关的 Playground 代码。然后从<a href="https://www.uraimo.com/archives/closure.zip" target="_blank" rel="external">这里</a>获取闭包案例和 <code>SIL</code> ，<code>SILGen</code> 以及 <code>LLVM IR</code> 的输出。</p>
</blockquote>
<p><a name="deconstructing_capture_lists_handling"></a></p>
<h4 id="捕获列表处理解析"><a href="#捕获列表处理解析" class="headerlink" title="捕获列表处理解析"></a>捕获列表处理解析</h4><p>接下来看看一个简单的 <code>Swift</code> 的例子，定义两个类变量，然后在一个闭包中对他们进行弱引用的捕获：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">aClass</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c1 = aClass()</div><div class="line"><span class="keyword">var</span> c2 = aClass()</div><div class="line"></div><div class="line"><span class="keyword">var</span> fSpec = &#123; </div><div class="line">    [<span class="keyword">unowned</span> c1, <span class="keyword">weak</span> c2] <span class="keyword">in</span></div><div class="line">    c1.value = <span class="number">42</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> c2o = c2 &#123;</div><div class="line">        c2o.value = <span class="number">42</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fSpec()</div></pre></td></tr></table></figure>
<p>通过 <code>xcrun swiftc -emit-sil sample.swift</code> 编译 swift 源代码，生成标准化 SIL 代码。原始SIL 可以使用 <code>-emit-silgen</code> 选项来生成。</p>
<p>运行以上命令以后，会发现 swiftc 产生了许多代码。通过查看 swiftc 输出代码的片段，学习一下基本的 SIL 指令，理解整个结构。</p>
<p>在下面代码中需要的地方添加了一些多行注释（编译器也生成了一些单行注释），希望这些注释已经足够说清楚发生了什么：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  此文件包含典型 SIL 代码</div><div class="line">*/</div><div class="line">sil_stage canonical             </div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">  只有在 SIL 内部使用的特殊的导入</div><div class="line">*/</div><div class="line"><span class="keyword">import</span> Builtin                  </div><div class="line"><span class="keyword">import</span> Swift</div><div class="line"><span class="keyword">import</span> SwiftShims</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">	三个全局变量的定义，包括 c1，c2 和 闭包 fSpec。</div><div class="line">  	@_Tv4clos2c1CS_6aClass是变量的符号，$aClass 是它的类型（类型前缀为$)。</div><div class="line">  	变量名在这里看起来很乱，但是在后面的代码中将变得更加可读。</div><div class="line">*/</div><div class="line"><span class="comment">// c1</span></div><div class="line">sil_global hidden @_Tv4sample2c1CS_6aClass : $aClass</div><div class="line"></div><div class="line"><span class="comment">// c2</span></div><div class="line">sil_global hidden @_Tv4sample2c2CS_6aClass : $aClass</div><div class="line"></div><div class="line"><span class="comment">// fSpec</span></div><div class="line">sil_global hidden @_Tv4sample5fSpecFT_T_ : $@callee_owned () -&gt; ()</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  层次作用域定义表示原始代码的位置。</div><div class="line">  每个 SIL 指示将会指向它生成的 `sil_scope`。</div><div class="line">*/</div><div class="line">sil_scope <span class="number">1</span> &#123;  parent @main : $<span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Int32</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="type">Int32</span> &#125;</div><div class="line">sil_scope <span class="number">2</span> &#123; loc <span class="string">"sample.swift"</span>:<span class="number">14</span>:<span class="number">1</span> parent <span class="number">1</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">	自动生成的 @main 函数包含了我们原始全部作用域的代码。</div><div class="line"> 	这里沿用了熟悉的 c main() 函数结构，接收参数个数和参数数组两个输入，这个函数遵循 c 调用约定。</div><div class="line">  	这个函数包含了需要调用闭包的指令。</div><div class="line">*/</div><div class="line"><span class="comment">// main</span></div><div class="line">sil @main : $<span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Int32</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="type">Int32</span> &#123;</div><div class="line"><span class="comment">/*</span></div><div class="line">  入口定义头部为 % 符号，后面跟随一个数字 id。</div><div class="line">  每当一个新的入口定义时（或者函数开头定义函数参数），编译器在入口行尾根据它的值（叫做 users）添加一个注释。</div><div class="line">  对于其他指令，需要提供 id 号。</div><div class="line">  在这里，入口 0 将被用来计算入口 4 的内容，入口 1 将被用来创建入口 10 的值。</div><div class="line">*/</div><div class="line"><span class="comment">// %0                                             // user: %4</span></div><div class="line"><span class="comment">// %1                                             // user: %10</span></div><div class="line"><span class="comment">/*</span></div><div class="line">  每一个函数被分解成一系列的基本指令块，每一个指令块结束于一个终止指令（一个分支或者一个返回）。</div><div class="line">  这一系列的指令块表示函数所有可能的执行路径。</div><div class="line">*/</div><div class="line">bb0(%<span class="number">0</span> : $<span class="type">Int32</span>, %<span class="number">1</span> : $<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;):</div><div class="line">...</div><div class="line">  <span class="comment">/*</span></div><div class="line">    每一个 SIL 指令都包含一个引用，指向源代码的位置，包括指令具体从源代码中哪个地方来，属于哪一个作用域。</div><div class="line">    在后面分析具体的方法会看到这些内容。</div><div class="line">  */</div><div class="line">  unowned_retain %<span class="number">27</span> : $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %28</span></div><div class="line">  store %<span class="number">27</span> to %<span class="number">2</span> : $*@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %29</span></div><div class="line">  %<span class="number">30</span> = alloc_box $@sil_weak <span class="type">Optional</span>&lt;aClass&gt;, <span class="keyword">var</span>, name <span class="string">"c2"</span>, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %46, %44, %43, %31</span></div><div class="line">  %<span class="number">31</span> = project_box %<span class="number">30</span> : $@box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// user: %35</span></div><div class="line">  %<span class="number">32</span> = load %<span class="number">19</span> : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %34, %33</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">  下面是一系列自动生成的`aClass`的方法，包括： init/deinit, setter/getter 和其他一些工具方法。</div><div class="line">  每个方法前的注释是编译器添加的，用来说明代码的具体作用。</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  隐藏方法只在它们模块中可见。</div><div class="line">  @convention(方法名)是 Swift 中方法调用默认的约定，在尾部有一个附加的参数指向它自己。</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.__deallocating_deinit</span></div><div class="line">sil hidden @_TFC4clos6aClassD : $<span class="meta">@convention</span>(method) (@owned aClass) -&gt; () &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  @guaranteed 参数表示保证在整个周期内调用此方法都有效。</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.deinit</span></div><div class="line">sil hidden @_TFC4clos6aClassd : $<span class="meta">@convention</span>(method) (@guaranteed aClass) -&gt; @owned <span class="type">Builtin</span>.<span class="type">NativeObject</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  [transparent] 修饰的方法是内联的小方法</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.value.getter</span></div><div class="line">sil hidden [transparent] @_TFC4clos6aClassg5valueSi : $<span class="meta">@convention</span>(method) (@guaranteed aClass) -&gt; <span class="type">Int</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// aClass.value.setter</span></div><div class="line">sil hidden [transparent] @_TFC4clos6aClasss5valueSi : $<span class="meta">@convention</span>(method) (<span class="type">Int</span>, @guaranteed aClass) -&gt; () &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">// aClass.value.materializeForSet</span></div><div class="line">sil hidden [transparent] @_TFC4clos6aClassm5valueSi : $<span class="meta">@convention</span>(method) (<span class="type">Builtin</span>.<span class="type">RawPointer</span>, @<span class="keyword">inout</span> <span class="type">Builtin</span>.<span class="type">UnsafeValueBuffer</span>, @guaranteed aClass) -&gt; (<span class="type">Builtin</span>.<span class="type">RawPointer</span>, <span class="type">Optional</span>&lt;<span class="type">Builtin</span>.<span class="type">RawPointer</span>&gt;) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">  @owned 修饰符表示这个对象将被调用者拥有。</div><div class="line">*/</div><div class="line"><span class="comment">// aClass.init() -&gt; aClass</span></div><div class="line">sil hidden @_TFC4clos6aClasscfT_S0_ : $<span class="meta">@convention</span>(method) (@owned aClass) -&gt; @owned aClass &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// aClass.__allocating_init() -&gt; aClass</span></div><div class="line">sil hidden @_TFC4clos6aClassCfT_S0_ : $<span class="meta">@convention</span>(method) (@thick aClass.<span class="type">Type</span>) -&gt; @owned aClass &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">  接下面是闭包代码段</div><div class="line">*/</div><div class="line"><span class="comment">// (closure #1)</span></div><div class="line">sil shared @_TF4closU_FT_T_ : $<span class="meta">@convention</span>(thin) (@owned @sil_unowned aClass, @owned @box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;) -&gt; () &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">/* 关于闭包的 SIL 代码， 见下文 */</span></div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"><span class="comment">/* </span></div><div class="line">  sil_vtable 定义所有关于 aClass 类的虚函数表。</div><div class="line">  sil_vtable 包含了期望的所有自动生成的方法。</div><div class="line">*/</div><div class="line">sil_vtable aClass &#123;</div><div class="line">  #aClass.<span class="keyword">deinit</span>!deallocator: _TFC4clos6aClassD	<span class="comment">// aClass.__deallocating_deinit</span></div><div class="line">  #aClass.value!getter.<span class="number">1</span>: _TFC4clos6aClassg5valueSi	<span class="comment">// aClass.value.getter</span></div><div class="line">  #aClass.value!setter.<span class="number">1</span>: _TFC4clos6aClasss5valueSi	<span class="comment">// aClass.value.setter</span></div><div class="line">  #aClass.value!materializeForSet.<span class="number">1</span>: _TFC4clos6aClassm5valueSi	<span class="comment">// aClass.value.materializeForSet</span></div><div class="line">  #aClass.<span class="keyword">init</span>!initializer.<span class="number">1</span>: _TFC4clos6aClasscfT_S0_	<span class="comment">// aClass.init() -&gt; aClass</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在回到主函数，看看两个类实例如何被获取到，并如何传递给调用他们的闭包。</p>
<p>在这里，所有标识都被重新整理，使得代码片段更加可读。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="comment">// main</span></div><div class="line">sil @main : $<span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Int32</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;) -&gt; <span class="type">Int32</span> &#123;</div><div class="line"><span class="comment">// %0                                             // user: %4</span></div><div class="line"><span class="comment">// %1                                             // user: %10</span></div><div class="line">bb0(%<span class="number">0</span> : $<span class="type">Int32</span>, %<span class="number">1</span> : $<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Optional</span>&lt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;&gt;&gt;):</div><div class="line">  ...</div><div class="line">  <span class="comment">/*</span></div><div class="line">    全局变量的引用使用三个入口来放置。</div><div class="line">  */</div><div class="line">  %<span class="number">13</span> = global_addr @clos.c1 : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">5</span>:<span class="number">5</span>, scope <span class="number">1</span> <span class="comment">// users: %26, %17</span></div><div class="line">  ...</div><div class="line">  %<span class="number">19</span> = global_addr @clos.c2 : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">6</span>:<span class="number">5</span>, scope <span class="number">1</span> <span class="comment">// users: %32, %23</span></div><div class="line">  ...</div><div class="line">  %<span class="number">25</span> = global_addr @clos.fSpec : $*@callee_owned () -&gt; (), loc <span class="string">"sample.swift"</span>:<span class="number">8</span>:<span class="number">5</span>, scope <span class="number">1</span> <span class="comment">// users: %48, %45</span></div><div class="line">  <span class="comment">/*</span></div><div class="line">    c1 是 unowned_retained 的。</div><div class="line">    下面的指令增加变量的 unowned 引用计数。</div><div class="line">  */</div><div class="line">  %<span class="number">26</span> = load %<span class="number">13</span> : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// user: %27</span></div><div class="line">  %<span class="number">27</span> = ref_to_unowned %<span class="number">26</span> : $aClass to $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// users: %47, %38, %39, %29, %28</span></div><div class="line">  unowned_retain %<span class="number">27</span> : $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %28</span></div><div class="line">  store %<span class="number">27</span> to %<span class="number">2</span> : $*@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">14</span>, scope <span class="number">2</span> <span class="comment">// id: %29</span></div><div class="line">  <span class="comment">/*</span></div><div class="line">    对 c2 的处理会更加复杂一些。</div><div class="line">	alloc_box 创建了一个这个变量的引用数容器，变量将会存在这个容器的堆中。</div><div class="line">    容器创建以后，将会创建一个可选变量，指向 c2，并且可选变量会存储在容器里。容器会增加所包含值的技术，正如下面看到的一样，一旦容器被迁移，可选值就会被释放。</div><div class="line">    在这里，c2 的值将被存储在这个可选值中，对象将暂时strong_retained 然后释放。</div><div class="line">  */</div><div class="line">  %<span class="number">30</span> = alloc_box $@sil_weak <span class="type">Optional</span>&lt;aClass&gt;, <span class="keyword">var</span>, name <span class="string">"c2"</span>, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %46, %44, %43, %31</span></div><div class="line">  %<span class="number">31</span> = project_box %<span class="number">30</span> : $@box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// user: %35</span></div><div class="line">  %<span class="number">32</span> = load %<span class="number">19</span> : $*aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// users: %34, %33</span></div><div class="line">  strong_retain %<span class="number">32</span> : $aClass, loc <span class="string">"sample.swift"</span>:<span class="number">9</span>:<span class="number">23</span>, scope <span class="number">2</span> <span class="comment">// id: %33</span></div><div class="line">  %<span class="number">34</span> = <span class="class"><span class="keyword">enum</span> <span class="title">$Optional</span>&lt;<span class="title">aClass</span>&gt;, #<span class="title">Optional</span>.<span class="title">some</span>!<span class="title">enumelt</span>.1, %32 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:23, <span class="title">scope</span> 2 // <span class="title">users</span>: %36, %35</span></div><div class="line">  <span class="title">store_weak</span> %34 <span class="title">to</span> [<span class="title">initialization</span>] %31 : <span class="title">$</span>*@<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:23, <span class="title">scope</span> 2 // <span class="title">id</span>: %35</div><div class="line">  <span class="title">release_value</span> %34 : <span class="title">$Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:23, <span class="title">scope</span> 2 // <span class="title">id</span>: %36</div><div class="line">  /*</div><div class="line">    获取到闭包的引用。</div><div class="line">  */</div><div class="line">  // <span class="title">function_ref</span> (<span class="title">closure</span> #1)</div><div class="line">  %37 = <span class="title">function_ref</span> @<span class="title">sample</span>.(<span class="title">closure</span> #1) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">thin</span>) (@<span class="title">owned</span> @<span class="title">sil_unowned</span> <span class="title">aClass</span>, @<span class="title">owned</span> @<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">user</span>: %44</div><div class="line">  /*</div><div class="line">    <span class="title">c1</span> 将被标记为 <span class="title">tagged</span>，并且变量变为 <span class="title">unowned_retained</span>。</div><div class="line">  */</div><div class="line">  <span class="title">strong_retain_unowned</span> %27 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %38</div><div class="line">  %39 = <span class="title">unowned_to_ref</span> %27 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span> <span class="title">to</span> <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">users</span>: %42, %40</div><div class="line">  %40 = <span class="title">ref_to_unowned</span> %39 : <span class="title">$aClass</span> <span class="title">to</span> <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">users</span>: %44, %41</div><div class="line">  <span class="title">unowned_retain</span> %40 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %41</div><div class="line">  <span class="title">strong_release</span> %39 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %42</div><div class="line">  /*</div><div class="line">    包含 <span class="title">c2</span> 的可选值容器是 <span class="title">strong_retained</span> 的。</div><div class="line">  */</div><div class="line">  <span class="title">strong_retain</span> %30 : <span class="title">$</span>@<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %43</div><div class="line">  /*</div><div class="line">    创建一个闭包对象，绑定方法到参数中。</div><div class="line">  */</div><div class="line">  %44 = <span class="title">partial_apply</span> %37(%40, %30) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">thin</span>) (@<span class="title">owned</span> @<span class="title">sil_unowned</span> <span class="title">aClass</span>, @<span class="title">owned</span> @<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">user</span>: %45</div><div class="line">  <span class="title">store</span> %44 <span class="title">to</span> %25 : <span class="title">$</span>*@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":8:13, <span class="title">scope</span> 2 // <span class="title">id</span>: %45</div><div class="line">  /*</div><div class="line">    </div><div class="line">    对 <span class="title">c1</span> 和 <span class="title">c2</span> 的容器变量进行释放（使用 对应匹配的 *<span class="title">_release</span> 方法）。</div><div class="line">  */</div><div class="line">  <span class="title">strong_release</span> %30 : <span class="title">$</span>@<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 2 // <span class="title">id</span>: %46</div><div class="line">  <span class="title">unowned_release</span> %27 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":9:14, <span class="title">scope</span> 2 // <span class="title">id</span>: %47</div><div class="line">  /*</div><div class="line">     加载原先存储的闭包对象，增加强引用然后调用它。</div><div class="line">  */</div><div class="line">   %48 = <span class="title">load</span> %25 : <span class="title">$</span>*@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":17:1, <span class="title">scope</span> 2 // <span class="title">users</span>: %50, %49</div><div class="line">  <span class="title">strong_retain</span> %48 : <span class="title">$</span>@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":17:1, <span class="title">scope</span> 2 // <span class="title">id</span>: %49</div><div class="line">  %50 = <span class="title">apply</span> %48() : <span class="title">$</span>@<span class="title">callee_owned</span> () -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":17:7, <span class="title">scope</span> 2</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>闭包有一个更加复杂的结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  闭包参数被标记为 @sil, 指定参数如何被计数，有一个 unowned 的 aClass 类变量 c2, 和另外一个包含 c2 的可选值容器。</div><div class="line">*/</div><div class="line"><span class="comment">// (closure #1)</span></div><div class="line">sil shared @clos.fSpec: $<span class="meta">@convention</span>(thin) (@owned @sil_unowned aClass, @owned @box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;) -&gt; () &#123;</div><div class="line"><span class="comment">// %0                                             // users: %24, %6, %5, %2</span></div><div class="line"><span class="comment">// %1                                             // users: %23, %3</span></div><div class="line"><span class="comment">/*</span></div><div class="line">  下面的函数包含三块，后面两块的执行依赖可选值 c2 具体的值。</div><div class="line">*/</div><div class="line">bb0(%<span class="number">0</span> : $@sil_unowned aClass, %<span class="number">1</span> : $@box @sil_weak <span class="type">Optional</span>&lt;aClass&gt;):</div><div class="line">...</div><div class="line">  <span class="comment">/*</span></div><div class="line">    c1 被强计数。</div><div class="line">  */</div><div class="line">  strong_retain_unowned %<span class="number">0</span> : $@sil_unowned aClass, loc <span class="string">"sample.swift"</span>:<span class="number">10</span>:<span class="number">5</span>, scope <span class="number">17</span> <span class="comment">// id: %5</span></div><div class="line">  %<span class="number">6</span> = unowned_to_ref %<span class="number">0</span> : $@sil_unowned aClass to $aClass, loc <span class="string">"sample.swift"</span>:<span class="number">10</span>:<span class="number">5</span>, scope <span class="number">17</span> <span class="comment">// users: %11, %10, %9</span></div><div class="line">  <span class="comment">/*</span></div><div class="line">    使用内部自带包，传入一个整型字面量到整型结构中，初始化了一个值为 42 的整型值。</div><div class="line">    这个值将被设置为 c1 的新值，完成以后这个变量将会被释放。</div><div class="line">    在这里，我们第一次看到 class_method 指令，用于获取 vtable 中的函数引用。</div><div class="line">  */</div><div class="line">  %<span class="number">7</span> = integer_literal $<span class="type">Builtin</span>.<span class="type">Int64</span>, <span class="number">42</span>, loc <span class="string">"sample.swift"</span>:<span class="number">10</span>:<span class="number">16</span>, scope <span class="number">17</span> <span class="comment">// user: %8</span></div><div class="line">  %<span class="number">8</span> = <span class="class"><span class="keyword">struct</span> <span class="title">$Int</span> (%7 : <span class="title">$Builtin</span>.<span class="title">Int64</span>), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:16, <span class="title">scope</span> 17 // <span class="title">user</span>: %10</span></div><div class="line">  %9 = <span class="title">class_method</span> %6 : <span class="title">$aClass</span>, #<span class="title">aClass</span>.<span class="title">value</span>!<span class="title">setter</span>.1 : (<span class="title">aClass</span>) -&gt; (<span class="title">Int</span>) -&gt; () , <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:14, <span class="title">scope</span> 17 // <span class="title">user</span>: %10</div><div class="line">  %10 = <span class="title">apply</span> %9(%8, %6) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:14, <span class="title">scope</span> 17</div><div class="line">  <span class="title">strong_release</span> %6 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":10:16, <span class="title">scope</span> 17 // <span class="title">id</span>: %11</div><div class="line">  /*</div><div class="line">    接下来讨论 <span class="title">c2</span>。</div><div class="line">    获取可选值，然后根据它的内容执行接下来的分支语句。</div><div class="line"></div><div class="line">    <span class="title">If</span> <span class="title">the</span> <span class="title">optional</span> <span class="title">has</span> <span class="title">a</span> <span class="title">value</span> <span class="title">the</span> <span class="title">bb2</span> <span class="title">block</span> <span class="title">will</span> <span class="title">be</span> <span class="title">executed</span> <span class="title">before</span> <span class="title">jumping</span> </div><div class="line">    <span class="title">to</span> <span class="title">bb3</span>, <span class="title">if</span> <span class="title">it</span> <span class="title">doesn</span>'<span class="title">t</span> <span class="title">after</span> <span class="title">a</span> <span class="title">brief</span> <span class="title">jump</span> <span class="title">to</span> <span class="title">bb1</span>, <span class="title">the</span> <span class="title">function</span> <span class="title">will</span> <span class="title">proceed</span> <span class="title">to</span> <span class="title">bb3</span> <span class="title">releasing</span></div><div class="line">    <span class="title">the</span> <span class="title">retained</span> <span class="title">parameters</span>.</div><div class="line">    </div><div class="line">  */</div><div class="line">  %12 = <span class="title">load_weak</span> %3 : <span class="title">$</span>*@<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":11:18, <span class="title">scope</span> 18 // <span class="title">user</span>: %13</div><div class="line">  <span class="title">switch_enum</span> %12 : <span class="title">$Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">case</span> #<span class="title">Optional</span>.<span class="title">some</span>!<span class="title">enumelt</span>.1: <span class="title">bb2</span>, <span class="title">default</span> <span class="title">bb1</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":11:18, <span class="title">scope</span> 18 // <span class="title">id</span>: %13</div><div class="line">  <span class="title">bb1</span>:                                              // <span class="title">Preds</span>: <span class="title">bb0</span></div><div class="line">  /*</div><div class="line">    跳转到闭包的结尾。</div><div class="line">  */</div><div class="line">  <span class="title">br</span> <span class="title">bb3</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":11:18, <span class="title">scope</span> 16        // <span class="title">id</span>: %14</div><div class="line"></div><div class="line">// %15                                            // <span class="title">users</span>: %21, %20, %19, %16</div><div class="line"><span class="title">bb2</span>(%15 : <span class="title">$aClass</span>):                               // <span class="title">Preds</span>: <span class="title">bb0</span></div><div class="line">  /*</div><div class="line">    调用 <span class="title">aClass</span> 的 <span class="title">setter</span>，设置它的值为 42.</div><div class="line">  */</div><div class="line">  ...</div><div class="line">  %17 = <span class="title">integer_literal</span> <span class="title">$Builtin</span>.<span class="title">Int64</span>, 42, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:21, <span class="title">scope</span> 19 // <span class="title">user</span>: %18</div><div class="line">  %18 = <span class="title">struct</span> <span class="title">$Int</span> (%17 : <span class="title">$Builtin</span>.<span class="title">Int64</span>), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:21, <span class="title">scope</span> 19 // <span class="title">user</span>: %20</div><div class="line">  %19 = <span class="title">class_method</span> %15 : <span class="title">$aClass</span>, #<span class="title">aClass</span>.<span class="title">value</span>!<span class="title">setter</span>.1 : (<span class="title">aClass</span>) -&gt; (<span class="title">Int</span>) -&gt; () , <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:19, <span class="title">scope</span> 19 // <span class="title">user</span>: %20</div><div class="line">  %20 = <span class="title">apply</span> %19(%18, %15) : <span class="title">$</span>@<span class="title">convention</span>(<span class="title">method</span>) (<span class="title">Int</span>, @<span class="title">guaranteed</span> <span class="title">aClass</span>) -&gt; (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":12:19, <span class="title">scope</span> 19</div><div class="line">  <span class="title">strong_release</span> %15 : <span class="title">$aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":13:5, <span class="title">scope</span> 18 // <span class="title">id</span>: %21</div><div class="line">  <span class="title">br</span> <span class="title">bb3</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":13:5, <span class="title">scope</span> 18         // <span class="title">id</span>: %22</div><div class="line"></div><div class="line"><span class="title">bb3</span>:                                              // <span class="title">Preds</span>: <span class="title">bb1</span> <span class="title">bb2</span></div><div class="line">  /*</div><div class="line">    释放所有获取的变量然后返回。</div><div class="line">  */</div><div class="line">  <span class="title">strong_release</span> %1 : <span class="title">$</span>@<span class="title">box</span> @<span class="title">sil_weak</span> <span class="title">Optional</span>&lt;<span class="title">aClass</span>&gt;, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">id</span>: %23</div><div class="line">  <span class="title">unowned_release</span> %0 : <span class="title">$</span>@<span class="title">sil_unowned</span> <span class="title">aClass</span>, <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">id</span>: %24</div><div class="line">  %25 = <span class="title">tuple</span> (), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">user</span>: %26</div><div class="line">  <span class="title">return</span> %25 : <span class="title">$</span>(), <span class="title">loc</span> "<span class="title">sample</span>.<span class="title">swift</span>":14:1, <span class="title">scope</span> 17 // <span class="title">id</span>: %26</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，忽略掉不同的 <code>ARC</code> 指令带来的性能的差异点，对不同阶段每种类型的捕获变量做一个快速的对比：</p>
<table>
<thead>
<tr>
<th>动作</th>
<th style="text-align:center">Unowned</th>
<th style="text-align:right">Weak</th>
</tr>
</thead>
<tbody>
<tr>
<td>预先调用 #1</td>
<td style="text-align:center">对象进行 unowned_retain 操作</td>
<td style="text-align:right">创建一个容器，并且对象进行 strong_retain 操作。创建一个可选值，存入到容器中，然后释放可选值</td>
</tr>
<tr>
<td>预先调用 #2</td>
<td style="text-align:center">strong_retain_unowned，unowned_retain 和 strong_release</td>
<td style="text-align:right">strong_retain</td>
</tr>
<tr>
<td>闭包执行</td>
<td style="text-align:center">strong_retain_unowned，unowned_release</td>
<td style="text-align:right">load_weak, 打开可选值, strong_release</td>
</tr>
<tr>
<td>调用之后</td>
<td style="text-align:center">unowned_release</td>
<td style="text-align:right">strong_release</td>
</tr>
</tbody>
</table>
<p>正如上面看到的 SIL 代码段那样，处理 weak 引用会涉及到更多的工作，因为需要处理引用需要的可选值。</p>
<p>参照<a href="https://github.com/apple/swift/blob/master/docs/SIL.rst%22" target="_blank" rel="external">官方文档</a>的描述，这里对涉及到的所有 ARC 指令做一个简要的解释：</p>
<ul>
<li><strong>unowned_retain</strong>：<em>增加堆对象中的 unowned 引用计数。</em></li>
<li><strong>strong_retain_unowned</strong> ：<em>断言对象的强引用计数大于 0，然后增加这个引用计数。</em></li>
<li><strong>strong_retain</strong>：<em>增加对象的强引用计数。</em></li>
<li><strong>load_weak</strong>：<em>不是真正的 ARC 调用，但是它将增加可选值指向对象的强引用计数。</em></li>
<li><strong>strong_release</strong>：<em>减少对象的强引用计数。如果释放操作把对象强引用计数变为0，对象将被销毁，然后弱引用将被清除。当整个强引用计数和 unowned 引用计数都为0时，对象的内存才会被释放。</em></li>
<li><strong>unowned_release</strong>：<em>减少对象的 unowned 引用计数。当整个强引用计数和 unowned 引用计数都为 0 时，对象的内存才会被释放。</em></li>
</ul>
<p>接下来深入到 <code>Swift</code> 运行时看看，这些指令都是如何被实现的，相关的代码文件有：<a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/HeapObject.cpp" target="_blank" rel="external">HeapObject.cpp</a>，<a href="https://github.com/apple/swift/blob/master/include/swift/Runtime/HeapObject.h" target="_blank" rel="external">HeapObject.h</a>，<a href="https://github.com/apple/swift/blob/master/stdlib/public/SwiftShims/RefCount.h" target="_blank" rel="external">RefCount.h</a> 和 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/Heap.cpp" target="_blank" rel="external">Heap.cpp</a>、 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/SwiftObject.mm" target="_blank" rel="external">SwiftObject.mm</a> 中的少量定义。容器实现可以在 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/MetadataImpl.h" target="_blank" rel="external">MetadataImpl.h</a> 找到，但是本文不展开讨论。</p>
<p>这些文件中定义大多数的 <code>ARC</code> 方法都有三种变体，一种是对 <code>Swift</code> 对象的基础实现，另外两种实现是针对非原生 Swift 对象的：桥接对象和未知对象。后面两种变体这里不予讨论。</p>
<p>第一个讨论指令集和 <code>unowned</code> 引用相关。</p>
<p>在 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/HeapObject.cpp" target="_blank" rel="external">HeapObject.cpp</a> 文件中间可以看到对 <code>unowned_retain</code> 和 <code>unowned_release</code> 的实现方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">SWIFT_RT_ENTRY_VISIBILITY</span></div><div class="line">void swift::swift_unownedRetain(<span class="type">HeapObject</span> *object)</div><div class="line">    <span class="type">SWIFT_CC</span>(<span class="type">RegisterPreservingCC_IMPL</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (!object)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  object-&gt;weakRefCount.increment();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">SWIFT_RT_ENTRY_VISIBILITY</span></div><div class="line">void swift::swift_unownedRelease(<span class="type">HeapObject</span> *object)</div><div class="line">    <span class="type">SWIFT_CC</span>(<span class="type">RegisterPreservingCC_IMPL</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (!object)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (object-&gt;weakRefCount.decrementShouldDeallocate()) &#123;</div><div class="line">    <span class="comment">// Only class objects can be weak-retained and weak-released.</span></div><div class="line">    auto metadata = object-&gt;metadata;</div><div class="line">    <span class="built_in">assert</span>(metadata-&gt;isClassObject());</div><div class="line">    auto classMetadata = static_cast&lt;const <span class="type">ClassMetadata</span>*&gt;(metadata);</div><div class="line">    <span class="built_in">assert</span>(classMetadata-&gt;isTypeMetadata());</div><div class="line">    <span class="type">SWIFT_RT_ENTRY_CALL</span>(swift_slowDealloc)</div><div class="line">        (object, classMetadata-&gt;getInstanceSize(),</div><div class="line">         classMetadata-&gt;getInstanceAlignMask());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>swift_unownedRetain</code> 是 <code>unowned_retain</code> 的具体实现，简单地进行 <code>unowned</code> 引用计数的原子增加操作（这里定义为<code>weakRefCount</code>），<code>swift_unownedRelease</code> 更加复杂，原因之前也描述过，当没有其他 unowned 引用存在时，它需要执行对象的析构操作。</p>
<p>但是整体来讲都不复杂，在<a href="https://github.com/apple/swift/blob/master/stdlib/public/SwiftShims/RefCount.h#L242" target="_blank" rel="external">这里</a>可以看到 <code>doDecrementShouldDeallocate</code> 方法，这个方法在上面代码中被一个命名类似的方法调用了。这个方法没有做太多，<code>swift_slowDealloc</code> 只是释放给定的指针。</p>
<p>到此已经有了一个对象的 unowned 引用，另外一个指令，<code>strong_retain_unowned</code> 用来创建一个强引用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">SWIFT_RT_ENTRY_VISIBILITY</span></div><div class="line">void swift::swift_unownedRetainStrong(<span class="type">HeapObject</span> *object)</div><div class="line">    <span class="type">SWIFT_CC</span>(<span class="type">RegisterPreservingCC_IMPL</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (!object)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  <span class="built_in">assert</span>(object-&gt;weakRefCount.getCount() &amp;&amp;</div><div class="line">         <span class="string">"object is not currently weakly retained"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (! object-&gt;refCount.tryIncrement())</div><div class="line">    _swift_abortRetainUnowned(object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为弱引用应该指向了这个对象，要使用断言来验证对象是否被弱引用，一旦断言通过，将尝试进行增加强引用计数的操作。一旦对象在进程中已经被释放，尝试将会失败。</p>
<p>所有类似于 <code>tryIncrement</code> 通过某种形式修改引用计数的方法都放到 <a href="https://github.com/apple/swift/blob/master/stdlib/public/SwiftShims/RefCount.h" target="_blank" rel="external">RefCount.h</a> 中，需要使用原子操作进行这些任务。</p>
<p>接下来讨论下 <code>weak</code> 引用的的实现，正如之前看到的那样，<code>swift_weakLoadStrong</code> 用来获取容器中可选值中强引用的对象。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">HeapObject</span> *swift::swift_weakLoadStrong(<span class="type">WeakReference</span> *ref) &#123;</div><div class="line">  <span class="keyword">if</span> (ref-&gt;<span class="type">Value</span> == (uintptr_t)nullptr) &#123;</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ref 可能被其他线程访问</span></div><div class="line">  auto ptr = __atomic_fetch_or(&amp;ref-&gt;<span class="type">Value</span>, <span class="type">WR_READING</span>, __ATOMIC_RELAXED);</div><div class="line">  <span class="keyword">while</span> (ptr &amp; <span class="type">WR_READING</span>) &#123;</div><div class="line">    short <span class="built_in">c</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (__atomic_load_n(&amp;ref-&gt;<span class="type">Value</span>, __ATOMIC_RELAXED) &amp; <span class="type">WR_READING</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (++<span class="built_in">c</span> == <span class="type">WR_SPINLIMIT</span>) &#123;</div><div class="line">        std::this_thread::yield();</div><div class="line">        <span class="built_in">c</span> -= <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    ptr = __atomic_fetch_or(&amp;ref-&gt;<span class="type">Value</span>, <span class="type">WR_READING</span>, __ATOMIC_RELAXED);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  auto object = (<span class="type">HeapObject</span>*)(ptr &amp; ~<span class="type">WR_NATIVE</span>);</div><div class="line">  <span class="keyword">if</span> (object == nullptr) &#123;</div><div class="line">    __atomic_store_n(&amp;ref-&gt;<span class="type">Value</span>, (uintptr_t)nullptr, __ATOMIC_RELAXED);</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (object-&gt;refCount.isDeallocating()) &#123;</div><div class="line">    __atomic_store_n(&amp;ref-&gt;<span class="type">Value</span>, (uintptr_t)nullptr, __ATOMIC_RELAXED);</div><div class="line">    <span class="type">SWIFT_RT_ENTRY_CALL</span>(swift_unownedRelease)(object);</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line">  &#125;</div><div class="line">  auto result = swift_tryRetain(object);</div><div class="line">  __atomic_store_n(&amp;ref-&gt;<span class="type">Value</span>, ptr, __ATOMIC_RELAXED);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个实现中，获取一个强引用需要<a href="https://github.com/apple/swift/pull/1454" target="_blank" rel="external">更多复杂同步操作</a>，在多线程竞争严重的情况下，会带来性能损耗。</p>
<p>在这里第一次出现的 <code>WeakReference</code> 对象，是一个简单的结构体，包含一个整型值字段指向目标对象，目标对象是使用 <code>HeapObject</code> 类来承载的每一个运行时的 Swift 对象。 </p>
<p>在 weak 引用询问当前线程设置的 <code>WR_READING</code> 标识之后，从  <code>WeakReference</code>  容器中获取 Swift 对象，如果对象不再有效，或者在等待获取资源时，它变成可以进行析构，当前的引用会被设置为 <em>null</em>。</p>
<p>如果对象依然有效，获取对象的尝试将会成功。</p>
<p>因此，从这个角度来讲，对 weak 引用的常规操作性能比 unowned 引用的更低（但是主要的问题还是在可选值操作上面）。</p>
<p><a name="conclusion"></a></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>保守的使用 weak 引用是否明智呢？答案是否定的，无论是从性能的角度还是代码清晰的角度而言。</p>
<p>使用正确的捕获修饰符类型，明确的表明代码中的生命周期特性，当其他人或者你自己在读你的代码时不容易误解。</p>
<p><a name="footnotes"></a></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p><a name="1"></a><br>1、<em>苹果第一次讨论 weak/unowned 争议可以查看<a href="https://devforums.apple.com/message/987086#987086" target="_blank" rel="external">这里</a>，之后在 twitter 上 Joe Groff 对此也进行了讨论，并且被 Michael Tsai <a href="http://mjtsai.com/blog/2015/11/24/how-swift-implements-unowned-and-weak-references/" target="_blank" rel="external">总结成文</a>。<br>这篇文章从意图角度出发，提供了完整并且可操作的解释。</em></p>
<p><a name="2"></a><br>2、<em>从<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">维基百科</a>中可以找到关于 AST 的解释，还可以从 Slava Pestov 的<a href="https://medium.com/@slavapestov/the-secret-life-of-types-in-swift-ff83c3c000a5#.jyxx86n2x" target="_blank" rel="external">这篇文章</a>中看到关于 Swift 编译器中如何实现 AST 的一些细节。</em></p>
<p><a name="3"></a><br>3、<em>关于 SIL 的更多信息，请查看详尽的<a href="https://github.com/apple/swift/blob/master/docs/SIL.rst" target="_blank" rel="external">官方 SIL 指南</a>，还有 2015 LLVM 开发者会议的<a href="https://www.youtube.com/watch?v=Ntj8ab-5cvE" target="_blank" rel="external">视频</a>。Lex Chou 写的 SIL 快速指南可以点击这里<a href="https://github.com/lexchou/swallow/tree/master/docs/en/sil-3-instruction-references" target="_blank" rel="external">查看</a>。 </em></p>
<p><a name="4"></a><br>4、<em>查看在 Swift 中如何进行名称粉碎（name mangling）的细节，请查看 Lex Chou 的<a href="https://github.com/lexchou/swallow/tree/master/docs/en/sil-1-mangling" target="_blank" rel="external">这篇文章</a>。</em></p>
<p><a name="5"></a><br>5、<em>Mike Ash 在他的 Friday Q&amp;A 中的<a href="https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html" target="_blank" rel="external">一篇文章</a>中讨论了如何实现 weak 引用的一种实践方法，这种方法与目前 Swift 的方法对比起来有一些过时，但是其中的解释依然值得参考。</em></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Umberto Raimondi，&lt;a href=&quot;https://www.uraimo.com/2016/10/27/unowned-or-weak-lifetime-and-performance/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-10-27&lt;br&gt;译者：&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;shanks&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;每当处理循环引用（retain cycles）时，需要考量对象生命周期来选择&lt;code&gt;unowned&lt;/code&gt;或者&lt;code&gt;weak&lt;/code&gt;标识符，这已经成为了一个共识。但是有时仍然会心存疑问，在具体的使用中应该选择哪一个，或者退一步讲，保守的只使用 weak 是不是一个好的选择呢？&lt;/p&gt;
&lt;p&gt;本文首先对循环引用的基础知识做一个简要介绍，然后会分析 Swift 源代码的一些片段，讲解 &lt;code&gt;unowned&lt;/code&gt; 和 &lt;code&gt;weak&lt;/code&gt;  在生命周期和性能上的差异点，希望看完本文以后，在的使用场景中，能使用正确的弱引用类型。&lt;/p&gt;
    
    </summary>
    
      <category term="uraimo" scheme="https://swift.gg/categories/uraimo/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>在 iOS 上用 Core Image 实现人脸检测</title>
    <link href="https://swift.gg/2017/05/11/face-detection-core-image/"/>
    <id>https://swift.gg/2017/05/11/face-detection-core-image/</id>
    <published>2017-05-10T16:00:00.000Z</published>
    <updated>2017-07-16T00:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Gregg Mojica，<a href="http://www.appcoda.com/face-detection-core-image/" target="_blank" rel="external">原文链接</a>，原文日期：2016-09-06<br>译者：<a href="http://hulizhen.me" target="_blank" rel="external">智多芯</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="external">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a></p>
</blockquote>
<!--此处开始正文-->
<p>Core Image 是 Cocoa Touch 框架提供的功能强大的 API，是 iOS SDK 中常常被忽视的关键部件。本教程将尝试探索 Core Image 提供的人脸识别功能，并将其应用到 iOS App 中。</p>
<blockquote>
<p>注：这是中高级 iOS 教程，本教程假设你已经使用过类似 UIImagePicker，Core Image 等技术。如果你对这些还不熟悉，先看看<a href="http://www.appcoda.com/ios-programming-course" target="_blank" rel="external">我们的 iOS 教程系列</a>，等你准备好了再看这篇文章。</p>
</blockquote>
<a id="more"></a>
<h2 id="接下来要做的事"><a href="#接下来要做的事" class="headerlink" title="接下来要做的事"></a>接下来要做的事</h2><p>自从 iOS 5（大概在2011年左右）之后，iOS 开始支持人脸识别，只是用的人不多。人脸识别 API 让开发者不仅可以进行人脸检测，还能识别微笑、眨眼等表情。</p>
<p>首先创建一个简单的应用，探索一下 Core Image 提供的人脸识别技术，该应用可以识别出照片中的人脸并用方框将人脸框起来。在第二个例子中，用户可以拍照并检测照片上是否有人脸出现，如果有则提取人脸坐标。通过这两个例子，你将学会 iOS 上所有关于人脸识别的技术，并充分利用它强大却经常被忽视的功能。</p>
<p>下面开始吧！</p>
<h2 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h2><p><a href="https://github.com/appcoda/FaceDetector/raw/master/FaceDetectorStarter.zip" target="_blank" rel="external">下载</a>并在 Xcode 中打开起始工程。该工程中的 Storyboard 仅包含一个已连接到代码的 IBOutlet 和 imageView。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/09/face-detection-storyboard.jpg" alt=""></p>
<blockquote>
<p><strong>注</strong>：项目中的图片由 <a href="http://unsplash.com/" target="_blank" rel="external">unsplash.com</a> 提供。</p>
</blockquote>
<p>在开始使用 Core Image 进行人脸识别之前，需要将 Core Image 库导入项目中。打开 ViewController.swift 文件，在文件最上方插入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> CoreImage</div></pre></td></tr></table></figure>
<h2 id="用-Core-Image-实现人脸检测"><a href="#用-Core-Image-实现人脸检测" class="headerlink" title="用 Core Image 实现人脸检测"></a>用 Core Image 实现人脸检测</h2><p>在起始工程的 storyboard 里包含一个通过 IBOutlet 连接到代码中的 imageView。下一步将实现人脸检测的代码。先把以下代码加入 swift 文件中，后面再解释：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">detect</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> personciImage = <span class="type">CIImage</span>(image: personPic.image!) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> accuracy = [<span class="type">CIDetectorAccuracy</span>: <span class="type">CIDetectorAccuracyHigh</span>]</div><div class="line">    <span class="keyword">let</span> faceDetector = <span class="type">CIDetector</span>(ofType: <span class="type">CIDetectorTypeFace</span>, context: <span class="literal">nil</span>, options: accuracy)</div><div class="line">    <span class="keyword">let</span> faces = faceDetector?.features(<span class="keyword">in</span>: personciImage)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> face <span class="keyword">in</span> faces <span class="keyword">as</span>! [<span class="type">CIFaceFeature</span>] &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Found bounds are \(face.bounds)"</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> faceBox = <span class="type">UIView</span>(frame: face.bounds)</div><div class="line">        faceBox.layer.borderWidth = <span class="number">3</span></div><div class="line">        faceBox.layer.borderColor = <span class="type">UIColor</span>.red.cgColor</div><div class="line">        faceBox.backgroundColor = <span class="type">UIColor</span>.clear</div><div class="line">        personPic.addSubview(faceBox)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasLeftEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Left eye bounds are \(face.leftEyePosition)"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasRightEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Right eye bounds are \(face.rightEyePosition)"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里解释一下上面的代码：</p>
<ul>
<li>第 3 行：从 storyboard 中的 UIImageView 提取出 UIImage 并转换成 CIImage，将其保存在新创建的 <code>personciImage</code> 变量中。Core Image 需要用到 CIImage。</li>
<li>第 7 行：创建一个 <code>accuracy</code> 变量并设置为 <code>CIDetectorAccuracyHigh</code>。你可以选择 <code>CIDetectorAccuracyHigh</code> 或 <code>CIDetectorAccuracyLow</code>。本文希望得到高精度的结果，因此选择了 <code>CIDetectorAccuracyHigh</code>。</li>
<li>第 8 行：创建一个 <code>faceDetector</code> 变量并设置为  <code>CIDetector</code>  的实例。实例化 <code>CIDetector</code> 时将前文创建的 <code>accuracy</code> 作为参数传入。</li>
<li>第 9 行：通过调用 <code>faceDetector</code> 的 <code>features(in:)</code> 方法可检测出给定图像的所有人脸，最终以数组的形式返回所有人脸。</li>
<li>第 11 行：遍历数组中所有的人脸，并将其转换为 <code>CIFaceFeature</code> 类型。</li>
<li>第 15 行：创建一个 UIView 实例并命名为 <code>faceBox</code>，然后根据 <code>faces.first</code> 设置其大小。这将画一个方框用于高亮检测到的人脸。</li>
<li>第 17 行：将 <code>faceBox</code> 的边框宽度设为 3。</li>
<li>第 18 行：将边框颜色设置为红色。</li>
<li>第 19 行：将背景色设为透明，表示该视图没有可见的背景。</li>
<li>第 20 行：最后，将该视图添加到 <code>personPic</code> 视图中。</li>
<li>第 22-28 行：这些 API 不仅可以检测出人脸，还能检测出人脸的左右眼，但本文就不在图像中高亮人眼了。本文只想展示一些 <code>CIFaceFeature</code> 的相关属性。</li>
</ul>
<p>接着调用在 <code>viewDidLoad</code>中调用  <code>detect</code> 方法，在方法中增加下列一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">detect()</div></pre></td></tr></table></figure>
<p>编译并运行程序，可以看到如下效果：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/09/face-detection-2.png" alt=""></p>
<p>根据控制台的输出结果，似乎可以检测出人脸：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">Found</span> bounds are (<span class="number">177.0</span>, <span class="number">415.0</span>, <span class="number">380.0</span>, <span class="number">380.0</span>)</div></pre></td></tr></table></figure>
<p>还有几个问题没有处理：</p>
<ul>
<li>人脸识别程序应用于原始图像上，而原始图像有着比 imageView 更高的分辨率。另外，工程中 imageView 的 content mode 被设置为 aspect fit。为了正确地画出检测框，还需要计算出 imageView 中识别到的人脸的实际位置和尺寸。</li>
<li>再者，Core Image 和 UIView（或者UIKit）使用了不同的坐标系（如下图所示），因此还需要实现 Core Image 坐标到 UIView 坐标的转换。</li>
</ul>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/09/core-image-coordinate-1240x835.jpg" alt=""></p>
<p>现在使用下面的代码替换 <code>detect()</code> 方法中的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">detect</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> personciImage = <span class="type">CIImage</span>(image: personPic.image!) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> accuracy = [<span class="type">CIDetectorAccuracy</span>: <span class="type">CIDetectorAccuracyHigh</span>]</div><div class="line">    <span class="keyword">let</span> faceDetector = <span class="type">CIDetector</span>(ofType: <span class="type">CIDetectorTypeFace</span>, context: <span class="literal">nil</span>, options: accuracy)</div><div class="line">    <span class="keyword">let</span> faces = faceDetector?.features(<span class="keyword">in</span>: personciImage)</div><div class="line">    </div><div class="line">    <span class="comment">// 将 Core Image 坐标转换成 UIView 坐标</span></div><div class="line">    <span class="keyword">let</span> ciImageSize = personciImage.extent.size</div><div class="line">    <span class="keyword">var</span> transform = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1</span>, y: -<span class="number">1</span>)</div><div class="line">    transform = transform.translatedBy(x: <span class="number">0</span>, y: -ciImageSize.height)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> face <span class="keyword">in</span> faces <span class="keyword">as</span>! [<span class="type">CIFaceFeature</span>] &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Found bounds are \(face.bounds)"</span>)</div><div class="line">        </div><div class="line">        <span class="comment">// 实现坐标转换</span></div><div class="line">        <span class="keyword">var</span> faceViewBounds = face.bounds.applying(transform)</div><div class="line">        </div><div class="line">        <span class="comment">// 计算实际的位置和大小</span></div><div class="line">        <span class="keyword">let</span> viewSize = personPic.bounds.size</div><div class="line">        <span class="keyword">let</span> scale = <span class="built_in">min</span>(viewSize.width / ciImageSize.width,</div><div class="line">                        viewSize.height / ciImageSize.height)</div><div class="line">        <span class="keyword">let</span> offsetX = (viewSize.width - ciImageSize.width * scale) / <span class="number">2</span></div><div class="line">        <span class="keyword">let</span> offsetY = (viewSize.height - ciImageSize.height * scale) / <span class="number">2</span></div><div class="line">        </div><div class="line">        faceViewBounds = faceViewBounds.applying(<span class="type">CGAffineTransform</span>(scaleX: scale, y: scale))</div><div class="line">        faceViewBounds.origin.x += offsetX</div><div class="line">        faceViewBounds.origin.y += offsetY</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> faceBox = <span class="type">UIView</span>(frame: faceViewBounds)</div><div class="line">        </div><div class="line">        faceBox.layer.borderWidth = <span class="number">3</span></div><div class="line">        faceBox.layer.borderColor = <span class="type">UIColor</span>.red.cgColor</div><div class="line">        faceBox.backgroundColor = <span class="type">UIColor</span>.clear</div><div class="line">        personPic.addSubview(faceBox)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasLeftEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Left eye bounds are \(face.leftEyePosition)"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasRightEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Right eye bounds are \(face.rightEyePosition)"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，上面的代码使用放射变换将 Core Image 坐标转换成了 UIKit 坐标。然后，添加了一些额外的代码用于计算框视图的实际位置和尺寸。</p>
<p>现在再一次运行程序，应该可以看到检测框将识别出的人脸框起来了，这样就成功地用 Core Image 检测到人脸了。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/09/face-detection-result-1240x809.jpg" alt=""></p>
<h2 id="开发一个支持人脸识别的摄像应用"><a href="#开发一个支持人脸识别的摄像应用" class="headerlink" title="开发一个支持人脸识别的摄像应用"></a>开发一个支持人脸识别的摄像应用</h2><p>假设有一个用于摄像或拍照的应用程序，我们希望在拍照后检测是否有人脸出现。如果出现了人脸，可能想将这张照片打上一些标签并对其分类。下面结合 <code>UIImagePicker</code> 类，拍照完成时立刻运行上面的人脸检测代码。</p>
<p>上面的起始工程中已经创建了一个 <code>CameraViewController</code> 类，将其代码更新成下面这样，用以实现摄像功能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraViewController</span>: <span class="title">UIViewController</span>, <span class="title">UIImagePickerControllerDelegate</span>, <span class="title">UINavigationControllerDelegate</span> </span>&#123;</div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span>!</div><div class="line">    <span class="keyword">let</span> imagePicker = <span class="type">UIImagePickerController</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        imagePicker.delegate = <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">takePhoto</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> !<span class="type">UIImagePickerController</span>.isSourceTypeAvailable(.camera) &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        imagePicker.allowsEditing = <span class="literal">false</span></div><div class="line">        imagePicker.sourceType = .camera</div><div class="line">        </div><div class="line">        present(imagePicker, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any])</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> pickedImage = info[<span class="type">UIImagePickerControllerOriginalImage</span>] <span class="keyword">as</span>? <span class="type">UIImage</span> &#123;</div><div class="line">            imageView.contentMode = .scaleAspectFit</div><div class="line">            imageView.image = pickedImage</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">self</span>.detect()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">imagePickerControllerDidCancel</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController)</span></span> &#123;</div><div class="line">        dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开始的几行代码设置了 <code>UIImagePicker</code> 代理。在 <code>didFinishPickingMediaWithInfo</code> 方法（这是一个 <code>UIImagePicker</code> 代理方法）中，将传入的图像设置到 imageView 上，最后关闭拾取器并调用 <code>detect</code> 函数。</p>
<p>上面的代码还未实现 <code>detect</code> 函数，将下面的代码加上：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">detect</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> imageOptions = <span class="type">NSDictionary</span>(object: <span class="type">NSNumber</span>(value: <span class="number">5</span>) <span class="keyword">as</span> <span class="type">NSNumber</span>, forKey: <span class="type">CIDetectorImageOrientation</span> <span class="keyword">as</span> <span class="type">NSString</span>)</div><div class="line">    <span class="keyword">let</span> personciImage = <span class="type">CIImage</span>(cgImage: imageView.image!.cgImage!)</div><div class="line">    <span class="keyword">let</span> accuracy = [<span class="type">CIDetectorAccuracy</span>: <span class="type">CIDetectorAccuracyHigh</span>]</div><div class="line">    <span class="keyword">let</span> faceDetector = <span class="type">CIDetector</span>(ofType: <span class="type">CIDetectorTypeFace</span>, context: <span class="literal">nil</span>, options: accuracy)</div><div class="line">    <span class="keyword">let</span> faces = faceDetector?.features(<span class="keyword">in</span>: personciImage, options: imageOptions <span class="keyword">as</span>? [<span class="type">String</span> : <span class="type">AnyObject</span>])</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> face = faces?.first <span class="keyword">as</span>? <span class="type">CIFaceFeature</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"found bounds are \(face.bounds)"</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"Say Cheese!"</span>, message: <span class="string">"We detected a face!"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</div><div class="line">        alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</div><div class="line">        <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasSmile &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"face is smiling"</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasLeftEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Left eye bounds are \(face.leftEyePosition)"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> face.hasRightEyePosition &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Right eye bounds are \(face.rightEyePosition)"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"No Face!"</span>, message: <span class="string">"No face was detected"</span>, preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</div><div class="line">        alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</div><div class="line">        <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 detect() 函数和之前的实现非常相似，不过这一次我们使用的是临时拍到的图像。根据检测结果会显示一个提示框，提示是否检测到人脸。运行程序来快速测试一下。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/08/faces.png" alt=""></p>
<p>CIFaceFeature 中的一些属性和方法前面已经尝试过了。例如，若要判断照片中的人是否正在微笑，可以通过 <code>hasSmile</code> 属性判断。还可以通过 <code>hasLeftEyePosition</code>  （或<code>hasRightEyePosition</code>）属性检查是否有左眼（或右眼）出现（希望有）。</p>
<p>还可以通过 <code>hasMouthPosition</code> 来判断是否出现了嘴巴。如果出现了，可以通过 <code>mouthPosition</code> 属性得到其坐标，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (face.hasMouthPosition) &#123;</div><div class="line">     <span class="built_in">print</span>(<span class="string">"mouth detected"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，通过 Core Image 进行人脸识别极其简单。除了检测嘴、微笑、眼睛位置等，还可以通过 <code>leftEyeClosed</code> （或<code>rightEyeClosed</code>）判断左眼（或右眼）是否睁开。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本教程探索了 Core Image 提供的人脸识别 API，并展示了如何在摄像机应用中使用该功能。本文通过 UIImagePicker 拍摄图像，并检测该图像中是否有人的出现。</p>
<p>如你所见，Core Image 的人脸识别 API 有着非常多的用处！希望你能觉得本教程有所帮助，让你了解到了这一鲜为人知的 iOS API！</p>
<blockquote>
<p> 注：欢迎继续关注让人脸识别更加强大的<a href="https://www.appcoda.com/tag/neural-net/" target="_blank" rel="external">神经网络系列教程</a>。</p>
</blockquote>
<p>你可以从<a href="https://github.com/appcoda/FaceDetector" target="_blank" rel="external">这里</a>下载到最终的工程代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Gregg Mojica，&lt;a href=&quot;http://www.appcoda.com/face-detection-core-image/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-09-06&lt;br&gt;译者：&lt;a href=&quot;http://hulizhen.me&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;智多芯&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Core Image 是 Cocoa Touch 框架提供的功能强大的 API，是 iOS SDK 中常常被忽视的关键部件。本教程将尝试探索 Core Image 提供的人脸识别功能，并将其应用到 iOS App 中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：这是中高级 iOS 教程，本教程假设你已经使用过类似 UIImagePicker，Core Image 等技术。如果你对这些还不熟悉，先看看&lt;a href=&quot;http://www.appcoda.com/ios-programming-course&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我们的 iOS 教程系列&lt;/a&gt;，等你准备好了再看这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="AppCoda" scheme="https://swift.gg/categories/AppCoda/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
